{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\nHello world 예제\r\n기본적으로 이 앱은 여러분이 작성할 수 있는 가장 간단한 Express 앱일 것입니다. 이 앱은 하나의 파일로 된 앱이며 Express 생성기를 통해 얻게 되는 앱과는 같지 않습니다. (이 예제와 달리 Express 생성기를 통해 얻게 되는 앱은 다양한 목적을 위한 여러 JavaScript 파일, Jade 템플리트 및 하위 디렉토리를 포함하는 전체 앱에 대한 스캐폴딩을 작성합니다.)\r\n먼저, myapp이라는 이름의 디렉토리를 작성한 후 이 디렉토리로 이동하여 npm init를 실행하십시오. 이후 설치 안내서에 따라 express를 종속 항목으로서 설치하십시오.\r\nmyapp 디렉토리에 app.js라는 이름의 파일을 작성한 후 다음과 같은 코드를 추가하십시오.\r\n\r\nvar express = require('express');\r\nvar app = express();\r\napp.get('/', function (req, res) {\r\nres.send('Hello World!');\r\n});\r\napp.listen(3000, function () {\r\nconsole.log('Example app listening on port 3000!');\r\n});\r\n앱은 서버를 시작하며 3000번 포트에서 연결을 청취합니다. 앱은 루트 URL(/) 또는 라우트에 대한 요청에 “Hello World!”로 응답합니다. 다른 모든 경로에 대해서는 404 Not Found로 응답합니다.\r\nreq(요청) 및 res(응답)는 Node가 제공하는 동일한 오브젝트이며, 따라서 req.pipe(), req.on('data', callback) 그리고 Express의 관여가 필요 없는 다른 모든 항목을 호출할 수 있습니다.\r\n다음의 명령을 이용하여 앱을 실행하십시오.\r\n\r\n\\$ node app.js\r\n이후 브라우저에서 http://localhost:3000/을 로드하여 결과물을 확인하십시오.\r\n\r\n출처: <https://expressjs.com/ko/starter/hello-world.html>\r\n\r\nExpress 애플리케이션 생성기\r\n애플리케이션의 골격을 신속하게 작성하려면 애플리케이션 생성기 도구인 express를 사용하십시오.\r\n다음의 명령을 이용해 express를 설치하십시오.\r\n\r\n\\$ npm install express-generator -g\r\n다음과 같이 -h 옵션을 이용해 명령의 옵션을 표시하십시오.\r\n\r\n\\$ express -h\r\nUsage: express [options][dir]\r\nOptions:\r\n-h, --help output usage information\r\n--version output the version number\r\n-e, --ejs add ejs engine support\r\n--hbs add handlebars engine support\r\n--pug add pug engine support\r\n-H, --hogan add hogan.js engine support\r\n--no-view generate without view engine\r\n-v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)\r\n-c, --css <engine> add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)\r\n--git add .gitignore\r\n-f, --force force on non-empty directory\r\n예를 들면, 다음의 예에서는 *myapp*라는 이름의 Express 앱을 현재 작업 디렉토리에 작성합니다.\r\n\r\n\\$ express --view=pug myapp\r\ncreate : myapp\r\ncreate : myapp/package.json\r\ncreate : myapp/app.js\r\ncreate : myapp/public\r\ncreate : myapp/public/javascripts\r\ncreate : myapp/public/images\r\ncreate : myapp/routes\r\ncreate : myapp/routes/index.js\r\ncreate : myapp/routes/users.js\r\ncreate : myapp/public/stylesheets\r\ncreate : myapp/public/stylesheets/style.css\r\ncreate : myapp/views\r\ncreate : myapp/views/index.pug\r\ncreate : myapp/views/layout.pug\r\ncreate : myapp/views/error.pug\r\ncreate : myapp/bin\r\ncreate : myapp/bin/www\r\n이후 다음과 같이 종속 항목을 설치하십시오.\r\n\r\n$ cd myapp\r\n$ npm install\r\nMacOS 또는 Linux에서는 다음 명령을 사용하여 앱을 실행하십시오.\r\n\r\n\\$ DEBUG=myapp:\\* npm start\r\nWindows에서는 다음 명령을 사용하십시오.\r\n\r\n> set DEBUG=myapp:\\* & npm start\r\n> 이후 브라우저에서 http://localhost:3000/을 로드하여 앱에 액세스하십시오.\r\n> 생성된 앱은 다음과 같은 디렉토리 구조를 갖습니다.\r\n\r\n.\r\n├── app.js\r\n├── bin\r\n│ └── www\r\n├── package.json\r\n├── public\r\n│ ├── images\r\n│ ├── javascripts\r\n│ └── stylesheets\r\n│ └── style.css\r\n├── routes\r\n│ ├── index.js\r\n│ └── users.js\r\n└── views\r\n├── error.pug\r\n├── index.pug\r\n└── layout.pug\r\n7 directories, 9 files\r\n생성기에 의해 작성된 앱 구조는 Express 앱을 구조화하는 여러 방법 중 하나에 불과합니다. 이러한 구조를 사용하거나 사용자의 요구사항에 가장 적합하도록 구조를 수정하십시오.\r\n\r\n출처: <https://expressjs.com/ko/starter/generator.html>\r\n\r\n기본 라우팅\r\n라우팅은 URI(또는 경로) 및 특정한 HTTP 요청 메소드(GET, POST 등)인 특정 엔드포인트에 대한 클라이언트 요청에 애플리케이션이 응답하는 방법을 결정하는 것을 말합니다.\r\n각 라우트는 하나 이상의 핸들러 함수를 가질 수 있으며, 이러한 함수는 라우트가 일치할 때 실행됩니다.\r\n라우트 정의에는 다음과 같은 구조가 필요합니다.\r\n\r\napp.METHOD(PATH, HANDLER)\r\n여기서,\r\n• app은 express의 인스턴스입니다.\r\n• METHOD는 HTTP 요청 메소드입니다.\r\n• PATH는 서버에서의 경로입니다.\r\n• HANDLER는 라우트가 일치할 때 실행되는 함수입니다.\r\n이 학습서에서는 app이라는 이름의 express 인스턴스가 작성되며 서버가 실행 중인 것으로 가정합니다. 앱의 작성 및 시작에 익숙하지 않은 경우에는 Hello world 예제를 참조하십시오.\r\n다음 예에서는 간단한 라우트의 정의를 설명합니다.\r\n홈 페이지에서 Hello World!로 응답:\r\n\r\napp.get('/', function (req, res) {\r\nres.send('Hello World!');\r\n});\r\n애플리케이션의 홈 페이지인 루트 라우트(/)에서 POST 요청에 응답:\r\n\r\napp.post('/', function (req, res) {\r\nres.send('Got a POST request');\r\n});\r\n/user 라우트에 대한 PUT 요청에 응답:\r\n\r\napp.put('/user', function (req, res) {\r\nres.send('Got a PUT request at /user');\r\n});\r\n/user 라우트에 대한 DELETE 요청에 응답:\r\n\r\napp.delete('/user', function (req, res) {\r\nres.send('Got a DELETE request at /user');\r\n});\r\n라우팅에 대한 자세한 내용을 확인하려면 라우팅 안내서를 참조하십시오.\r\n\r\n출처: <https://expressjs.com/ko/starter/basic-routing.html>\r\n\r\nExpress에서 정적 파일 제공\r\n이미지, CSS 파일 및 JavaScript 파일과 같은 정적 파일을 제공하려면 Express의 기본 제공 미들웨어 함수인 express.static을 사용하십시오.\r\n정적 자산이 포함된 디렉토리의 이름을 express.static 미들웨어 함수에 전달하면 파일의 직접적인 제공을 시작할 수 있습니다. 예를 들면, 다음과 같은 코드를 이용하여 public이라는 이름의 디렉토리에 포함된 이미지, CSS 파일 및 JavaScript 파일을 제공하십시오.\r\n\r\napp.use(express.static('public'));\r\n이제 다음과 같이 public 디렉토리에 포함된 파일을 로드할 수 있습니다.\r\n\r\nhttp://localhost:3000/images/kitten.jpg\r\nhttp://localhost:3000/css/style.css\r\nhttp://localhost:3000/js/app.js\r\nhttp://localhost:3000/images/bg.png\r\nhttp://localhost:3000/hello.html\r\nExpress는 정적 디렉토리에 대해 상대적으로 파일을 검색하며, 따라서 정적 디렉토리의 이름은 URL의 일부가 아닙니다.\r\n여러 개의 정적 자산 디렉토리를 이용하려면 다음과 같이 express.static 미들웨어 함수를 여러 번 호출하십시오.\r\n\r\napp.use(express.static('public'));\r\napp.use(express.static('files'));\r\nExpress는 express.static 미들웨어 함수를 이용해 정적 디렉토리를 설정한 순서대로 파일을 검색합니다.\r\nexpress.static 함수를 통해 제공되는 파일에 대한 가상 경로 접두부(파일 시스템 내에 해당 경로가 실제로 존재하지 않는 경우)를 작성하려면, 아래에 표시된 것과 같이 정적 디렉토리에 대한 마운트 경로를 지정하십시오.\r\n\r\napp.use('/static', express.static('public'));\r\n이제 /static 경로 접두부를 통해 public 디렉토리에 포함된 파일을 로드할 수 있습니다.\r\n\r\nhttp://localhost:3000/static/images/kitten.jpg\r\nhttp://localhost:3000/static/css/style.css\r\nhttp://localhost:3000/static/js/app.js\r\nhttp://localhost:3000/static/images/bg.png\r\nhttp://localhost:3000/static/hello.html\r\n그러나 express.static 함수에 제공되는 경로는 node 프로세스가 실행되는 디렉토리에 대해 상대적입니다. Express 앱을 다른 디렉토리에서 실행하는 경우에는 다음과 같이 제공하기 원하는 디렉토리의 절대 경로를 사용하는 것이 더 안전합니다.\r\n\r\napp.use('/static', express.static(\\_\\_dirname + '/public'));\r\n\r\n출처: <https://expressjs.com/ko/starter/static-files.html>\r\n\r\n라우팅\r\n라우팅은 애플리케이션 엔드 포인트(URI)의 정의, 그리고 URI가 클라이언트 요청에 응답하는 방식을 말합니다. 라우팅에 대한 소개는 기본 라우팅을 참조하십시오.\r\n다음 코드는 매우 기본적인 라우트의 예입니다.\r\n\r\nvar express = require('express');\r\nvar app = express();\r\n// respond with \"hello world\" when a GET request is made to the homepage\r\napp.get('/', function(req, res) {\r\nres.send('hello world');\r\n});\r\n라우트 메소드\r\n라우트 메소드는 HTTP 메소드 중 하나로부터 파생되며, express 클래스의 인스턴스에 연결됩니다.\r\n다음 코드는 앱의 루트에 대한 GET 및 POST 메소드에 대해 정의된 라우트의 예입니다.\r\n\r\n// GET method route\r\napp.get('/', function (req, res) {\r\nres.send('GET request to the homepage');\r\n});\r\n// POST method route\r\napp.post('/', function (req, res) {\r\nres.send('POST request to the homepage');\r\n});\r\nExpress는 HTTP 메소드에 해당하는 다음과 같은 라우팅 메소드를 지원합니다. get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search 및 connect.\r\n올바르지 않은 JavaScript 변수 이름으로 변환되는 메소드를 라우팅하려면 대괄호 표기법을 사용하십시오. 예를 들면 app['m-search']('/', function ... 등과 같습니다.\r\n특수한 라우팅 메소드인 app.all()은 어떠한 HTTP 메소드로부터도 파생되지 않습니다. 이 메소드는 모든 요청 메소드에 대해 한 경로에서 미들웨어 함수를 로드하는 데 사용됩니다.\r\n다음 예에서는, GET, POST, PUT 또는 DELETE 메소드를 사용하는 경우, 또는 http 모듈에서 지원되는 기타 모든 HTTP 요청 메소드를 사용하는 경우 등의 “/secret”에 대한 요청을 위하여 핸들러가 실행됩니다.\r\n\r\napp.all('/secret', function (req, res, next) {\r\nconsole.log('Accessing the secret section ...');\r\nnext(); // pass control to the next handler\r\n});\r\n라우트 경로\r\n라우트 경로는, 요청 메소드와의 조합을 통해, 요청이 이루어질 수 있는 엔드포인트를 정의합니다. 라우트 경로는 문자열, 문자열 패턴 또는 정규식일 수 있습니다.\r\nExpress는 라우트 경로의 일치를 위해 path-to-regexp를 사용합니다. 라우트 경로를 정의할 수 있는 모든 가능성을 확인하려면 path-to-regexp 문서를 참조하십시오. Express Route Tester는 기본적인 Express 라우트의 테스트를 위한 편리한 도구이지만, 패턴 일치는 지원하지 않습니다.\r\n조회 문자열은 라우트 경로의 일부가 아닙니다.\r\n문자열을 기반으로 하는 라우트 경로의 몇 가지 예는 다음과 같습니다.\r\n다음의 라우트 경로는 요청을 루트 라우트 /에 일치시킵니다.\r\n\r\napp.get('/', function (req, res) {\r\nres.send('root');\r\n});\r\n다음의 라우트 경로는 요청을 /about에 일치시킵니다.\r\n\r\napp.get('/about', function (req, res) {\r\nres.send('about');\r\n});\r\n다음의 라우트 경로는 요청을 /random.text에 일치시킵니다.\r\n\r\napp.get('/random.text', function (req, res) {\r\nres.send('random.text');\r\n});\r\n문자열 패턴을 기반으로 하는 라우트 경로의 몇 가지 예는 다음과 같습니다.\r\n다음의 라우트 경로는 acd 및 abcd와 일치합니다.\r\n\r\napp.get('/ab?cd', function(req, res) {\r\nres.send('ab?cd');\r\n});\r\n다음의 라우트 경로는 abcd, abbcd 및 abbbcd 등과 일치합니다.\r\n\r\napp.get('/ab+cd', function(req, res) {\r\nres.send('ab+cd');\r\n});\r\n다음의 라우트 경로는 abcd, abxcd, abRABDOMcd 및 ab123cd 등과 일치합니다.\r\n\r\napp.get('/ab*cd', function(req, res) {\r\nres.send('ab*cd');\r\n});\r\n다음의 라우트 경로는 /abe 및 /abcde와 일치합니다.\r\n\r\napp.get('/ab(cd)?e', function(req, res) {\r\nres.send('ab(cd)?e');\r\n});\r\n?, +, \\* 및 () 문자는 정규식 문자의 서브세트입니다. 하이픈(-) 및 점(.)은 문자열 기반 경로에 의해 문자 그대로 해석됩니다.\r\n정규식을 기반으로 하는 라우트 경로의 예:\r\n다음의 라우트 경로는 라우트 이름에 “a”가 포함된 모든 항목과 일치합니다.\r\n\r\napp.get(/a/, function(req, res) {\r\nres.send('/a/');\r\n});\r\n다음의 라우트 경로는 butterfly 및 dragonfly와 일치하지만, butterflyman 및 dragonfly man 등과 일치하지 않습니다.\r\n\r\napp.get(/.*fly\\$/, function(req, res) {\r\nres.send('/.*fly\\$/');\r\n});\r\n라우트 핸들러\r\n미들웨어와 비슷하게 작동하는 여러 콜백 함수를 제공하여 요청을 처리할 수 있습니다. 유일한 차이점은 이러한 콜백은 next('route')를 호출하여 나머지 라우트 콜백을 우회할 수도 있다는 점입니다. 이러한 메커니즘을 이용하면 라우트에 대한 사전 조건을 지정한 후, 현재의 라우트를 계속할 이유가 없는 경우에는 제어를 후속 라우트에 전달할 수 있습니다.\r\n다음 예에 나타난 것과 같이, 라우트 핸들러는 함수나 함수 배열의 형태 또는 둘을 조합한 형태일 수 있습니다.\r\n하나의 콜백 함수는 하나의 라우트를 처리할 수 있습니다. 예를 들면 다음과 같습니다.\r\n\r\napp.get('/example/a', function (req, res) {\r\nres.send('Hello from A!');\r\n});\r\n2개 이상의 콜백 함수는 하나의 라우트를 처리할 수 있습니다(next 오브젝트를 반드시 지정해야 함). 예를 들면 다음과 같습니다.\r\n\r\napp.get('/example/b', function (req, res, next) {\r\nconsole.log('the response will be sent by the next function ...');\r\nnext();\r\n}, function (req, res) {\r\nres.send('Hello from B!');\r\n});\r\n하나의 콜백 함수 배열은 하나의 라우트를 처리할 수 있습니다. 예를 들면 다음과 같습니다.\r\n\r\nvar cb0 = function (req, res, next) {\r\nconsole.log('CB0');\r\nnext();\r\n}\r\nvar cb1 = function (req, res, next) {\r\nconsole.log('CB1');\r\nnext();\r\n}\r\nvar cb2 = function (req, res) {\r\nres.send('Hello from C!');\r\n}\r\napp.get('/example/c', [cb0, cb1, cb2]);\r\n독립적인 함수와 함수 배열의 조합은 하나의 라우트를 처리할 수 있습니다. 예를 들면 다음과 같습니다.\r\n\r\nvar cb0 = function (req, res, next) {\r\nconsole.log('CB0');\r\nnext();\r\n}\r\nvar cb1 = function (req, res, next) {\r\nconsole.log('CB1');\r\nnext();\r\n}\r\napp.get('/example/d', [cb0, cb1], function (req, res, next) {\r\nconsole.log('the response will be sent by the next function ...');\r\nnext();\r\n}, function (req, res) {\r\nres.send('Hello from D!');\r\n});\r\n응답 메소드\r\n다음 표에 표시된 응답 오브젝트에 대한 메소드(res)는 응답을 클라이언트로 전송하고 요청-응답 주기를 종료할 수 있습니다. 라우트 핸들러로부터 다음 메소드 중 어느 하나도 호출되지 않는 경우, 클라이언트 요청은 정지된 채로 방치됩니다.\r\n메소드 설명\r\nres.download() 파일이 다운로드되도록 프롬프트합니다.\r\nres.end() 응답 프로세스를 종료합니다.\r\nres.json() JSON 응답을 전송합니다.\r\nres.jsonp() JSONP 지원을 통해 JSON 응답을 전송합니다.\r\nres.redirect() 요청의 경로를 재지정합니다.\r\nres.render() 보기 템플리트를 렌더링합니다.\r\nres.send() 다양한 유형의 응답을 전송합니다.\r\nres.sendFile 파일을 옥텟 스트림의 형태로 전송합니다.\r\nres.sendStatus() 응답 상태 코드를 설정한 후 해당 코드를 문자열로 표현한 내용을 응답 본문으로서 전송합니다.\r\napp.route()\r\napp.route()를 이용하면 라우트 경로에 대하여 체인 가능한 라우트 핸들러를 작성할 수 있습니다. 경로는 한 곳에 지정되어 있으므로, 모듈식 라우트를 작성하면 중복성과 오타가 감소하여 도움이 됩니다. 라우트에 대한 자세한 정보는 Router() 문서를 참조하십시오.\r\napp.route()를 사용하여 정의된 체인 라우트 핸들러의 예는 다음과 같습니다.\r\n\r\napp.route('/book')\r\n.get(function(req, res) {\r\nres.send('Get a random book');\r\n})\r\n.post(function(req, res) {\r\nres.send('Add a book');\r\n})\r\n.put(function(req, res) {\r\nres.send('Update the book');\r\n});\r\nexpress.Router\r\nexpress.Router 클래스를 사용하면 모듈식 마운팅 가능한 핸들러를 작성할 수 있습니다. Router 인스턴스는 완전한 미들웨어이자 라우팅 시스템이며, 따라서 “미니 앱(mini-app)”이라고 불리는 경우가 많습니다.\r\n다음 예에서는 라우터를 모듈로서 작성하고, 라우터 모듈에서 미들웨어 함수를 로드하고, 몇몇 라우트를 정의하고, 기본 앱의 한 경로에 라우터 모듈을 마운트합니다.\r\n다음의 내용이 입력된 birds.js라는 이름의 라우터 파일을 앱 디렉토리에 작성하십시오.\r\n\r\nvar express = require('express');\r\nvar router = express.Router();\r\n// middleware that is specific to this router\r\nrouter.use(function timeLog(req, res, next) {\r\nconsole.log('Time: ', Date.now());\r\nnext();\r\n});\r\n// define the home page route\r\nrouter.get('/', function(req, res) {\r\nres.send('Birds home page');\r\n});\r\n// define the about route\r\nrouter.get('/about', function(req, res) {\r\nres.send('About birds');\r\n});\r\nmodule.exports = router;\r\n이후 앱 내에서 다음과 같이 라우터 모듈을 로드하십시오.\r\n\r\nvar birds = require('./birds');\r\n...\r\napp.use('/birds', birds);\r\n앱은 이제 /birds 및 /birds/about에 대한 요청을 처리할 수 있게 되었으며, 해당 라우트에 대한 특정한 미들웨어 함수인 timeLog를 호출할 것입니다.\r\n\r\n출처: <https://expressjs.com/ko/guide/routing.html>\r\n","excerpt":"Hello world 예제\n기본적으로 이 앱은 여러분이 작성할 수 있는 가장 간단한 Express 앱일 것입니다. 이 앱은 하나의 파일로 된 앱이며 Express 생성기를 통해 얻게 되는 앱과는 같지 않습니다. (이 예제와 달리 Express 생성기…","fields":{"slug":"/Express-study_1/"},"frontmatter":{"date":"Sep 20, 2021","title":"Express guide","tags":["express"],"update":"Sep 20, 2021"}}},{"node":{"rawMarkdownBody":"\r\n명령어 복습하기\r\n\r\n프로젝트 생성하기\r\nnpm init react-app .\r\n터미널에서 원하는 디렉토리에 들어가서 npm init react-app .를 입력하면 현재 디렉토리에 리액트 프로젝트를 생성합니다.\r\n\r\n개발 모드 실행하기\r\nnpm start (npm run start)\r\n터미널에서 npm run start를 입력하면 개발 모드 서버가 실행됩니다.\r\n\r\n실행 중인 서버 종료하기\r\nctrl + c\r\n서버가 실행 중인 터미널에서 ctrl + c를 입력하면 서버가 종료됩니다.\r\n\r\n개발된 프로젝트 빌드하기\r\nnpm run build\r\n터미널에서 npm run build를 입력하면 빌드를 시작합니다.\r\n\r\n빌드한 것 로컬에서 실행하기\r\nnpx serve build\r\n터미널에서 npx serve build를 입력하면 serve 프로그램을 다운 받고 build 폴더에서 서버가 실행됩니다.\r\n","excerpt":"명령어 복습하기 프로젝트 생성하기\nnpm init react-app .\n터미널에서 원하는 디렉토리에 들어가서 npm init react-app .를 입력하면 현재 디렉토리에 리액트 프로젝트를 생성합니다. 개발 모드 실행하기\nnpm start (npm…","fields":{"slug":"/React-study_6/"},"frontmatter":{"date":"Sep 01, 2021","title":"React 배포하기","tags":["react"],"update":"Sep 01, 2021"}}},{"node":{"rawMarkdownBody":"\r\n사실 CSS 파일을 불러오거나 이미지 파일을 불러오는 기능은 리액트 고유의 기능이 아니라 Create React App이라는 프로그램이 대신 설정해 준 기능입니다. (참고: Create React App 문서)\r\n\r\n클래스네임을 좀 더 편리하게 쓰는 방법\r\n\r\n디자인을 적용하는 방법\r\n이미지 불러오기\r\n이미지 파일은 import 구문을 통해 불러오고, 불러온 이미지 주소를 src 속성으로 사용하면 됩니다.\r\n\r\nimport diceImg from './assets/dice.png';\r\n\r\nfunction Dice() {\r\nreturn <img src={diceImg} alt=\"주사위 이미지\" />;\r\n}\r\n\r\nexport default App;\r\n인라인 스타일\r\n리액트에서 인라인 스타일은 문자열이 아닌 객체형으로 사용합니다. 프로퍼티 이름은 CSS 속성 이름으로, 프로퍼티 값은 CSS 속성 값으로 쓰는데요, 이때 프로퍼티 이름은 아래의 boarderRadius 처럼 대시 기호 없이 카멜 케이스로 써야 한다는 점도 꼭 기억해두세요.\r\n\r\nimport diceImg from './assets/dice.png';\r\n\r\nconst style = {\r\nborderRadius: '50%',\r\nwidth: '120px',\r\nheight: '120px',\r\n};\r\n\r\nfunction Dice() {\r\nreturn <img style={style} src={diceImg} alt=\"주사위 이미지\" />;\r\n}\r\n\r\nexport default App;\r\nCSS 파일 불러오기\r\nimport 구문으로 파일을 불러올 수 있는데요, 이때 from 키워드 없이 쓰면 됩니다.\r\n\r\nimport diceImg from './assets/dice.png';\r\nimport './Dice.css';\r\n\r\nfunction Dice() {\r\nreturn <img src={diceImg} alt=\"주사위 이미지\" />;\r\n}\r\n\r\nexport default App;\r\n클래스네임 사용하기\r\nCSS 파일에 정의된 클래스명을 className prop에 문자열로 넣어주면 됩니다. 이때 재사용성을 위해 className prop을 부모 컴포넌트에서 받으면 더 좋습니다.\r\n\r\nimport diceImg from './assets/dice.png';\r\nimport './Dice.css';\r\n\r\nfunction Dice({ className = '' }) {\r\nconst classNames = `Dice ${className}`;\r\nreturn <img className={classNames} src={diceImg} alt=\"주사위 이미지\" />;\r\n}\r\n\r\nexport default App;\r\n편리하게 클래스네임을 쓰는 방법\r\n앞에서는 여러 className을 템플릿 문자열로 합쳐서 사용했습니다. 몇 개 없을 때는 상관없지만, 개수가 늘어날수록 아래처럼 알아보기 힘들어진다는 문제점이 있는데요.\r\n\r\n템플릿 문자열을 사용한 예\r\nfunction Button({ isPending, color, size, invert, children }) {\r\nconst classNames = `Button ${isPending ? 'pending' : ''} ${color} ${size} ${invert ? 'invert' : ''}`;\r\nreturn <button className={classNames}>{children}</button>;\r\n}\r\n\r\nexport default Button;\r\n배열을 사용한 예\r\nfunction Button({ isPending, color, size, invert, children }) {\r\nconst classNames = [\r\n'Button',\r\nisPending ? 'pending' : '',\r\ncolor,\r\nsize,\r\ninvert ? 'invert' : '',\r\n].join('');\r\nreturn <button className={classNames}>{children}</button>;\r\n}\r\n\r\nexport default Button;\r\n위 예시 코드처럼 지저분하게 느껴지고, 매번 반복되는 코드를 작성한다는 번거로움이 있습니다. 개발자들은 이럴 때 라이브러리라는 걸 쓰는데요, 다른 개발자가 미리 만들어 놓은 코드를 이용해서 편하게 개발하는 겁니다.\r\n\r\n클래스네임의 경우에도 편리하게 사용할 수 있는 라이브러리가 많이 있는데요, 그중에서도 이번에 소개할 라이브러리는 바로 classnames라는 라이브러리입니다. 아래 예시 코드를 보시면 아시겠지만, 클래스네임에만 집중할 수 있어 훨씬 읽기 편해집니다. 이렇게 적절한 라이브러리를 쓰면 개발 생산성이 굉장히 좋아지죠.\r\n\r\nclassnames 라이브러리를 사용한 예\r\nimport classNames from 'classnames';\r\n\r\nfunction Button({ isPending, color, size, invert, children }) {\r\nreturn (\r\n<button\r\nclassName={classNames(\r\n'Button',\r\nisPending && 'pending',\r\ncolor,\r\nsize,\r\ninvert && 'invert',\r\n)}>\r\n{ children }\r\n</button >\r\n);\r\n}\r\n\r\nexport default Button;\r\nclassnames 은 NPM이라는 프로그램을 통해 설치할 수 있습니다. 터미널에서 npm install classnames 을 입력하고 설치한 다음에, 위 예시처럼 import 로 불러와서 사용하면 됩니다. NPM 저장소 사이트로 들어가면 사용 방법과 설명이 나와있음.\r\n\r\nNPM classnames 패키지: https://www.npmjs.com/package/classnames\r\n","excerpt":"사실 CSS 파일을 불러오거나 이미지 파일을 불러오는 기능은 리액트 고유의 기능이 아니라 Create React App이라는 프로그램이 대신 설정해 준 기능입니다. (참고: Create React App 문서) 클래스네임을 좀 더 편리하게 쓰는 방법…","fields":{"slug":"/React-study_5/"},"frontmatter":{"date":"Aug 24, 2021","title":"React 디자인 적용하는 방법과 팁","tags":["react"],"update":"Aug 24, 2021"}}},{"node":{"rawMarkdownBody":"\r\nState\r\nstate는 리액트에서 화면을 그려내는 데 굉장히 중요한 역할을 합니다.\r\n\r\nState라는 단어는 한국어로 '상태'라는 뜻이 있는데요. 리액트에서의 state도 그 의미가 다르지 않습니다.\r\n\r\n상태가 바뀔 때마다 화면을 새롭게 그려내는 방식으로 동작을 하는 것이죠.\r\n\r\n리액트에서 state를 만들고, state를 바꾸기 위해서는 일단 useState라는 함수를 활용해야 합니다.\r\n\r\nimport { useState } from 'react';\r\n\r\n// ...\r\n\r\nconst [num, setNum] = useState(1);\r\n\r\n// ...\r\n보통 이렇게 Destructuring 문법으로 작성하는데요. useState 함수가 초깃값을 아규먼트로 받고 그에 따른 실행 결과로 요소 2개를 가진 배열의 형태로 리턴을 하기 때문입니다.\r\n\r\n이때 첫 번째 요소가 바로 state이고, 두 번째 요소가 이 state를 바꾸는 setter 함수인데요.\r\n\r\n참고로 위 코드에서도 볼 수 있듯 첫 번째 변수는 원하는 state의 이름(num)을 지어주고, 두 번째 변수에는 state 이름 앞에 set을 붙인 다음 카멜 케이스로 이름을 지어주는 것(setNum)이 일반적입니다.\r\n\r\nstate는 변수에 새로운 값을 할당하는 방식으로 변경하는 것이 아니라 이 setter 함수를 활용해야 하는데요. setter 함수는 호출할 때 전달하는 아규먼트 값으로 state 값을 변경해 줍니다.\r\n\r\n그래서 아래 코드처럼 setter 함수를 활용해서 이벤트 핸들러를 등록해두면, 이벤트가 발생할 때마다 상태가 변하면서 화면이 새로 그려지는 것이죠!\r\n\r\nimport { useState } from 'react';\r\nimport Button from './Button';\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nconst [num, setNum] = useState(1);\r\n\r\nconst handleRollClick = () => {\r\nsetNum(3); // num state를 3으로 변경!\r\n};\r\n\r\nconst handleClearClick = () => {\r\nsetNum(1); // num state를 1로 변경!\r\n};\r\n\r\nreturn (\r\n<div>\r\n<Button onClick={handleRollClick}>던지기</Button>\r\n<Button onClick={handleClearClick}>처음부터</Button>\r\n<Dice color=\"red\" num={num} />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\n참조형 State\r\n자바스크립트의 자료형은 크게 기본형(Primitive type)과 참조형(Reference type)로 나눌 수 있다는 사실, 모두 알고 계시죠?\r\n\r\n특히 참조형 값들은 조금 독특한 특성을 가지고 있어서 변수로 다룰 때도 조금 주의해야 할 부분들이 있었는데요. state를 활용할 때도 마찬가지입니다!\r\n\r\n// ...\r\n\r\nconst [gameHistory, setGameHistory] = useState([]);\r\n\r\nconst handleRollClick = () => {\r\nconst nextNum = random(6);\r\ngameHistory.push(nextNum);\r\nsetGameHistory(gameHistory); // state가 제대로 변경되지 않는다!\r\n};\r\n\r\n// ...\r\n위 코드에서 볼 수 있듯 배열 값을 가진 gameHistory에 push 메소드를 이용해서 배열의 값을 변경한 다음, 변경된 배열을 setter 함수로 state를 변경하려고 하면 코드가 제대로 동작하지 않습니다.\r\n\r\ngameHistory state는 배열 값 자체를 가지고 있는 게 아니라 그 배열의 주솟값을 참조하고 있는 건데요. 때문에 push 메소드로 배열 안에 요소를 변경했다고 하더라도 결과적으로 참조하는 배열의 주솟값은 변경된 것이 아니게 됩니다.\r\n\r\n결과적으로 리액트 입장에서는 gameHistory state가 참조하는 주솟값은 여전히 똑같기 때문에 상태(state)가 바뀌었다고 판단하지 않는 것이죠!\r\n\r\n그래서 참조형 state를 활용할 때는 반드시 새로운 참조형 값을 만들어 state를 변경해야 합니다.\r\n\r\n가장 간단한 방법은 Spread 문법(...) 을 활용하는 것이겠죠?\r\n\r\n// ...\r\n\r\nconst [gameHistory, setGameHistory] = useState([]);\r\n\r\nconst handleRollClick = () => {\r\nconst nextNum = random(6);\r\nsetGameHistory([...gameHistory, nextNum]); // state가 제대로 변경된다!\r\n};\r\n\r\n// ...\r\n이 참조형 state의 특성을 이해하지 못하면, 간혹 state가 제대로 변경되지 않는 버그가 발생했을 때 원인을 제대로 찾지 못하는 경우가 발생할 수도 있는데요.\r\n\r\n참조형 state를 활용할 땐 반드시 새로운 참조형 값을 만들어서 state를 변경해야 한다는 점.\r\n","excerpt":"State\nstate는 리액트에서 화면을 그려내는 데 굉장히 중요한 역할을 합니다. State라는 단어는 한국어로 '상태'라는 뜻이 있는데요. 리액트에서의 state도 그 의미가 다르지 않습니다. 상태가 바뀔 때마다 화면을 새롭게 그려내는 방식으로 …","fields":{"slug":"/React-study_4/"},"frontmatter":{"date":"Aug 23, 2021","title":"React state 정리하기","tags":["react"],"update":"Aug 23, 2021"}}},{"node":{"rawMarkdownBody":"\r\nJSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다.\r\n\r\nProps는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 모여서 컴포넌트를 정의한 함수의 첫 번째 파라미터로 전달됩니다.\r\n\r\nApp.js\r\n\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<Dice color=\"blue\" />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\nDice.js\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\n\r\nfunction Dice(props) {\r\nconsole.log(props)\r\nreturn <img src={diceBlue01} alt=\"주사위\" />;\r\n}\r\n\r\nexport default Dice;\r\n위 코드들 처럼 App 함수에서 사용하는 Dice 컴포넌트에 color라는 속성을 blue로 지정해주고, Dice 함수 내부에서 props라는 파라미터를 하나 만들어 출력해보면 브라우저 콘솔에는 다음과 같은 출력 결과가 나타나게 됩니다.\r\n\r\n{ color: \"blue\" }\r\n그래서 컴포넌트를 활용할 때 속성값을 다양하게 전달하고 이 props 값을 활용하면, 똑같은 컴포넌트라도 전달된 속성값에 따라 서로 다른 모습을 그려낼 수도 있게 됩니다.\r\n\r\nApp.js\r\n\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<Dice color=\"red\" num={2} />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\nDice.js\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\nimport diceBlue02 from './assets/dice-blue-2.svg';\r\n// ...\r\nimport diceRed01 from './assets/dice-red-1.svg';\r\nimport diceRed02 from './assets/dice-red-2.svg';\r\n// ...\r\n\r\nconst DICE_IMAGES = {\r\nblue: [diceBlue01, diceBlue02],\r\nred: [diceRed01, diceRed02],\r\n};\r\n\r\nfunction Dice(props) {\r\nconst src = DICE_IMAGES[props.color][props.num - 1];\r\nconst alt = `${props.color} ${props.num}`;\r\nreturn <img src={src} alt={alt} />;\r\n}\r\n\r\nexport default Dice;\r\n참고로, 이렇게 props가 객체 형태를 띠고 있으니 Destructuring 문법을 활용해서 조금 더 간결하게 코드를 작성할 수도 있겠죠?\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\nimport diceBlue02 from './assets/dice-blue-2.svg';\r\n// ...\r\nimport diceRed01 from './assets/dice-red-1.svg';\r\nimport diceRed02 from './assets/dice-red-2.svg';\r\n// ...\r\n\r\nconst DICE_IMAGES = {\r\nblue: [diceBlue01, diceBlue02],\r\nred: [diceRed01, diceRed02],\r\n};\r\n\r\nfunction Dice({ color = 'blue', num = 1 }) {\r\nconst src = DICE_IMAGES[color][num - 1];\r\nconst alt = `${color} ${num}`;\r\nreturn <img src={src} alt={alt} />;\r\n}\r\n\r\nexport default Dice;\r\nChildren\r\nprops에는 children이라는 조금 특별한 프로퍼티(prop, 프롭)가 있습니다.\r\n\r\nJSX 문법으로 컴포넌트를 작성할 때 컴포넌트를 단일 태그가 아니라 여는 태그와 닫는 태그의 형태로 작성하면, 그 안에 작성된 코드가 바로 이 children 값에 담기게 됩니다.\r\n\r\nButton.js\r\n\r\nfunction Button({ children }) {\r\nreturn <button>{children}</button>;\r\n}\r\n\r\nexport default Button;\r\nApp.js\r\n\r\nimport Button from './Button';\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<div>\r\n<Button>던지기</Button>\r\n<Button>처음부터</Button>\r\n</div>\r\n<Dice color=\"red\" num={2} />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\n그래서 JSX 문법으로 컴포넌트를 작성할 때 어떤 정보를 전달할 때는 일반적인 props의 속성값을 주로 활용하고, 화면에 보여질 모습을 조금 더 직관적인 코드로 작성하고자 할 때 children 값을 활용할 수가 있습니다.\r\n\r\n참고로 이 children을 활용하면 단순히 텍스트만 작성하는 걸 넘어서 컴포넌트 안에 컴포넌트를 작성할 수도 있고, 컴포넌트 안에 복잡한 태그들을 더 작성할 수도 있다.\r\n","excerpt":"JSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다. Props는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 …","fields":{"slug":"/React-study_3/"},"frontmatter":{"date":"Aug 22, 2021","title":"React Props 문법","tags":["react"],"update":"Aug 22, 2021"}}},{"node":{"rawMarkdownBody":"\r\n리액트 엘리먼트\r\nJSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst element = <h1>안녕 리액트!</h1>;\r\nconsole.log(element);\r\nReactDOM.render(element, document.getElementById('root'));\r\n{\\$\\$typeof: Symbol(react.element), type: \"h1\", key: null, ref: null, props: {…}, …}\r\n이런 객체를 리액트 엘리먼트라고 부르는데요.\r\n\r\n이 리액트 엘리먼트를 ReactDOM.render 함수의 아규먼트로 전달하게 되면, 리액트가 객체 형태의 값을 해석해서 HTML 형태로 브라우저에 띄워주는 것이죠.\r\n\r\n리액트 엘리먼트는 리액트로 화면을 그려내는데 가장 기본적인 요소입니다.\r\n\r\n리액트 컴포넌트\r\n리액트 컴포넌트는 리액트 엘리먼트를 조금 더 자유롭게 다루기 위한 하나의 문법입니다.\r\n\r\n컴포넌트를 만드는 가장 간단한 방법은 자바스크립트의 함수를 활용하는 건데요.\r\n아래 코드에서 JSX 문법으로 작성된 하나의 요소를 리턴하는 Hello 함수가 바로 하나의 컴포넌트입니다.\r\n\r\n이렇게 요소를 컴포넌트로 작성하게 되면 다양한 장점들이 있는데,\r\n자세한 내용은 이후의 개념들을 하나씩 배워나가면서 차차 알아보도록 합시다!\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nfunction Hello() {\r\nreturn <h1>안녕 리액트</h1>;\r\n}\r\n\r\nconst element = (\r\n<>\r\n<Hello />\r\n<Hello />\r\n<Hello />\r\n</>\r\n);\r\n\r\nReactDOM.render(element, document.getElementById('root'));\r\n그리고 이렇게 컴포넌트를 작성하면,\r\n위 코드에서 element 변수 안의 JSX 코드에서 볼 수 있듯 컴포넌트 함수 이름을 통해 하나의 태그처럼 활용할 수가 있습니다.\r\n\r\n이런 특성을 모듈 문법으로 활용하면 훨씬 더 독립적으로 컴포넌트 특성에 집중해서 코드를 작성할 수가 있습니다.\r\n\r\n예시: Dice.js\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\n\r\nfunction Dice() {\r\nreturn <img src={diceBlue01} alt=\"주사위\" />;\r\n}\r\n\r\nexport default Dice;\r\n예시: App.js\r\n\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<Dice />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\n한 가지 주의해야 할 부분은, 리액트 컴포넌트의 이름은 반드시 첫 글자를 대문자로 작성해야 한다는 것입니다.\r\n컴포넌트 이름의 첫 글자가 소문자라면 오류가 발생하니깐 꼭 주의!\r\n","excerpt":"리액트 엘리먼트\nJSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다. import ReactDOM from 'react-dom'; const element = 안녕 리액트!;\nconsole.log(element);\nReactDOM.r…","fields":{"slug":"/React-study_2/"},"frontmatter":{"date":"Aug 21, 2021","title":"React commponent 문법","tags":["react"],"update":"Aug 21, 2021"}}},{"node":{"rawMarkdownBody":"\r\nJSX란?\r\nJSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(<h1>안녕 리액트!</h1>, document.getElementById('root'));\r\nJSX 문법\r\nJSX는 자바스크립트로 HTML과 같은 문법을 사용할 수 있도록 만들어주는 편리한 문법이지만, 그만큼 꼭 지켜야 할 규칙들도 있습니다.\r\n\r\nHTML과 다른 속성명\r\n\r\n1. 속성명은 카멜 케이스로 작성하기!\r\n   JSX 문법에서도 태그에 속성을 지정해 줄 수 있습니다. 단, 여러 단어가 조합된 몇몇 속성들을 사용할 때는 반드시 카멜 케이스(Camel Case)로 작성해야 합니다.\r\n   사실 여러 단어가 조합된 HTML 속성들이 많진 않지만, 예를 들면 onclick, onblur, onfocus 등과 같은 이벤트 속성이나, tabindex 같은 속성들이 있습니다.\r\n   이런 속성들은 모두 onClick, onBlur, onFocus, onMouseDown, onMouseOver, tabIndex 처럼 작성하는 것이죠!\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n<button onClick= ... >클릭!</button>,\r\ndocument.getElementById('root')\r\n);\r\n단, 예외적으로 HTML에서 비표준 속성을 다룰 때 활용하는 data-\\* 속성은 카멜 케이스(Camel Case)가 아니라 기존의 HTML 문법 그대로 작성하셔야 합니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <div>\r\n    상태 변경: \r\n    <button className=\"btn\" data-status=\"대기중\">대기중</button>\r\n    <button className=\"btn\" data-status=\"진행중\">진행중</button>\r\n    <button className=\"btn\" data-status=\"완료\">완료</button>\r\n  </div>,\r\n  document.getElementById('root')\r\n);\r\n2. 자바스크립트 예약어와 같은 속성명은 사용할 수 없다!\r\nJSX 문법도 결국은 자바스크립트 문법이기 때문에, for나 class처럼 자바스크립트의 문법에 해당하는 예약어와 똑같은 이름의 속성명은 사용할 수 없습니다.\r\n그래서 HTML의 for의 경우에는 자바스크립트의 반복문 키워드 for와 겹치기 때문에 htmlFor로, HTML의 class 속성도 자바스크립트의 클래스 키워드 class와 겹치기 때문에 className으로 작성해 주어야 합니다.\r\n\r\nReact 공식 문서 - 어트리뷰트의 차이\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <form>\r\n    <label htmlFor=\"name\">이름</label>\r\n    <input id=\"name\" className=\"name-input\" type=\"text\" />\r\n  </form>,\r\n  document.getElementById('root')\r\n);\r\n반드시 하나의 요소로 감싸기 - Fragment\r\nJSX 문법을 활용할 때는 반드시 하나의 요소로 감싸주어야 합니다. 그래서 아래 코드처럼 여러 개의 요소를 작성하면 오류가 발생하는데요.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <p>안녕</p>\r\n  <p>리액트!</p>,\r\n  document.getElementById('root')\r\n);\r\n이럴 때는 아래 코드처럼 여러 태그를 감싸는 부모 태그를 만들어 하나의 요소로 만들어 주어야 합니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <div>\r\n    <p>안녕</p>\r\n    <p>리액트!</p>\r\n  </div>,\r\n  document.getElementById('root')\r\n);\r\n하지만 이렇게 작성한다면 때로는 꼭 필요하지 않은 부모 태그가 작성될 수 있겠죠? 그럴 땐 Fragment로 감싸주면 의미 없는 부모 태그를 만들지 않아도 여러 요소를 작성할 수 있습니다.\r\n\r\nimport { Fragment } from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n<Fragment>\r\n\r\n<p>안녕</p>\r\n<p>리액트!</p>\r\n</Fragment>,\r\ndocument.getElementById('root')\r\n);\r\n참고로 Fragment는 아래 코드처럼 빈 태그로 감싸는 단축 문법으로 활용할 수도 있습니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n<>\r\n\r\n<p>안녕</p>\r\n<p>리액트!</p>\r\n</>,\r\ndocument.getElementById('root')\r\n);\r\n자바스크립트 표현식 넣기\r\nJSX 문법에서 중괄호({})를 활용하면 자바스크립트 표현식을 넣을 수 있습니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst product = '맥북';\r\n\r\nReactDOM.render(\r\n\r\n  <h1>나만의 {product} 주문하기</h1>,\r\n  document.getElementById('root')\r\n);\r\n이런 부분들을 잘 활용하면, 아래 코드처럼 중괄호 안에서 문자열을 조합할 수도 있고 변수에 이미지 주소를 할당해서 img 태그의 src 속성값을 전달해 줄 수도 있고, 이벤트 핸들러를 좀 더 편리하게 등록할 수도 있습니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst product = 'MacBook';\r\nconst model = 'Air';\r\nconst imageUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/MacBook_with_Retina_Display.png/500px-MacBook_with_Retina_Display.png'\r\n\r\nfunction handleClick(e) {\r\nalert('곧 도착합니다!');\r\n}\r\n\r\nReactDOM.render(\r\n<>\r\n\r\n<h1>{product + ' ' + model} 주문하기</h1>\r\n<img src={imageUrl} alt=\"제품 사진\" />\r\n<button onClick={handleClick}>확인</button>\r\n</>,\r\ndocument.getElementById('root')\r\n);\r\n단, JSX 문법에서 중괄호는 자바스크립트 표현식을 다룰 때 활용하기 때문에, 중괄호 안에서 for, if문 등의 문장은 다룰 수 없다는 점은 꼭 기억해 주세요.\r\n그런데도 만약 JSX 문법을 활용할 때 조건문이 꼭 필요하다면 조건 연산자를, 반복문이 꼭 필요하다면 배열의 반복 메소드를 활용하자.\r\n","excerpt":"JSX란?\nJSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다. import ReactDOM from 'react-do…","fields":{"slug":"/React-study_1/"},"frontmatter":{"date":"Aug 20, 2021","title":"React JSX 문법","tags":["react"],"update":"Aug 20, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)\r\ngit blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력\r\ngit revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성\r\n","excerpt":"git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)\ngit blame : 특정 파…","fields":{"slug":"/Git-study_5/"},"frontmatter":{"date":"Aug 17, 2021","title":"Git 협업하기 정리 노트","tags":["git"],"update":"Aug 17, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit branch [새 브랜치 이름] : 새로운 브랜치를 생성\r\ngit checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동\r\ngit branch -d [기존 브랜치 이름] : 브랜치 삭제\r\ngit checkout [기존 브랜치 이름] : 그 브랜치로 이동\r\ngit merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지\r\ngit merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감\r\n","excerpt":"git branch 새 브랜치 이름 : 새로운 브랜치를 생성\ngit checkout -b 새 브랜치 이름 : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동\ngit branch -d 기존 브랜치 이름 : 브랜치 삭제\ngit checkout 기존 브랜…","fields":{"slug":"/Git-study_4/"},"frontmatter":{"date":"Aug 17, 2021","title":"branch 정리 노트","tags":["git"],"update":"Aug 17, 2021"}}},{"node":{"rawMarkdownBody":"\r\nGit 써보기\r\ngit init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\r\ngit config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)\r\ngit config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)\r\ngit add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기\r\ngit add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit reset [파일 이름] : staging area에 올렸던 파일 다시 내리기\r\ngit status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)\r\ngit commit -m \"커밋 메시지\" : 현재 staging area에 있는 것들 커밋으로 남기기\r\ngit help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력\r\n\r\nGitHub 시작하기\r\ngit push -u(또는 --set-upstream) origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.\r\ngit push : 위의 커맨드를 한번 실행하고 난 후에는 git push라고만 쳐도 로컬 레포지토리의 내용을 리모트 레포지토리에 올릴 수 있습니다.\r\ngit pull : 바로 위의 위에 있는 커맨드를 한번 실행하고 난 후에는 git pull이라고만 쳐도 리모트 레포지토리의 내용을 로컬 레포지토리로 가져옵니다.\r\ngit clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기\r\n\r\nGit에서 커밋 다루기\r\ngit log : 커밋 히스토리를 출력\r\ngit log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.\r\ngit show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인\r\ngit commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦\r\ngit config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로는 별명으로도 해당 커맨드를 실행할 수 있게 설정\r\ngit diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교\r\ngit reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)\r\n(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)\r\n\r\n    \t(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)\r\n\r\n    \t(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)\r\n\r\n    \t그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨\r\n\r\ngit tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임\r\n\r\nGit에서 브랜치 사용하기\r\ngit branch [새 브랜치 이름] : 새로운 브랜치를 생성\r\ngit checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동\r\ngit branch -d [기존 브랜치 이름] : 브랜치 삭제\r\ngit checkout [기존 브랜치 이름] : 그 브랜치로 이동\r\ngit merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지\r\ngit merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감\r\n\r\nGit 실전 I\r\ngit fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)\r\ngit blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력\r\ngit revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성\r\n\r\nGit 실전 Ⅱ\r\ngit reflog : HEAD가 그동안 가리켜왔던 커밋들의 기록을 출력\r\ngit log --all --graph : 모든 브랜치의 커밋 히스토리를, 커밋 간의 관계가 잘 드러나도록 그래프 형식으로 출력\r\ngit rebase [브랜치 이름] : A, B 브랜치가 있는 상태에서 지금 HEAD가 A 브랜치를 가리킬 때, git rebase B를 실행하면 A, B 브랜치가 분기하는 시작점이 된 공통 커밋 이후로부터 존재하는 A 브랜치 상의 커밋들이 그대로 B 브랜치의 최신 커밋 이후로 이어붙여짐(git merge와 같은 효과를 가지지만 커밋 히스토리가 한 줄로 깔끔하게 된다는 차이점이 있음)\r\ngit stash : 현재 작업 내용을 스택 영역에 저장\r\ngit stash apply [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용\r\ngit stash drop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 스택에서 삭제\r\ngit stash pop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용하면서 스택에서 삭제\r\ngit cherry-pick [커밋 아이디] : 특정 커밋의 내용을 현재 커밋에 반영\r\n! 그 밖에 알아야할 사실\r\n\r\n(1) git commit이라고만 쓰고 실행하면 커밋 메시지를 입력할 수 있는 텍스트 에디터 창이 뜹니다. 거기서 커밋 메시지를 입력하고 저장하고 나면 커밋이 이루어집니다.\r\n\r\n(2) git push와 git pull은 그 작업 단위가 브랜치입니다. 예를 들어, master 브랜치에서 git push를 하면 master 브랜치의 내용만 리모트 레포지토리의 master 브랜치로 전송되지, premium 브랜치의 내용이 전송되는 것은 아닙니다.(git push에 --all이라는 옵션을 주면 모든 브랜치의 내용을 전송할 수 있기는 합니다.)\r\n","excerpt":"Git 써보기\ngit init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\ngit config user.name 'codeit' : 현재 사용자의 …","fields":{"slug":"/Git-study_6/"},"frontmatter":{"date":"Aug 17, 2021","title":"Git 내용 총정리 노트","tags":["git"],"update":"Aug 17, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.\r\ngit push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기\r\ngit pull : 리모트 레포지토리의 내용을 로컬 레포지토리로 가져오기\r\ngit clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기\r\n","excerpt":"git push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.\ngit push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기\ngit pull : 리모트 레포지토리의 내용을 로컬 …","fields":{"slug":"/Git-study_2/"},"frontmatter":{"date":"Aug 16, 2021","title":"GitHub 시작하기 정리 노트","tags":["git"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit log : 커밋 히스토리를 출력\r\ngit log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.\r\ngit show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인\r\ngit commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦\r\ngit config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로 별명으로 해당 커맨드를 실행할 수 있도록 설정\r\ngit diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교\r\ngit reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)\r\n(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)\r\n\r\n    \t(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)\r\n\r\n    \t(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)\r\n\r\n    \t그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨\r\n\r\ngit tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임\r\n","excerpt":"git log : 커밋 히스토리를 출력\ngit log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 …","fields":{"slug":"/Git-study_3/"},"frontmatter":{"date":"Aug 16, 2021","title":"commit 정리 노트","tags":["git"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\r\ngit config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)\r\ngit config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)\r\ngit add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기\r\ngit add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit reset [파일 이름] : staging area에 올렸던 파일 다시 내리기\r\ngit status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)\r\ngit commit -m \"커밋 메시지\" : 현재 staging area에 있는 것들 커밋으로 남기기\r\ngit help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력\r\n","excerpt":"git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\ngit config user.name 'codeit' : 현재 사용자의 아이디를 'co…","fields":{"slug":"/Git-study_1/"},"frontmatter":{"date":"Aug 16, 2021","title":"Git 써보기 정리 노트","tags":["git"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\n![](screenshot.png)\r\n\r\n이미지 파일이 첨부된 게시물의 예제입니다.\r\n\r\n폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다.\r\n\r\n게시물 파일명은 index.md 로 합니다.\r\n\r\n이미지 파일은 폴더 내에 위치시킵니다.\r\n\r\n자세한 가이드는 [Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 확인해주세요.\r\n","excerpt":"이미지 파일이 첨부된 게시물의 예제입니다. 폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다. 게시물 파일명은 index.md 로 합니다. 이미지 파일은 폴더 내에 위치시킵니다. 자세한 가이드는 Documents를 확인해주세요.","fields":{"slug":"/image-post-example.md/"},"frontmatter":{"date":"Mar 24, 1991","title":"Image, 이미지 게시물 예제","tags":["undefined"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}