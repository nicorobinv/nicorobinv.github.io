{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n표현식 (expression)은 자바스크립트 인터프리터가 값으로 평가하는(evaluate) 자바스크립트 구문이다. 예를 들어 프로그램에 포함된 임의의 상수는 표현식의 아주 간단한 형태다. 변수 이름 또한 간단한 표현식으로, 변수에 할당된 임의의 값으로 평가된다. 이처럼 간단한 표현식들을 사용해 복잡한 표현식도 만들 수 있다. 예를 들어 배열 접근 표현식은 열린 대괄호([) 와 숫자로 평가되는 표현식, 닫힌 대괄호(])가 결합된 하나의 표현식이다. 이렇게 결합된 복잡 표현식은 배열의 특정 위치에 저장된 값으로 평가된다. 이와 유사하게, 함수 호출 표현식은 함수 객체와 인자로 사용되는 하나 이상의 표현식들이 결합해 하나의 복합 표현식이 된다.\r\n\r\n복합 표현식을 만드는 가장 쉬운 방법은 연산자(operator)를 사용하는 것이다. 연산자는 피연산자의 값들을(보통 두 개) 어떻게든 결합해 새로운 값을 만들어 낸다. 곱셈 연산자 _가 그 간단한 사례다. 표현식 x _ y는 표현식 x와 y 값의 곱으로 평가된다. 간단히 설명하기 위해, 연산자는 '값으로 평가된다'는 표현 대신, '값을 반환한다'는 표현을 쓰기도 한다.\r\n\r\n이번 장에서는 자바스크립트에서 사용하는 모든 연산자뿐 아니라, 배열 참조나 함수 호출처럼 연산자를 사용하지 않는 표현식도 다룬다. 만약 독자 여러분이 C 스타일 문법을 사용하는 다른 프로그래밍 언어를 배운 적이 있다면, 자바스크립트의 표현식과 연산자 문법이 한결 친숙할 것이기에 이 장을 좀 더 빠르게 살펴볼 수 있을 것이다.\r\n\r\n4.1 기본 표현식\r\n가장 간단한 형태의 표현식은 '기본 표현식(primary expression)'으로, 다른 표현식을 포함하지 않은 독립적 표현식이다. 자바스크립트에서 기본 표현식은 상수나 리터럴 값, 특정 키워드들 그리고 변수 참조를 말한다.\r\n리터럴은 상수 값으로 프로그램에 직접 포함된다. 예를 들어 다음과 같다.\r\n\r\n1.234 // 숫자 리터럴\r\n\"hello\" // 문자열 리터럴\r\n/pattern/ // 정규 표현식 리터럴\r\n\r\n숫자 리터럴을 작성하는 자바스크립트 문법은 3.1절에서, 문자열 리터럴은 3.2절에서 다뤘다. 정규 표현식 리터럴 문법도 3.2.4에서 간단히 소개했지만 10장에서 좀 더 자세히 다룬다.\r\n자바스크립트의 예약어 중에는 기본 표현식이 몇 개 있다.\r\n\r\ntrue // 불리언 true 값으로 평가된다.\r\nfalse // 불리언 false 값으로 평가된다.\r\nnull // null 값으로 평가된다.\r\nthis // '현재' 객체로 평가된다.\r\n\r\n3.3절과 3.4절에서 true, false, null에 대해 살펴봤다. 다른 키워드와는 달리 this는 상수가 아니고 프로그램 안에서 위치에 따라 각기 다른 값으로 평가된다. this 키워드는 객체 지향 프로그래밍에서 주로 사용된다. 메서드의 본문 안에서 this는 메서드를 호출한 객체로 평가된다. 4.5절과 8장(특히 8.2.2), 9장에서 this에 대해 좀 더 상세히 다루겠다. 마지막으로 세 번째 기본 표현식은 변수를 있는 그대로 참조하는 형태다.\r\n\r\ni // 변수 i의 값으로 평가된다.\r\nsum // 변수 sum의 값으로 평가된다.\r\nundefined // undefined는 전역 변수로 null처럼 키워드가 아니다.\r\n\r\n자바스크립트에서는 프로그램 안에 존재하는 각 식별자들을 일단 변수라고 가정하고 값을 살펴본다. 만약 해당 식별자를 이름으로 하는 변수가 없다면, 해당 표현식은 undefined 값으로 평가된다. 하지만 ECMAScript 5의 엄격 모드 (strict mode)에서는 존재하지 않는 변수를 평가하려고 하면 ReferenceError 예외가 발생한다.\r\n\r\n4.2 객체와 배열의 초기화 표현식\r\n\r\n객체와 배열 초기화 표현식(initializer)은 말 그대로 새로 생성된 객체나 배열을 값으로 하는 표현식이다. 이들 초기화 표현식은 종종 '객체 리터럴'과 '배열 리터럴' 이라고 한다. 하지만 일반 리터럴과는 달리, 이들은 기본 표현식이 아니다. 이들 리터럴은 프로퍼티와 원소의 값을 지정하는 수많은 하위 표현식을 포함할수 있기 때문이다. 배열 초기화 문법은 상대적으로 간단하니, 이 부분부터 살펴보자.\r\n배열 초기화 표현식은 대괄호 안에 담긴 쉼표로 구분된 표현식 리스트다. 배열 초기화 표현식의 값은 새로 생성된 배열이다. 이렇게 생성된 배열의 원소들은 각각 쉼표로 구분된 표현식의 값들로 초기화된다.\r\n\r\n[] // 빈 배열: 대괄호 안에 표현식이 없으면 원소가 없음을 말\r\n한다.\r\n[1+2, 3+4] // 두 개의 원소를 가진 배열. 첫 번째는 3, 두 번째는 7이다.\r\n\r\n배열 초기화 표현식에 사용되는 원소 표현식으로는 또 다른 배열 초기화 표현식을 사용할 수도 있다. 다시 말해, 원소 표현식 자체가 배열이라면 중첩 배열을 만들 수도 있다는 의미다.\r\n\r\nvar matrix = [[1,2,3], [4,5,6], [7,8,9]];\r\n\r\n배열 초기화 표현식에 사용되는 원소 표현식은 매번 배열이 초기화될 떄마다 평가된다. 이는 배열 초기화 표현식이 평가될 때마다 원소의 값이 달라질 수 있음을 뜻한다.\r\n배열 리터럴에서 쉼표 사이의 값을 생략함으로써 원소의 값을 정의하지 않을수 있다. 예를 들어, 다음 배열은 세 개의 정의되지 않은 원소를 포함해 총 다섯개 원소를 갖고 있다.\r\n\r\nvar sparseArray = [1,,,,,,5];\r\n\r\n배열 초기화 표현식의 마지막 원소 표현식 다음에 쉼표가 올 수는 있지만, 그렇다고 해서 값이 정의되지 않은 원소가 만들어지지는 않는다. 객체 초기화 표현식은 배열 초기화 표현식과 유사하다. 하지만 대괄호가 아닌 중괄호가 사용되고, 각 하위 표현식 앞에는 프로퍼티 이름과 콜론(:)이 붙는다.\r\n\r\nvar p = { x : 2.3, y : -1.2 }; // 두 개의 프로퍼티를 가진 객체\r\nvar q = {}; // 프로퍼티가 없는 빈 객체\r\nq.x = 2.3; q.y = -1.2; // 객체 q와 p는 같은 프로퍼티를 갖는다.\r\n\r\n객체 리터럴은 중첩될 수 있다. 예를 통해 살펴보자.\r\n\r\nvar rectangle = { upperLeft : { x : 2, y : 2 },\r\nlowerRight : { x : 4, y : 5 } } ;\r\n\r\n객체 초기화에 사용한 표현식은 객체가 초기화 될 떄마다 매번 평가되기 때문에 일정한 값을 갖지 않는다. 그 자체로 임의의 자바스크립트 표현식이기 때문이다. 객체 리터럴에서의 프로퍼티 이름으로는 식별자 대신 문자열을 사용할 수도 있다(이는 예약어나, 식별자로는 적합하지 않은 이름을 프로퍼티 이름으로 사용 하고 싶을 때 유용하다).\r\n\r\nvar side = 1;\r\nvar square = { \"upperLeft\" : { x : p.x, y : p.y },\r\n\"lowerRight\" : { x : p.x + side, y : p.y + side } } ;\r\n\r\n객체와 배열 초기화 표현식은 6장과 7장에서 좀 더 상세히 다룬다.\r\n\r\n4.3 함수 정의 표현식\r\n\r\n함수 정의 표현식 ( function definition expression)은 함수를 정의하고, 함수 정의 표현식의 값은 새로 정의된 함수다. 다시 말해, 함수 정의 표현식은 '함수 리터럴'이라 할 수 있다. 이는 객체 초기화 표현식을 '객체 리터럴' 이라고 말하는것과 같다. 함수 정의 표현식은 일반적으로 function 키워드와 중괄호로 둘러싸인 쉼표로 구분된 식별자(매개변수 이름) 목록, 중괄호로 둘러싸인 자바스크립트 코드(함수 몸체)로 이루어진다. 예를 들어, 다음의 코드를 살펴보자.\r\n\r\n// 이 함수는 전달된 값을 제곱하여 반환한다.\r\nvar square = function(x) { return x \\* x; }\r\n\r\n함수 정의 표현식은 함수 이름을 포함할 수 있다. 또한 함수는 함수 정의 표현식 대신에 함수 구문(function statement)을 사용해 정의할 수 있다. 함수 정의에 대해서는 8장에서 좀 더 자세히 알아볼 것이다.\r\n\r\n4.4 프로퍼티 접근 표현식\r\n\r\n프로퍼티 접근 표현식은 객체의 프로퍼티나 배열의 원소 값으로 평가된다. 자바스크립트에서는 두 가지 문법으로 프로퍼티에 접근할 수 있다.\r\n\r\n표현식 . 식별자\r\n표현식 [ 표현식 ]\r\n\r\n첫 번째 프로퍼티 접근 방법은 표현식에 식별자를 점(.)으로 연결한 표현식이다. 여기서 표현식은 객체를 말하고, 식별자는 앞에서 지정한 객체에서 찾을 프로퍼티의 이름을 의미한다. 프로퍼티 접근의 두 번째 방법은 객체나 배열이 되는 첫 번째 표현식 다음에 열린 대괄호와 두 번째 표현식 그리고 닫힌 대괄호를 사용하는 것이다. 여기서 사용한 두 번째 표현식은 객체의 특정 프로퍼티 이름이나 배열 내 원소의 인덱스 값이 될 수 있다. 다음 예제를 통해 자세히 살펴보자.\r\n\r\nvar o = { x : 1, y : { z : 3 } }; // 간단한 객체 리터럴 예제\r\nvar a = [o,4, [5,6]]; // 객체를 포함한 간단한 배열 리터럴 예제\r\no.x // 1: 표현식 o의 프로퍼티 x의 값\r\no.y.z // 3: 표현식 o.y의 프로퍼티 z의 값\r\no[\"x\"] // 1: 객체 o의 프로퍼티 x의 값\r\na[1] // 4: 표현식 a의 인덱스 1 위치에 있는 원소 값\r\na[2][\"1\"] // 6: 표현식 a[2]의 인덱스 1 위치에 있는 원소 값\r\na[0].x // 1: 표현식 a[0]의 프로퍼티 x의 값\r\n\r\n두 프로퍼티 접근 표현식 모두 점(.)이나 대괄호 ([) 왼쪽 표현식이 먼저 평가된다. 만약 평가된 값이 null 이나 undefined이면 이들 값은 프로퍼티를 갖지 않기 때문에 표현식은 TypeError 예외를 발생시킨다. 만약 값이 객체(또는 배열)가 아니면 객체로 변환된다(3.6절 참고). 만약 객체 표현식 다음에 점(.)과 식별자가 올 경우에는 식별자를 이름으로 갖는 프로퍼티의 값을 찾게 되고, 이 값이 전체 표현식의 값이 된다.\r\n만약 객체 표현식 다음에 두 번째 표현식이 담긴 대괄호가 올 경우에는 두 번째 표현식이 평가되고, 이 값이 문자열로 변환된다. 전체 표현식의 값은 앞에서 변환된 문자열을 이름으로 갖는 프로퍼티의 값이 된다.\r\n두 경우 모두, 객체에 해당 프로퍼티가 존재하지 않으면, 프로퍼티 접근 표현식의 값은 undefined가 된다.\r\n\r\n'. 식별자' 문법이 두 방법 중 좀 더 간단하다. 하지만 접근하려는 프로퍼티 이름이 '합법적' 식별자일 때만 사용할 수 있고, 프로그램을 작성할 때 그 식별자를 미리 알고 있어야 한다. 만약 프로퍼티 이름이 예약어이거나, 구두점 문자나 공백을 포함하고 있거나, 숫자(배열의 경우)일 때는 반드시 대괄호를 사용해야 한다. 대괄호는 프로퍼티 이름이 고정되어 있지 않고, 그 이름 자체가 어떤 연산의 결과인 경우에도 사용할 수 있다 ( 6.2.1에서 다룬 예제 참고). 객체와 객체 프로퍼티에 대해서는 6장에서, 배열과 배열의 원소에 대해서는 7장에서 자세히 다룬다.\r\n\r\n4.5 호출 표현식\r\n\r\n호출 표현식(invocation expression)은 자바스크립트에서 함수나 메서드를 호출하는(또는 실행시키는) 문법이고, 호출될 함수를 가리키는 함수 표현식으로 시작한다. 그 뒤에는 여는 괄호로 시작해 쉼표(,)로 구분된 여러 개의 호출 인자 목록이 올 수 있고, 닫는 괄호로 끝난다. 예를 들면, 다음과 같다.\r\n\r\nf(0) // f는 함수 표현식이다. 여기서 '0'은 인자 표현식이다.\r\nMath.max(x,y,z) // Math.max는 함수고, x,y,z가 호출 인자다.\r\na.sort() // a.sort는 함수고, 호출 인자가 없다.\r\n\r\n호출 표현식이 평가될 때 함수 표현식이 가장 먼저 평가되고, 그 후에 호출 인자 표현식이 순서대로 인자 값으로 평가된다. 함수 표현식의 값이 호출할 수 있는 객체가 아닐 경우는 TypeError 예외가 발생하게 된다(모든 함수는 호출 가능하다. 함수가 아닌 호스트 객체도 호출이 가능한 경우가 있다. 그 차이점은 8.7.7에서 살펴보기로 한다). 인자 값이 평가된 다음에는 함수 선언 시 지정했던 인자 이름에 인자 값이 차례로 할당되고, 마지막으로 함수의 본문이 실행된다. 값을 반환하기 위해 return문을 사용하면, 그 값이 결국 호출 표현식의 값이 된다. 함수가 값을 반환하지 않는다면, 함수 표현식의 값은 undefined가 된다. 함수 호출과 관련한 좀 더 자세한 사항은 8장에서 살펴보기로 하자.\r\n\r\n모든 호출 표현식은 한 쌍의 괄호 () 와, 괄호 앞에 오는 표현식으로 이뤄진다. 만약 그 표현식이 프로퍼티 접근 표현식이면, 호출 표현식은 메서드 호출이 된다. 메서드가 호출되면 함수의 몸체가 실행되는 동안 프로퍼티 접근 표현식이 가리키는 객체나 배열이 모두 this의 값이 된다. 이는 함수(객체 지향에서는 '메서드'로 알려진)가 자신이 속한 객체를 대상으로 동작하게 하므로 객체 지향적으로 프로그램을 작성할 수 있게 한다. 이와 관련해서는 9장에서 좀 더 자세히 살펴보겠다.\r\n\r\n메서드 호출이 아닌 호출 표현식은 보통 전역 객체를 this 키워드의 값으로 사용한다. 하지만 ECMAScript 5에서는 메서드 호출이 아닌 호출 표현식을 '엄격 모드'에서 사용할 경우, 전역 객체 대신 undefined가 this의 값이 된다. 5.7.3에서 '엄격 모드'에 대해 자세히 살펴보겠다.\r\n\r\n4.6 객체 생성 표현식\r\n\r\n객체 생성 표현식(object creation expression)은 새 객체를 생성하고, 생성자라고 부르는 함수를 호출해 객체에 속한 프로퍼티들을 초기화한다. 객체 생성 표현식은 new 키워드가 앞에 붙는다는 점을 제외하면 호출 표현식과 유사하다.\r\n\r\nnew Object()\r\nnew Point(2,3)\r\n\r\n객체의 생성자 함수를 전달인자 없이 호출할 때, 다음과 같이 괄호를 생략할 수 있다.\r\n\r\nnew Object\r\nnew Darte\r\n\r\n객체 생성 표현식이 평가될 때, 자바스크립트 인터프리터는 먼저 새로운 빈 객체를 생성하는데, 이때 생성된 객체는 객체 초기자 {}에 의해 생성되는 객체와 동일하다. 다음으로, 주어진 인자들과 함께 생성자를 호출하는데, 이때 방금 생성된 새 객체를 this 키워드의 값으로 설정하여 전달한다. 생성자 함수는 이 this 키워드를 사용해 새로 생성된 객체의 프로퍼티들을 초기화한다.\r\n\r\n일반적으로 생성자로 사용되는 함수는 값을 반환하지 않는다. 객체 생성 표현식의 값은 새롭게 생성되고 초기화된 객체다. 생성자가 특정 객체 값을 반환할 경우, 이 값이 객체 생성 표현식의 값이 되고 생성자를 통해 새로 생성된 객체는 버려진다. 생성자 함수에 대한 좀 더 자세한 설명은 9장에서 다룬다.\r\n\r\n4.7 연산자 개요\r\n\r\n연산자는 수식 표현식, 비교 표현식, 논리 표현식, 할당 표현식 등 자바스크립트에서 다양하게 쓰인다. 표 4-1에서는 각 연산자가 하는 역할을 요약하고 우선순위순으로 나열하였다.\r\n대부분의 연산자가 +와 = 같은 부호로 표현되지만, 일부는 delete와 instanceof와 같이 키워드로 표현한다. 키워드 연산자들도 문장 부호 연산자들과 마찬가지로 정규 연산자인데, 문장 부호 연산자와 비교해 덜 간결한 형태로 표현된 것뿐이다.\r\n\r\n표 4-1은 연산자를 연산 우선순위로 정렬했다. 목록에 나열된 연산자 중에서 먼저 나온 연산자가 나중 나온 연산자보다 연산 우선순위가 높다. 이처럼, 연산자는 우선순위 단계에 따라 선으로 구분되어 있다. 표에서 '결합 방향' 열은 연산자 결합 방향을 나타내는데 , L은 '왼쪽에서 오른쪽으로'를 의미하고 R은 '오른쪽에서 왼쪽으로'를 뜻한다. 그리고 '피연산자 개수' 열은 해당 연산자가 갖는 피연산자의 개수를 뜻한다. '피연산자 타입' 열은 연산자가 사용할 피연산자들의 타입을, '반환' 열은 연산자가 평가된 후 반환하는 객체 타입을 말한다. 이어지는 절에서는 표 4-1에 나와 있는 연산자들의 연산 우선순위와 결합 방향 그리고 피연산자 타입에 대해 살펴볼 것이다. 또한 연산자 자체에 대해서도 살펴보겠다.\r\n\r\n                           표 4-1 자바스크립트 연산자\r\n\r\n4.7.1 피 연산자 개수\r\n\r\n연산자에 필요한 피연산자의 개수에 따라 연산자들을 분류할 수 있다. 곱셈 연산자 \\* 처럼 자바스크립트 연산자 대부분은 2항 연산자(binary operator)다. 2항 연산자는 두 개의 표현식을 조합하여 하나의 복합 표현식으로 만들어낸다. 자바스크립트는 단항 연산자(unary operator)도 지원한다. 이런 연산자는 하나의 표현식을 좀 더 복잡한 단일 표현식으로 바꾼다. 가령 -x와 같은 표현식에서 - 연산자는 피연산자 x의 부호를 전환한다. 마지막으로 자바스크립트는 3항 연산자 (ternary operator )도 하나 지원하는데, 바로 조건부 연산자인 ?: 이다. 이는 세 표현식들의 값을 조합해 하나의 표현식으로 만들어 낸다.\r\n\r\n4.7.2 피연산자와 반환 타입\r\n\r\n일부 연산자는 값의 타입과 무관하게 동작하지만 대부분의 경우에는 피연산자 타입이 정해져 있다. 그리고 연산자들은 대체로 특정 타입의 값을 반환(또는 평가)한다. 표 4-1의 '피연산자 타입' 열은 연산자별로 피연산자 타입과 평가 후 반환되는 타입을 보여준다.\r\n자바스크립트는 필요할 떄마다 피연산자 타입을 변환한다(3.8절 참고). 곱셈 연산자 _는 두 개의 숫자 타입을 피연산자로 갖지만, 표현식 '3' _ '5'는 자바스크립트가 두 개의 피연산자를 숫자로 바꾸기 때문에 특별히 문제가 되지 않는다.\r\n\r\n이 표현식의 값은 문자열 '15'가 아니라 숫자 15다. 또한, 자바스크립트에서 모든 값은 참이나 거짓으로 평가된다는 점을 기억하자. 따라서 불리언 값을 피연산자로 갖는 연산자는 어떤 타입의 피연산자와도 문제없이 동작한다.\r\n\r\n일부 연산자들은 피연산자의 타입에 따라 다르게 작동한다. 대표적으로 + 연산자는 피연산자가 숫자 타입이면 덧셈을 하지만, 문자열 타입이면 문자열을 이어붙인다. 이와 유사하게, < 같은 비교 연산자들은 피연산자 타입에 따라 숫자나 문자열 알파벳 순서대로 비교를 수행한다. 각 연산자의 명세를 보면 해당 연산자의 타입 종속성은 어떤지, 그리고 어떤 타입 변환이 이루어지는지 알 수 있다.\r\n\r\n4.7.3 좌변 값\r\n\r\n표 4-1 ㅔ서 할당 연산자를 비롯한 몇 가지 연산자의 피 연산자 타입은 '좌변 값(lvalue)'이다. 좌변 값이란 '할당 표현식의 좌변에 나타날 수 있는 표현식'에서 유래한 용어다. 자바스크립트에서는 변수, 객체 프로퍼티, 배열 원소가 좌변 값이다. EMCAScript 명세에 의하면 내장 함수도 좌변 값을 반환할 수 있다고 한다. 하지만 실제로 이와 같은 형태로 정의된 내장 함수는 하나도 없다.\r\n\r\n4.7.4 연산자 부수 효과\r\n\r\n2 \\* 3 과 같은 간단한 표현식의 평가 결과는 프로그램의 상태에 영향을 끼치지 않으며, 프로그램이 미래에 수행할 어떤 계산에도 영향을 끼치지 않는다. 하지만 일부 표현식은 부수 효과 (side effect)를 갖는다. 이러한 효과는 미래의 평가 결과에도 영향을 미치게 된다. 할당 연산자가 대표적인 경우인데, 변수나 객체의 프로퍼티에 값을 할당하면 그 변수나 프로퍼티를 사용하는 모든 표현식의 값이 바뀌는 것이다. 이와 유사하게 증가 연산자 ++와 감소 연산자 --도 실행되면 기존의 값을 변경하는 묵시적 할당이 이루어진다. delete 연산자도 부수 효과가 있는데, 프로퍼티를 삭제하는 것은 해당 프로퍼티에 undefined 값을 할당하는 것과 유사하다(하지만 똑같지는 않다).\r\n\r\n다른 자바스크립트 연산자는 부수 효과가 없다. 하지만 함수 또는 생성자 몸체에 부수 효과가 있는 연산자를 사용한다면 함수 호출 또는 객체 생성 표현식에서도 부수 효과가 나타날 수 있다.\r\n\r\n4.7.5 연산자 우선순위\r\n표 4-1에 나열한 연산자들은 우선순위가 가장 높은 연산자부터 우선순위가 낮은 연산자 순로 정렬되어 있다. 우선순위가 같은 산자들끼리는 선으로 구분하였다. 연산자 우선순위는 연산이 수행되는 순서를 제어하는 기준이 된다. 우선순위가 높은 연산자는 상대적으로 우선순위가 낮은 연산자보다 먼저 수행된다. 다음 표현식을 살펴보자.\r\n\r\nw = x + y\\*z;\r\n\r\n곱셈 연산자 \\*는 덧셈 연산자 +보다 우선순위가 높다. 따라서 곱셈이 덧셈보다 먼저 수행된다. 또한 할당 연산자 =는 우선순위가 가장 낮기 때문에 오른쪽의 모든 연산이 완료된 후에야 할당 연산이 수행된다.\r\n원래 정해진 연산자 우선순위를 바꾸려면 명시적으로 괄호를 쓰면 된다. 앞의 예에서 강제로 덧셈을 먼저 수행하려면 다음과 같이 작성하면 된다.\r\n\r\nw = ( x + y ) \\* z;\r\n\r\n참고로, 프로퍼티 접근이나 호출 표현식은 표 4-1에 나열된 연산자들보다 항상 우선순위가 높다. 다음 표현식을 살펴보자.\r\n\r\ntypeof my.functions[x](y)\r\n\r\n비록 typeof 연산자가 우선순위가 높은 연산자 중 하나지만, 프로퍼티 접근과 함수 호출이 끝난 후에야 실행된다. 실전에서 어떤 연산이 우선하는지 확신이 서지 않는다면, 가장 간단한 해결책은 괄호를 사용해 연산 순서를 명시적으로 지정하는 것이다. 단, 한 가지 알아둘 중요한 규칙은 다음과 같다. 곱셈과 나눗셈은 덧셈과 뺄셈보다 먼저 수행되며, 할당은 우선순위가 아주 낮기 때문에 대부분의 경우 마지막으로 수행된다는 점이다.\r\n\r\n4.7.6 연산자 결합 방향\r\n\r\n표 4-1에서 'A' 라고 표시된 열은 연산자 '결합 방향(associativity)'을 지정한다고 설명했다. L은 왼쪽에서 오른쪽으로의 결합 방향을, R은 오른쪽에서 왼쪽으로의 결합 방향을 나타낸다. 연산자 결합 방향이 지정하는 것은 동일 우선순위 연산들 간의 수행 순서를 의미한다. 왼쪽에서 오른쪽으로의 결합 방향은 연산이 왼쪽에서 오른쪽으로 일어난다는 의미다. 예를 들어 뺄셈 연산자는 결합 방향이 왼쪽에서 오른쪽(L)이기 때문에,\r\n\r\nw = x - y - z;\r\n\r\n이 표현식은 다음과 동일하다.\r\n\r\nw = (( x - y) - z );\r\n\r\n반면, 다음의 표현식들은,\r\n\r\nx = ~-y;\r\nw = x = y = z;\r\nq = q?b:c?d:e?f:g;\r\n\r\n다음 표현식들과 각각 동일하다.\r\n\r\nx = ~(-y);\r\nw = ( x = ( y = z));\r\nq = a?b:\\*c?d:(e?f:g));\r\n\r\n이렇게 되는 이유는 단항, 할당, 3항 비교 연산자들의 결합 방향이 오른쪽에서 왼쪽(R)이기 때문이다.\r\n\r\n4.7.7 평가 순위\r\n\r\n연산자 우선순위와 결합 방향은 복잡한 표현식에서 어떤 연산이 우선적으로 수행되는지를(order of evaluation) 결정한다. 하지만 어떤 부 표현식(sub-expression)이 먼저 평가되는지를 정하지는 않는다. 예를 들어 표현식 w=x+y\\*z의 경우, 부 표현식 w가 먼저 평가되고, x,y,z가 차례대로 평가된다. 그 후에 y와 z를 곱한 후, x 값을 더해서 표현식 w가 가리키는 변수나 객체 프로퍼티로 값을 할당한다. 표현식에 괄호를 추가하면 곱셈, 덧셈, 할당 사이의 순서를 변경할 수 있다. 하지만 왼쪽에서 오른쪽으로의 평가 순서까지 바꿀 수는 없다.\r\n\r\n평가 순서는, 표현식 가운데에 다른 표현식의 값에 영향을 끼치는 표현식이 포함된 경우에만 중요하다. 만약에 표현식 x가 z에서 사용하고 있는 임의의 변수 값을 증가시킨다고 할 때, 여기서 중요한 점은 x가 반드시 z보다 먼저 평가되어야 한다는 것이다.\r\n\r\n4.8 산술 표현식\r\n\r\n이번 절에는 피연산자들에 산술 연산이나 기타 수치 조작을 하는 연산자에 대해 다룬다. 곱셈, 나눗셈, 뺄셈 연산자는 매우 직관적이기 때문에 다른 연산자보다 먼저 다루겠다. 덧셈 연산자는 단순히 우리가 알고 있는 덧셈 연산뿐 아니라 문자열을 이어붙일 수도 있고, 피연산자의 타입을 바꿀 수도 있어서 별도의 절에서 자세히 다룰 것이다. 단항 연산자와 비트 연산자 또한 세부 절에서 살펴보겠다.\r\n\r\n기본 산술 연산자는 \\*(곱셈), /(나눗셈), %(나머지), +(덧셈), -(뺄셈)이다. 앞에서 언급했듯이, + 연산자는 별도의 절에서 살펴보겠다. 다른 네가지 기본 산술 연산자는 단순히 각각의 피연산자를 평가하고, 값을 숫자로 변환한다. 그 다음에 피연산자들의 최종 값으로 곱셈, 나눗셈, 나머지, 뺄셈 연산을 수행한다. 수로 변환 불가능한 피연산자는 NaN 값으로 변환되며, 피 연산자 중 하나라도 NaN일 경우에는 연산 결과도 NaN이다.\r\n\r\n/연산자는 첫 번째 피연산자를 두 번째 피연산자로 나눈다. 여러분이 정수와 부동소수점 숫자를 구분하는 프로그래밍 언어에 익숙하다면, 정수를 정수로 나누면 계산 값이 당연히 정수가 되리라고 예상할 것이다. 하지만 자바스크립트에서 모든 숫자는 부동소수점 숫자로 취급된다. 따라서 모든 나눗셈 연산의 결과 또한 부동소수점 숫자 값이 된다. 예를 들어 5.2는 2가 아니라 2.5로 평가된다. 값을 0으로 나누면 양의 무한대 또는 음의 무한대 값이 되고, 0/0의 값은 NaN로 평가된다. 이들 중 어떠한 경우라도 에러가 발생하지 않는다.\r\n\r\n% 연산자는 첫 번째 피연산자에 대한 두 번째 피연산자의 나머지 연산을 수행한다. 다시 말하면 첫 번째 피연산자를 두 번째 피연산자로 나누고 남은 나머지를 반환한다는 것이다. 결과의 부호는 첫 번째 피연산자의 부호와 동일하다. 예를 들어, 5 % 2의 결과는 1이고, -5 % 2의 결과는 -1이다.\r\n일반적으로 나머지 연산자는 정수 타입의 피연산자에 대해 사용되지만, 부동소수점 값에 대해서도 적용할 수 있다. 예를 들어 6.5 % 2.1 의 결과는 0.2 이다.\r\n\r\n4.8.1 덧셈 연산자 +\r\n\r\n- 연산자가 이항 연산자로 사용될 떄는 피 연산자 숫자 값을 더하거나 피연산자 문자열을 이어 붙인다.\r\n\r\n1 + 2 // => '3'\r\n\"hello\" + \" \" + \"there: // => 'hello there'\r\n\"1\" + \"2\" // => '12'\r\n\r\n두 피연산자 값이 모두 숫자거나 문자열인 경우에는 + 연산자가 하는 일이 명확하다. 하지만 이 외의 경우에는 타입 변환이 이루어져야 하고, 연산은 타입 변환이 이루어진 후에 수행된다. + 연산자는 타입 변환 시에 문자열 이어붙이기를 먼저 수행한다. 만일 피연산자 중 하나가 문자열이거나 문자열로 바꿀 수 있는 객체라면 다른 피연산자를 문자열로 변환한 후 두 문자열을 이어 붙인다. 덧셈은 두 피연산자 값이 모두 문자열이 아니거나 문자열로 변환될 수 없을 때만 수행된다. 기술적으로 + 연산자는 다음과 같이 동작한다.\r\n\r\n    • 만일 하나의 피연산자 값이 객체라면, 3.8.3 에서 설명한 알고리즘을 이용해 객체를 원시 타입으로 바꾼다. Date 객체는 toString() 메서드에 의해 문자열로 바뀌고, 다른 객체들은 valueOf() 메서드가 원시 타입의 값을 반환 하는 경우 그 반환값으로 변경된다. 그러나 대부분의 객체는 이처럼 유용한 valueOf() 메서드를 가지고 있지 않으므로, 그 대신 toString() 메서드를 통해 변환된다.\r\n    • 피연산자가 객체에서 원시 타입으로 변환된 후, 만일 어떤 피연산자라도 문자열이면, 다른 피연산자를 문자열로 변환한 후 두 문자열을 이어 붙인다.\r\n    • 이 외의 경우에는 두 피연산자가 숫자(또는 NaN)로 변환되고 덧셈 연산이 수행된다.\r\n\r\n몇 가지 예를 살펴보자.\r\n\r\n1 + 2 // => 3: 덧셈\r\n\"1\" + \"2\" // => '12': 이어붙이기\r\n\"1\" + 2 // => '12': 숫자를 문자열로 바꾼 후 이어붙이기\r\n1 + { ? } // => \"1[object Object]\" : 객체를 문자열로 바꾼 후 이어붙이기\r\ntrue + true // => 2: 불리언 값을 숫자로 바꾼 후 더하기\r\n2 + null // => 2: null 값을 0으로 바꾼 후 더하기\r\n2 + undefined // => NaN: undefined를 NaN으로 바꾼 후 더하기\r\n\r\n마지막으로, + 연산자는 여러 문자열과 여러 숫자를 함께 사용할 때는 연산자 결합 법칙이 적용되지 않는다는 점을 반드시 기억해야 한다. 다시 말해, 연산자가 실행된 순서에 따라 연산 결과가 달라질 수 있다는 의미다. 예를 들면, 다음과 같다.\r\n\r\n1 + 2 + \" blind mice \"; // => '3 blind mice '\r\n1 + ( 2 + \" blind mice\"); // => '12 blind mice'\r\n\r\n1행은 괄호가 없기 때문에 + 연산자는 왼쪽에서 오른쪽으로 결합된다. 따라서 두 숫자가 먼저 계산되고, 그 결과 값을 문자열로 바꾼 후 남은 문자열을 이어붙인다. 2행에서는 괄호가 연산의 순서를 바꾼다. 숫자 2가 문자열로 바뀌어 문자열과 하나로 합쳐진다. 그 다음에 숫자 1을 문자열로 바꾼 후 남은 문자열을 이어붙인다.\r\n\r\n4.8.2 단항 산술 연산자\r\n\r\n단항 연산자는 하나의 피연산자 값을 수정해서 새 값으로 만든다. 자바스크립트에서는 단항 연산자가 가장 우선순위가 높고, 결합 방향은 모두 오른쪽에서 왼쪽이다. 이번 절에서 설명하는 산술 단항 연산자 (+, -, ++, --)는 하나의 피연산자를 가능한 한 숫자 타입으로 변환하려 시도한다. 느낌표(!) 문자와 +, =는 단항과 이항 연산자 양쪽으로 사용할 수 있다. 단항 산술 연산자는 다음과 같다.\r\n\r\n단항 덧셈(+)\r\n\r\n단항 덧셈 연산자는 피연산자를 숫자(또는 NaN)로 바꾼 후 값을 반환한다. 만일 피연산자가 숫자인 경우에는 아무 일도 하지 않는다.\r\n\r\n단항 뺄셈(-)\r\n\r\n뺄셈 연산자가 단항 연산자로 사용될 때는, 피연산자를 가능하면 숫자로 변환하려고 시도하고, 성공할 경우에 결과 값의 부호를 바꾼다.\r\n\r\n증가(++)\r\n\r\n++ 연산자는 단항 피연산자에 대해 증가 연산을 한다(즉, 1을 더한다). 이떄 피연산자는 반드시 좌변 값(변수, 배열 원소 또는 객체 프로퍼티 중 하나)이어야 한다. 이러한 변수, 원소, 프로퍼티가 숫자가 아닐 경우 ++ 연산자는 일단 이를 숫자 타입으로 변환하고, 거기 1을 더한 다음, 원래 변수나 원소, 프로퍼티에 대입한다.\r\n\r\n이 연산자의 결과 값은 피연산자의 어느쪽에 연산자가 위치해 있는지에 따라 다르다. 피연산자의 앞에서 사용될 경우에는 전치증가(pre-increment) 연산자라고 하며, 먼저 피연산자를 증가시킨 다음 증가된 값을 결과로 내놓는다. 피연산자의 뒤에서 사용될 경우 후치증가(post-increment) 연산자라고 하며, 마찬가지로 피연산자를 증가시키지만 결과로는 원래의 증가되지 않은 값을 내놓는다.\r\n다음 두 코드 사이의 차이점을 살펴보자.\r\n\r\nvar i = 1, j = ++i; // i와 j 모두 2이다.\r\nvar i = 1, j = i++; // i는 2이고, j는 1이다.\r\n\r\n표현식 ++x는 x=x+1과 항상 같지 않음을 명심하자. ++ 연산자는 절대 문자열 결합 연산을 하지 않고, 항상 피연산자를 숫자로 바꾼 후에 값을 하나 증가시킨다. 예를 들어, x가 문자열 \"1\"이면 ++x는 숫자 2가 되지만 x+1은 문자열\"11\"이 된다.\r\n\r\n자바스크립트에서는 자동 세미콜론 삽입 기능이 있기 떄문에, 후치증가 연산자와 그 앞에 있는 피연산자 사이에서 줄바꿈을 해서는 안 된다. 만일 이럴 경우 자바스크립트에서 이 피연산자 자체를 하나의 표현식으로 취급하게 되어 연산자 앞에 세미콜론을 삽입할 것이다. 이 연산자는 전치 및 후치 형태로 사용할 수 있고, 일반적으로 for 루프의 제어 카운터를 증가시키는 데 많이 쓰인다(5.5.3 참고).\r\n\r\n감소(--)\r\n\r\n-- 연산자 역시 ++ 연산자와 마찬가지로 좌변 값(변수, 배열 원소 또는 객체 프로퍼티 중 하나)을 피연산자로 갖는다. -- 연산자는 단항 피연산자의 값을 숫자로 바꾼 후에 1을 뺀다. 그 다음에 감소한 값을 피연산자에 다시 할당한다. ++ 연산자와 마찬가지로 -- 연산자 역시, 연산자가 어느 쪽에 위치해 있는지에 따라 결과 값이 달라진다. 만약 피연산자 앞에 있으면 피연산자의 값을 감소시키고, 감소시킨 값을 반환한다. 만일 피연산자 뒤에 있으면, 피연산자의 값을 감소시키지만 감소시키기 전 값을 반환한다. ++ 연산자에서와 같은 이유로 연산자가 후치 감소 연산자로 사용될 때는 연산자와 피연산자 사이에 줄바꿈이 있어서는 안 된다.\r\n\r\n4.8.3 비트 단위 연산자\r\n\r\n비트 단위 연산자들은 2진수를 저수준에서 조작하는 데 사용한다. 사칙연산과 같은 산술 연산을 수행하지는 않지만, 피연산자로 숫자 값을 사용하고 최종적으로 숫자 값을 반환하기 때문에 자바스크립트에서는 산술 연산자로 분류되어 있다. 이러한 연산자는 자바스크립트에서 일반적으로 널리 쓰이지 않는다. 만일 여러분이 10진수 정수를 2진수로 표현하는 것에 익숙하지 않다면 이번 절에서 설명하는 연산자들을 건너뛰어도 좋다. 비트 단위 연산자 중 네 종류(&, |, ^, ~)는 피연산자의 개별 비트에 대해 불리언 대수(Boolean Algebra)를 수행한다. 이때 피연산자의 개별 비트는 불리언 값으로 취급된다( 1 = true, 0 = false). 다른 세 종류의 비트 단위 연산자(<<, >>, >>>)는 왼쪽이나 오른쪽으로 비트를 이동할 때 사용된다.\r\n\r\n비트 단위 연산자의 피연산자로는 정수가 온다. 여기서 정수는 64비트 부동 소수점 표현법이 아니라 32비트 정수 표현법을 따른다. 비트 단위 연산자는 피연산자의 값을 가능하면 숫자로 바꾸고, 32번째 이후 비트를 잘라내어 강제로 피연산자 값을 32비트로 만든다. 이동 연산자(shift operator)의 우측 피연산자는 0과 31 사이의 값이어야 한다. 이동 연산자는 피연산자를 32비트 정수로 변환한후 여섯 번째 이상의 비트를 버림으로써 이 숫자가 적절한 범위에 들도록 한다. 놀랍게도 NaN, 양의 무한대(infinity), 음의 무한대(-infinity)는 비트 단위 연산자의 피연산자로 사용될 떄 모두 값이 0으로 바뀐다.\r\n\r\n비트 단위 AND(&)\r\n\r\n& 연산자는 두 정수 피연산자의 개별 비트끼리 불리언 AND 연산을 수행한다. 동일 위치의 비트가 두 피연산자에서 모두 설정되어 있어야만 결과 값의 해당 비트도 설정된다. 예를 들어 0x1234 & 0x00FF의 결과는 0x0034다.\r\n\r\n비트 단위 OR ( | )\r\n\r\n| 연산자는 두정수 피연산자의 개별 비트끼리 불리언OR 연산을 수행한다. 적어도 하나 이상의 피연산자에게 특정 위치의 비트가 설정되어 있으면 결과 값의 해당 위치 비트가 설정된다. 예를 들어 0x1234 | 0x00FF의 결과는 0x12FF다.\r\n\r\n비트 단위 XOR (^)\r\n\r\n^연산자는 두 정수 피연산자의 개별 비트끼리 배타적(exclusive) 불리언 OR (XOR) 연산을 수행한다. 배타적 OR란 두 연산자 중 하나가 true이지만 둘 다 true는 아닐때 결과가 true가 된다. 두 피연산자 중 하나에만 특정 위치의 비트가 설정되어 있으면 결과 값의 해당 위치 비트도 설정된다. 예를 들어 0xFF00 ^ 0xF0F0의 결과는 0x0FF0다.\r\n\r\n비트 단위 NOT (~)\r\n\r\n~연산자는 단항 연산자로 하나의 정수 피연산자 앞에 위치한다. ~ 연산자는 피연산자의 모든 비트를 반전시킨다. 자바스크립트에서 부호 있는 정수를 표현하는 방법으로 인해, 어떤 값에 ~ 연산자를 적용하면 그 값의 부호를 바꾸고 1을 빼는 것과 같은 결과를 얻게 된다. 예를 들어 ~0x0F는 0xFFFFFFF0이며, 이는 -16과 같다.\r\n\r\n왼쪽으로 이동 (<<)\r\n\r\n<< 연산자는 첫 번째 피연산자의 모든 비트를 두 번째 피연산자에서 지정한 자릿수만큼 왼쪽으로 이동시킨다. 두 번째 피연산자는 반드시 0과 31 사이의 정수여야 한다. 예를 들어 a << 1 연산의 경우 a의 첫 번째 비트는 두 번째 비트가 되고, 두 번째 비트는 세 번째 비트가 되고… 이 과정이 이어진다. 모든 비트를 이동시키면 첫 번째 비트를 새 만들어야 하는데, 새로 만들어지는 비트의 값으로는 0이 사용되며 기존의 32번째 비트는 잃어버리게 된다. 어떤 값을 왼쪽으로 한 자리 이동시키는 것은 2를 곱하는 것과 같으며, 두 자리 이동시키는 것은 4를 곱하는 것과 같다. 예를 들어 7 << 2의 결과는 28이다.\r\n\r\n부호를 보존하면서 오른쪽으로 이동 ( >>)\r\n\r\n> > 연산자는 첫 번째 피연산자의 모든 비트를 두 번째 피연산자에서 지정한 자릿수만큼 오른쪽으로 이동시킨다. 두 번째 피연산자는 반드시 0과 31 사이의 정수여야 한다. 비트를 오른쪽으로 이동시키면 맨 오른쪽 비트들은 손실된다. 왼쪽 자리에 채워질 비트는 최소 피연산자의 부호 비트가 되고, 이는 곧 결과 값의 부호가 된다. 첫 번째 피연산자가 양수면, 결과 값의 최상위 비트가 0이 되고, 음수면 최상위 비트 1이 된다. 어떤 값을 오른쪽으로 한 자리 이동시키는 것은 이 값을 2로 나누는 것과 같고, 오른쪽으로 두 자리를 이동시키는 것은 값을 4로 나누는 것과 같다. 예를 들어, 7 >> 1의 결과는 3이고, -7 >> 1의 결과는 -4다.\r\n\r\n0으로 채우면서 오른쪽으로 이동 ( >>> )\r\n\r\n> > > 연산자는 >> 연산자와 한 가지를 제외하고는 똑같다. 차이점은, 왼쪽 자리에 새로 들어오는 비트가 첫 번째 피연산자의 부호에 관계없이 무조건 0이라는 점이다. 예를 들어, -1 >> 4의 결과는 -1이지만, -1 >>> 4의 결과는 0x0FFFFFFF다.\r\n\r\n4.9 관계형 표현식\r\n\r\n이번 절에서는 자바스크립트에서 사용하는 관계형 연산자(relational operator)를 다룬다. 이러한 연산자들은 두 피연산자 값의 관계(이를테면 두 값이 같은지, 한 값이 다른 값보다 작은지 또는 한 값이 다른 값의 프로퍼티로 존재하는지 등)를 검사하여, 관계가 성립하면 true를, 그렇지 않으면 false를 반환한다. 관계형 표현식은 항상 불리언 값으로 평가되고, 이 값은 프로그램 실행의 흐름을 제어하기 위한 if문, while문, for 루프문에서 주로 사용된다. 이제부터 동치와 부등치 연산자, 비교 연산자, 관계형 연산자인 in과 instanceof를 살펴보겠다.\r\n\r\n4.9.1 동치와 부등치 연산자\r\n\r\n==와 === 연산자 모두 주어진 두 값이 같은지를 확인하는 데 쓰이지만 같음을 정의하는 기준이 서로 다르다. 두 연산자 모두 피연산자 타입을 가리지 않고, 주어진 피연산자들이 같으면 true를, 다르면 false를 반환한다. === 연산자는 일치(엄격한 동치) 연산자로 알려져 있는데, 같음을 정의하는 기준을 매우 엄격하게 정의하여, 두 피연산자가 '일치(identical)'하는지 확인한다. == 연산자는 동치 연산자로 알려져 있으며, 두 피연산자가 '동등(equal)'한지 확인할 때 필요한 경우 타입 변환을 허용한다. 이때 같음을 정의하는 기준이 === 연산자만큼 엄격하지는 않다.\r\n\r\n자바스크립트는 =(할당), ==(동치), ===(일치) 연산자를 지원하고 있다. 여러분은 할당, 동치, 일치 연산자의 차이를 확실하게 이해해야 하며, 코딩할 때 올바른 것을 사용하도록 주의해야 한다! 이 세가지를 모두 같은(equal)연산자로 혼동하기 쉬운데, 다음과 같은 방법을 사용하면 혼동을 줄이는 데 도움이 될 것이다.\r\n= 연산자는 '취하다(get) 또는 할당하다(assigned)'로, == 연산자는 '~와 같은 값으로 볼 수 있다(is equal to)', 마지막으로 === 연산자는 '~와 일치한다(is strictly equal to)'로 읽는 것이다.\r\n!=와 !== 연산자가 비교하는 것은 앞에서 살펴본 ==와 ===연산자가 비교하는것과 정확히 반대다. 부등치 연산자 !=는 두 값이 서로 동치일 경우 false를 반환하며, 그렇지 않을 경우 true를 반환한다. 불일치 연산자 !==는 두 값이 서로 일치할 경우 false를 반환하며, 그렇지 않을 경우 true를 반환한다. 4.10절에서 살펴보겠지만, ! 연산자는 불리언 NOT 연산을 수행한다. 이 점을 감안하면 !=가 '같은 값으로 볼 수 없다'를 나타내며, !==는 '일치하지 않는다'를 말한다는 사실을 쉽게 떠올릴 수 있을 것이다.\r\n\r\n3.7절에서 설명했듯이, 자바스크립트는 값 비교가 아닌, 참조 비교를 수행한다. 간단히 말해서, 객체는 자기 자신과는 같지만 다른 객체와는 같지 않다. 예를 들어 두 개의 서로 다른 객체가 같은 수의 프로퍼티를 갖고, 각 프로퍼티 이름과 값이 서로 같더라도 두 객체는 여전히 다른 객체다. 마찬가지로 두 배열이 같은 원소들을 같은 순서로 가지고 있을지라도, 이 두 배열은 같지 않다.\r\n일치 연산자 ===가 두 값이 일치하는지 여부를 판단할 때는 다음의 규칙을 따르며, 타입 변환은 하지 않는다.\r\n\r\n    • 두 값의 타입이 서로 다르면 두 값은 일치하지 않는다.\r\n    • 두 값이 모두 null이거나 모두 undefined면, 두 값은 일치한다.\r\n    • 두 값이 모두 불리언 값 true이거나 모두 false일 경우에, 두 값은 일치한다.\r\n    • 적어도 하나의 값이 NaN이면 두 값은 일치하지 않는다. NaN값은 자기 자신을 포함해 다른 어떠한 값과도 일치하지 않는다. 임의의 값 x가 NaN인지 검사하기 위해서는 x !== x와 같이 사용하면 된다. NaN은 이 표현식을 참으로 만드는 유일한 값이다.\r\n    • 두 값이 모두 숫자고 같은 값을 갖는다면, 두 값은 일치한다. 만약 하나의 값이 0이고 다른 하나의 값이 -0일지라도, 두 값은 일치한다.\r\n    • 두 값이 모두 문자열이고, 같은 위치에 정확히 같은 16비트 값(3.2절 참고)을 가지고 있다면, 두 값은 일치한다. 만약 문자열의 길이나 내용이 다를 경우, 두 값은 일치하지 않는다. 두 문자열이 같은 의미를 갖고, 육안상 같은 문자열을 갖더라도 16비트 값의 순서가 다르게 인코딩되어 있을 수도 있다. 자바스크립트에서는 유니코드 문자열에 대해서 정규화 과정을 수행하지 않으며, 이런 문자열들은 === 나 == 연산자로는 같다고 판정되지 않는다. 이와 같은 문자열을 비교하려면 3부에서 다루는 String.localeCompare()를 참고하라.\r\n    • 두 값이 모두 같은 객체나 배열 또는 함수를 참조하고 있으면, 두 값은 일치한다. 두 값이 서로 다른 객체를 참조할 경우에 ㅅ ㅓㄹ사 두 객체의 프로퍼티가 일치하더라도 두 값은 일치하지 않는다.\r\n\r\n동치 연산자 ==는 일치 연산자와 유사하지만 상대적으로 규칙이 엄격하지 않다. 두 피연산자의 값이 같은 타입이 아닐 경우에는 일부 피연산자에 대해 타입 변환을 시도한 후에 비교를 다시 하게 된다. 두 값이 동등한지 여부를 판단할 때는 다음의 규칙을 따른다.\r\n\r\n    • 두 값의 타입이 같은 경우, 두 값이 일치하는지 테스트한다. 만약 두 값이 일치할 경우 두 값은 동치다. 하지만 두 값이 일치하지 않으면 두 값은 동치가 아니다.\r\n    • 두 값의 타입이 다를 경우라 할지라도 동치일 여지가 있다. 동치임을 확인하는 과정에서 다음에 나열된 규칙들과 타입 변환이 사용된다.\r\n      * 두 값 중 하나가 null이고 다른 하나가 undefined라면 두 값은동등하다.\r\n      * 한 값이 숫자이고 다른 하나가 문자열이면, 문자열을 숫자로 변환한 후 이를 사용해 다시 비교한다.\r\n      * 두 값 중 하나가 true이면 이를 1로 변환한 후 다시 비교한다. 두 값 중 하나가 false이면, 이를 0으로\r\n        변환한 후 다시 비교한다.\r\n      * 한 값이 객체고, 다른 하나는 숫자 또는 문자열이면, 객체를 원시 타입의 값으로 변환한 후 다시 비교\r\n        한다. 객체를 원시 값으로 변환하는 데에는 해당 객체의 toString() 메서드나 valueOf() 메서드가 사용\r\n        된다. 코어 자바스크립트의 내장 클래스에서는 toString90 메서드를 사용하기 전에 valueOf() 메서드\r\n        를 사용한 변환을 먼저 시도한다. 단, Date 클래스는 예외적으로 toString() 변환을 바로 수행한다. 코\r\n        어 자바스크립트에 속하지 않은 객체에서는 각 구현에서 정의한 방식으로 원시 값 변환을 수행한다.\r\n      * 앞에서 열거하지 않은 기타 값들의 조합은 동치가 아니다.\r\n\r\n동등함을 테스트하는 예로 다음의 비교식을 살펴보자.\r\n\r\n\"1\" == true\r\n\r\n이 표현식은 true가 된다. 겉보기에 매우 다른 값들임에도 불구하고 사실은 동등한 관계인 것이다. 이 표현식에서는 먼저 불리언 값 true가 숫자 1로 변환된후 다시 비교한다. 이어서 문자열\"1\"이 숫자 1로 변환된다. 이제 두 숫자는 같은 숫자이기 때문에 비교식의 결과로 true를 반환한다.\r\n\r\n4.9.2 비교 연산자\r\n\r\n비교 연산자는 두 피연산자 값의 상대적인 순서를 판단하는 데 쓰인다.\r\n\r\n더 작다 (<)\r\n\r\n< 연산자는 첫 번째 피연산자가 두 번째 피연산자보다 크면 true로, 그렇지 않으면 false로 평가된다.\r\n\r\n더 크다 (>)\r\n\r\n> 연산자는 첫 번째 피연산자가 두번째 피연산자보다 크면 true로, 그렇지 않으면 false로 평가된다.\r\n\r\n작거나 같다 ( <= )\r\n\r\n<= 연산자는 첫 번째 피연산자가 두 번째 피연산자보다 작거나 같으면 true로, 그렇지 않으면 false로 평가된  \r\n 다.\r\n\r\n크거나 같다 ( >= )\r\n\r\n> = 연산자는 첫 번째 피연산자가 두 번째 피연산자보다 크거나 같으면 true로, 그렇지 않으면 false로 평가된\r\n\r\n     다.\r\n\r\n비교 연산자는 피연산자 타입에 제한이 없다. 하지만 오직 숫자와 문자열만 비교할 수 있기 때문에, 숫자나 문자열이 아닌 피연산자는 먼저 변환된다. 비교와 변환은 다음과 같이 일어난다.\r\n\r\n    • 피연산자 중 어느 하나가 객체로 평가되면, 3.8.3에서 살펴봤듯이 해당 객체가 원시 값으로 변환되는데, 이 과정에서 valueOf() 메서드의 반환값이 원시 타입이면 그 값을 이용하고, 그렇지 않은 경우에는 toString() 메서드의 반환 값을 이용한다.\r\n    • 객체가 원시 타입으로 변환된 후에 피연산자가 모두 문자열이라면 '알파벳 순서'대로 두 문자열을 비교하게 된다. 여기서 '알파벳 순서'란 문자열을 구성하는 16비트 유니코드 값의 순서를 말한다.\r\n    • 객체가 원시 타입으로 변환된 후에 최소한 피연산자 중 하나가 문자열이 아니면, 피연산자 모두 숫자로 변환된 후 값을 비교하게 된다. 0과 -0은 의미상 동일하다. 양의 무한대는 양의 무한대가 아닌 어떤 수보다 크고, 음의 무한대는 음의 무한대가 아닌 어떤 수보다 작다. 둘 중의 하나의 피연산자가 NaN이거나 NaN으로 변환된다면 비교 연산자는 언제나 false를 반환한다.\r\n\r\n자바스크립트 문자열은 16비트 정수 값들의 나열이고, 문자열 비교는 단순히 두 문자열이 가지고 있는 각 문자에 해당하는 숫자 값의 비교라는 점을 유념해야 한다. 유니코드에 의해 정의된 숫자 인코딩 순서는 어떤 특정 언어나 로케일(locale)에 사용되는 고유 문자의 조합과 순서가 다를 수 있다. 또한, 문자열 비교는 대소문자를 구분한다는 점을 염두에 두어야 하는데, 모든 ASCII 대문자는 모든 ASCII 소문자보다 '작다'. 이 점을 미리 알지 못하면 문자열 비교 결과에 혼란을 겪을 수 있다. 예를 들면 < 연산자에 대해 문자열 \"Zoo\"는 문자열 \"aardvark\"보다 작다.\r\n\r\n로케일 차이에서 오는 알파벳 순서 차이 등의 문제까지 고려하는, 좀 더 견고한 문자열 비교 알고리즘으로 String.localeCompare() 메서드가 있다. 대소문자를 구분하지 않고 문자열을 비교하려면, 우선 String.toLowerCase()나 String.toUpperCase() 메서드를 사용해서 비교할 문자열을 전부 소문자나 대문자로 변환해야 한다.\r\n\r\n- 연산자와 비교 연산자는 피연산자로 숫자가 올 경우와 문자열이 올 경우 전혀 다르게 동작한다. + 연산자는 문자열을 선호하는데, 피연산자가 문자열일 때는 문자열을 이어붙이는 방식으로 동작한다. 비교 연산자는 숫자를 선호하고, 두 피연산자들이 문자열일 때만 문자열 비교를 한다.\r\n\r\n1 + 2 // 덧셈. 결과는 3\r\n\"1\" + \"2\" // 결과는 '12'\r\n\"1\" + 2 // 2가 문자열로 변환되고, 결과는 '12'\r\n11 < 3 // 숫자 비교. 결과는 false\r\n\"11\" < \"3\" // 숫자 비교. '11'이 숫자 11로 변환되고, 결과는 false.\r\n\"11\" < 3 // 숫자 비교. 결과는 false\r\n\"one\" < 3 // 숫자 비교. 'one'이 NaN으로 변환되고, 결과는 false.\r\n\r\n마지막으로, <= 연산자(더 작거나 같다)와 >= 연산자( 더 크거나 같다)는 두 값이 같은지 판단할 떄, 동치 연산자의 힘을 빌리지 않는다. 그 대신, '더 작거나 같다' 연산자는 단순히 '크지 않다'로 정의되며, '더 크거나 같다' 연산자는 단순히 '작지 않다'로 정의된다. 단 한 가지 예외가 있는데, 두 피연산자 중 하나가 NaN이면 (또는 NaN으로 변환되면) 네 종류의 비교 연산자 모두 false를 반환한다.\r\n\r\n4.9.3 in 연산자\r\n\r\nin 연산자는 좌변의 피연산자로 문자열(또는 문자열로 변환될 수 있는 것)을 받는다. 우변의 피연산자로는 객체나 배열을 받는다. 좌변 값이 우변 객체의 프로퍼티 이름에 해당할 경우 연산 결과는 true다. 예를 들어보자.\r\n\r\nvar point = { x : 1, y : 1 } ; // 객체 정의\r\n\"x\" in point // => true: 프로퍼티 x가 있다.\r\n\"z\" in point // => false: 프로퍼티 z가 없다.\r\n\"toString\" in point // => true: 상속된 프로퍼티\r\nvar data = [7,8,9]; // 원소가 0, 1, 2 위치에 차례로 7, 8, 9\r\n\"0\" in data // => true: 배열에 0번째 원소가 있기 때문\r\n1 in data // => true: 배열에 1번째 원소가 있기 때문\r\n3 in data // => false: 배열에 3번째 원소가 없기 때문\r\n\r\n4.9.4 instanceof 연산자\r\n\r\ninstanceof 연산자는 좌변의 피연산자로 객체를, 우변의 피연산자로 객체 클래스의 이름을 식별자로 받는다. 좌변에 오는 객체가 우변 클래스의 인스턴스일 경우 연산 결과는 true로 평가되고, 그렇지 않은 경우에는 false로 평가된다. 9장에서 설명하겠지만, 자바스크립트에서 객체의 클래스는 객체를 초기화하는 생성자 함수로부터 정의된다. 그러므로 instanceof의 우변 피연산자는 함수가 되어야 한다. 다음 예제를 살펴보자.\r\n\r\nvar d = new Date(); // Date() 생성자로 새로운 객체를 생성한다.\r\nd instanceof Date; // => true: d는 Date()에 의해 생성되었다.\r\nd instanceof Object; // => true: 모든 객체는 Object의 인스턴스.\r\nd instanceof Number; // => false: d는 Number의 객체가 아니다.\r\nvar a = [1, 2, 3]; // 배열 리터럴 문법으로 새로운 배열을 생성한다.\r\nd instanceof Array; // => true: a는 배열이다.\r\nd instanceof Object; // => true: 모든 배열은 객체다.\r\nd instanceof RegExp; // => false: 배열은 정규 표현식이 아니다.\r\n\r\n모든 객체는 Object의 인스턴스라는 점을 기억하자. instanceof로 객체가 클래스의 인스턴스인지 판단할 때는 해당 객체의 '상위 클래스'들도 고려하게 된다. 만일 instanceof 의 좌변 피연산자가 객체가 아니면, instanceof 의 결과는 false다. 또한 우변 피연산자가 함수가 아니라면 TypeError 예외가 발생한다.\r\n\r\ninstanceof 연산자가 어떻게 동작하는지 이해하기 위해서는 '프로토타입 체인'을 이해해야 한다. 프로토타입 체인은 자바스크립트의 상속 메커니즘으로 6.2.2에서 상세히 다룬다. o instanceof f 표현식을 평가하기 위해서 자바스크립트는 f.prototype을 평가한 후, o의 프로토타입 체인에 그 값이 나타나는지 검색한다. 만일 o의 프로토타입 체인에서 f.prototype 값이 발견되면 o는 f의 인스턴스(또는 f의 하위 클래스의 인스턴스)가 되고, 표현식은 true를 반환한다. 만일 o의 프로토타입 체인에서 f.prototype 값을 찾을 수 없으면 o는 f의 인스턴스가 아니고, 표현식은 false를 반환한다.\r\n\r\n4.10 논리 표현식\r\n\r\n논리 연산자 &&, ||, ! 은 불리언 대수(Boolean algebra)를 수행한다. 논리 연산자는 종종 비교 연산자와 함께 사용되어 둘 이상의 변수가 관계되는 복잡한 표현식을 표현하기도 한다. 각 논리 연산자는 세부 항목에서 살펴볼 것이다. 논리 연산자를 온전히 이해하기 위해서는 3.3절에서 설명한 '참이 되는(truthy) 표현식' 과 '거짓이 되는(falsy) 표현식'의 개념을 다시 한번 살펴볼 필요가 있다.\r\n\r\n4.10.1 논리 AND ( && )\r\n\r\n&& 연산자는 크게 세 가지 수준에서 이해할 수 있다. 첫 번째 수준은 아주 단순한 것으로, 연산자가 불리언 피연산자에 대해 쓰일 경우에는 두 피연산자의 값에 대한 불리언 AND를 수행한다. 첫 번째 피연산자와 두 번째 피연산자가 '모두' true일 경우에만 연산 결과로 true를 반환한다. 적어도 하나 이상의 피연산자가 false라면 연산 결과로 false를 반환한다. && 는 종종 두 관계 표현식의 접속사 (conjunction)로도 쓰인다.\r\n\r\nx == 0 && y == 0 // x와 y가 모두 0이면 참이 된다.\r\n\r\n관계 표현식은 항상 true나 false로 평가되기 때문에, 위와 같이 &&를 사용하면 항상 true나 false를 반환하게 된다. 관계 연산자는 && 와 || 보다 연산자 우선순위가 높기 떄문에, 위와 같은 표현식은 괄호 없이도 안전하게 사용할 수 있다. 하지만 && 연산자의 피연산자로 반드시 불리언 값이 올 필요는 없다. 모든 자바스크립트 값은 true로 평가될 수 있거나(truthy) false로 평가될 수 있음(falsy)을 상기하자(3.3절에서 자세히 다루고있다. false로 평가되는 값은 false, null, undefined, 0, -0, NaN, ''(빈문자열)이다. 객체를 비롯한 이 외의 다른 모든 값은 true로 평가된다).\r\n\r\n&& 연산자를 이해하는 두 번째 방법은 true나 false로 평가되는 값들을 위한 불리언 AND 연산자로써 이해하는 것이다. 피연산자 모두 true로 평가되는 값이면, && 연산자는 true로 평가되는 값을 반환한다. 하지만 적어도 하나의 피연산자가 false로 평가될 경우에는 false로 평가되는 값을 반환한다. 자바스크립트에서 불리언 값을 요구하는 표현식이나 구문은 'truthy'한 값이나 'falsy'한 값과도 잘 동작한다. 이러한 이유로 &&가 항상 true나 false를 반환 하진 않는다는 사실이 실질적인 문제를 일으키지는 않는다.\r\n\r\n지금까지 && 연산자가 'true로 평가되는 값' 또는 'false로 평가되는 값'을 반환한다고 했는데 정확히 어떤 값을 말하는지 설명하지 않았다. 그래서 && 연산자를 이해하는 세 번째 수준의 방법을 설명해야 한다. && 연산자는 좌변에 있는 첫 번째 피연산자인 표현식을 먼저 평가한다. 좌변의 값이 'falsy'면, 전체 표현식의 값 역시 'falsy'여야 하므로, 단순히 좌변의 'falsy'값을 반환하고 우변의 표현식은 평가하지 않는다.\r\n\r\n반대로, 만약 좌변의 값이 'truthy'면 전체 표현식의 값은 우변 값에 따라 달라진다. 우변의 값이 'truthy'면 전체 표현식의 값도 'truthy'고, 만약 우변의 값이 'falsy'면 전체 표현식의 값도 'falsy'다. 그렇기 때문에 좌변의 값이 'truthy'면 && 연산자는 항상 우변의 값을 평가하고 반환한다.\r\n\r\nvar o = { x : 1 };\r\nvar p = null;\r\no && o.x // => 1: o가 객체이기 때문에 o.x를 반환한다.\r\np && p.x // => null: p가 null이기 때문에 p.x를 평가하지 않고 null을 반환\r\n\r\n여기서 &&가 우변 표현식을 평가할 수도, 또는 하지 않을 수도 있다는 점을 이해해야만 한다. 이 코드에서 변수 p는 null이기 때문에 표현식 p.x가 평가되면 TypeError가 발생한다. 하지만 실제로는 && 연산자는 p를 먼저 평가하기 때문에, 표현식 p.x는 반드시 p가 true로 평가될 때만(값이 null이나 undefined가 아닐 때) 실행된다. 이와 같은 && 연산자의 특성을 '단축 평가(short circuiting)'라고 부르고, 이와 같은 특성을 일부러 사용하는 코드를 종종 보게 된다. 예를 들면 다음 두 줄의 자바스크립트 코드는 동일하게 작동한다.\r\n\r\nif ( a == b) stop(); // a == b를 만족할 때만 stop() 함수를 호출한다.\r\n( a == b ) && stop(); // 작동은 위와 같다.\r\n\r\n일반적으로 && 우변에 부수 효과가 일어나는 표현식(할당, 증가, 감소, 함수 호출)을 사용할 때는 각별히 주의해야 한다. 이러한 부수 효과가 일어나는 표현식은 && 좌변 값에 따라 실행 여부가 결정된다.\r\n이 연산자는 실제 작동이 꽤나 혼란스러운 방식임에도 불구하고, 가장 일반적으로 사용되는 단순한 불리언 대수 연산자다.\r\n\r\n4.10.2 논리 OT ( || )\r\n","excerpt":"표현식 (expression)은 자바스크립트 인터프리터가 값으로 평가하는(evaluate) 자바스크립트 구문이다. 예를 들어 프로그램에 포함된 임의의 상수는 표현식의 아주 간단한 형태다. 변수 이름 또한 간단한 표현식으로, 변수에 할당된 임의의 값으…","fields":{"slug":"/javascript-study_3/"},"frontmatter":{"date":"Oct 27, 2021","title":"javascript 표현식과 연산자","tags":["javascript"],"update":"Oct 27, 2021"}}},{"node":{"rawMarkdownBody":"\r\n프로그래밍 언어로 다룰 수 있는 값의 유형을 데이터 타입이라고 한다. 프로그래밍 언어의 가장 기본적인 특징 중 하나는 바로 그 언어가 지원하는 데이터 타입의 종류다. 한편, 프로그램은 값이 유지될 필요가 있을 때, 변수에 값을 할당(저장)한다. 변수명은 그 값의 이름이므로, 그 이름을 통하면 값을 참조할 수 있다. 이러한 변수의 작동 방식도 일반적인 프로그램 언어가 갖는 기본 특징 중 하나다. 이 번 장에서는 자바스크립트의 데이터 타입과 값, 변수에 대해 설명한다. 자바스크립트의 타입은 크게 원시 타입(primitive type)과 객체 타입(object type)으로 나뉘고, 원시 타입으로는 숫자, 텍스트의 나열(문자열, string), 불리언 진리 값(불리언, boolean이라고 함)이 있다.\r\n\r\n자바스크립트에서 null과 undefined는 원시값이긴 하지만, 숫자도 아니고, 문자열이나 불리언도 아니다. 자바스크립트에서 null과 undefined는 자기 자신만을 값으로 갖는 독립적인 타입에 속한다.\r\n\r\n숫자와 문자열, 불리언, null, undefined 외의 값은 객체다. 객체(즉, object 타입의 멤버)는 이름과 값을 갖는 프로퍼티의 집합이다(여기서 값은 숫자나 문자열 같은 기본 데이터 타입 값이 될 수도 있고 객체가 될 수도 있다). 일반적인 자바스크립트 객체는 순서가 없는 값들의 집합이며, 각 값에는 이름이 지정(named)되어 있다. 한편 자바스크립트에는 배열(array)이라고 알려진 특별한 종류의 객체도 있다. 배열은순서가 있는 값들의 집합이며, 각 값에는 번호(index)가 부여된다. 자바스크립트 언어는 배열을 다루는 독특한 문법을 가지고 있다.\r\n배열은 일반적인 객체와는 다르게 동작한다.\r\n\r\n자바스크립트는 함수라고 부르는 특별한 객체도 갖고 있다. 함수는 실행 코드를 가지고 있는 객체로서, 함수를 호출하면 코드가 수행되고 계산된 값이 반환된다. 배열과 마찬가지로 함수는 일반 객체와 다르게 동작한다. 그리고 자바스크립트는 함수를 실행하기 위한 특별한 문법을 가지고 있다. 함수에 대해 알아야 할 가장 중요한 점은 함수는 값이고, 자바스크립트 프로그램은 함수를 보통 객체처럼 다룰 수 있다는 점이다.\r\n\r\n함수 중에는 새로 생성된 객체를 (new 연산자를 이용하여) 초기화하기 위해 사용되는 함수가 있는데, 이를 생성자(constructor)함수라고 한다. 생성자는 객체들의 클래스를 정의한다. 여기서 객체는 생성자로 초기화되는 대상을 말한다. 클래스는 객체 타입의 하위 타입(subtyoe)으로 생각할 수 있다. 코어 자바스크립트에서는 Array와 Function 클래스뿐만 아니라 세 개의 다른 유용한 클래스들을 정의하고 있다. Date 클래스는 날짜를 표현하는 객체를 정의하고, RegExp 클래스는 정규 표현식을 표현하는 객체를 정의한다(강력한 패턴 매칭 도구). 그리고 Error 클래스는 자바스크립트 프로그램에서 발생 할 수 있는 문법과 런타임 에러를 표현하는 객체를 정의한다. 적절한 생성자 함수를 이용하여 자신만의 클래스를 정의할 수도 있다.\r\n\r\n자바스크립트 인터프리터는 메모리 관리를 위해 자동으로 가비지 컬렉션(garbage collection)을 수행한다. 프로그램이 필요할 때 객체를 생성할 수 있고, 프로그래머는 이 객체를 어떻게 해제할지 걱정할 필요가 없다. 객체에 더 이상 접근할 수 없을 때(프로그램이 더 이상 객체를 참조하지 않을 때) 인터프리터는 그 객체가 다시 사용되지 않을 거라 판단하고 자동으로 메모리에서 해제한다.\r\n\r\n자바스크립트는 객체 지향 언어다. 넓은 의미에서 이는, 다양한 타입의 값을 다루는 전역 함수를 정의해두기보다, 어떤 값과 작동하는 메서드를 그 값의 타입에 정의해둔다는 말이다. 예를 들어, 배열의 원소들을 정렬할 때는 배열a를 sort() 함수에 인자로 전달하지 않는다. 대신에, a의 sort() 메서드를 호출하여 정렬한다.\r\n\r\na.sort(); // sort(a)의 객체 지향 버전\r\n\r\n기술적으로, 자바스크립트 객체만이 메서드를 소유한다. 하지만 숫자, 문자열, 불리언 값은 메서드를 가진 것처럼 동작한다. null과 undefined는 자바스크립트에서 유일하게 메서드를 가질 수 없는 값이다.\r\n\r\n자바스크립트의 타이비은 원시 타입과 객체 타입으로 나뉠 수 있다. 메서드를 가진 타입과 그렇지 않은 타입으로도 나뉠 수 있다. 또한 수정 가능한(mutable)타입과 수정할 수 없는(immutable)타입으로도 나뉠 수 있다. 수정 가능한 타입의 값은 바꿀 수 있다. 객체와 배열은 수정 가능한 타입이다. 따라서 자바스크립트 프로그램은 객체 프로퍼티와 배열 원소의 값을 변경할 수 있다. 숫자와 불리언, null, undefined는 수정할 수 없는 타입이다. 예를 들어, 숫자는 그 자체로 값이므로 변경한다는 것 자체가 말이 안 된다. 한편 문자열은 문자들의 배열이니 변경 가능한 타입이라고 생각할지도 모르겠다. 하지만, 자바스크립트에서 문자열은 수정할 수 없는 타입이다. 여러분은 문자열의 인덱스를 이용하여 문자에 접근할 수는 있는지만, 자바스크립트는 문자열의 문자를 바꾸는 어떤 방법도 제공하지 않는다.\r\n\r\n자바스크립트의 값은 타입 변환이 자유롭다. 예를 들어, 프로그램이 문자열을 인자로 받아 처리하는데 여러분이 숫자를 인자로 넘겼다면, 숫자를 자동으로 문자열로 변경할 것이다. 마찬가지로, 불리언 값을 다루는 곳에 불리언 값이 아닌 값을 사용한다면, 자바스크립트는 적절하게 불리언 값으로 변경할 것이다. 자바스크립트의 자유로운 값 변환 규칙은 동일성(equality) 정의에도 영향을 미친다.\r\n\r\n자바스크립트 변수들은 타입이 정해져 있지 않다. 여러분은 변수에 어떤 타입의 값도 할당할 수 있고, 나중에 같은 변수에 다른 타입의 값을 할당할 수 있다. 변수는 var 키워드로 선언한다. 자바스크립트는 어휘 유효범위(scope)를 사용한다. 함수 밖에서 선언된 변수들은 전역 변수고 자바스크립트 프로그램 어디서든 사용할 수 있다. 함수 안에 선언된 변수들은 유효범위가 함수 영역이며, 오직 함수 안에서만 사용할 수 있다.\r\n\r\n3.1 숫자\r\n\r\n다른 프로그래밍 언어들과는 다르게 자바스크립트는 정수 값과 실수 값을 구분하지 않는다. 자바스크립트에서는 모든 숫자를 실수로 표현한다. 프로그램 안에서 있는 그대로 등장하는 숫자를 숫자 리터럴(numberic literal)이라고 한다. 자바스크립트에서는 여러 형태의 숫자 리터럴을 지원하는데, 숫자 리터럴은 첫 번째 숫자 왼편에 뺄셈 기호(-)를 사용하는 방법으로 음수를 표현할 수 있다. 하지만 기술적으로 -는 단항 부정 연산자(unary negation operator)이지 숫자 리터럴의 일부는 아니다.\r\n\r\n3.1.1 정수 리터럴\r\n\r\n자바스크립트에서 10진수 정수는 숫자를 일렬로 나열한 것이다. 예를 들면, 다음과 같다.\r\n\r\n0\r\n3\r\n100000000000\r\n\r\n자바스크립트는 10진수 리터럴 이외에도 16진수 값을 인식한다. 16진수 리터럴은 '0x'나 '0X' 뒤에 16진수 숫자들이 뒤따르는 형태다. 16진수 숫자는 0에서 9까지의 문자와 10부터 15까지를 표현하는 a(혹은 A)부터 f(혹은 F) 까지의 문자 중 하나다. 다음 예제를 통해 16진수 정수 리터럴을 살펴보자.\r\n\r\n0xff // 15\\*16 + 15 = 255 255 ( base 10) 십진수 255\r\n0xCAFE911\r\n\r\n일부 자바스크립트 구현체에서는 정수 리터럴을 8진수로도 표현할 수 있다. 하지만 ECMAScript 표준에서 8진수 표현을 지원하지는 않는다. 8진수 리터럴은 숫자 0 뒤에 0부터 7 사이의 숫자 시퀸스가 뒤따르는 형태다. 예를 들면 다음과 같다.\r\n\r\n0377 // 3*64 + 7*8 + 7 = 255 255 (base 10) 십진수 255\r\n\r\n자바스크립트 구현체에 따라 8진수 리터럴을 지원할 수 있고 하지 않을 수도 있기 떄문에 0으로 시작하는 정수 리터럴은 절대로 사용하지 말아야 한다. 이 경우에, 리터럴이 8진수인지 10진수인지 사용자가 판단하기 힘들기 때문이다. ECMAScripts 5의 엄격 모드 (Strict Mode)에서는 8진수 리터럴을 명시적으로 금지하고 있다.\r\n\r\n3.1.2 부동소수점 리터럴\r\n\r\n부동소수점(floating-point) 리터럴은 소수점을 가질 수 있다. 부동소수점 리터럴은 실수를 표현하는 전통적인 문법을 따른다. 실수는 정수 부분과 소수점, 소수점 이하 부분으로 표현한다.\r\n부동소수점 리터럴은 지수 표기법(exponential notation)으로도 표현할 수 있다. 실수에 이어 문자 e(혹은 E)가 따라나오고, 그뒤에 선택적으로 덧셈 혹은 뺄셈 기호가 나타나고 마지막으로 정수 지수 값이 따라온다. 지수 표기법으로 표현한 값은 실수에 10을 지수 횟수만큼 곱한 값을 나타낸다. 보동소수점 표기법을 더 간결하게 표현하면 다음과 같다 (과연 이게 간결한겨..?..)\r\n\r\n[''digits''][.''digits''][( E | e ) [(+ | - ) ''digite'']\r\n\r\n예제는 다음과 같다.\r\n\r\n3.14\r\n2345.789\r\n.3333333333333333\r\n6.02e23 // 6.02 x 10^23 (10의 23승)\r\n1.4738223E-32 // 1.4738223 x 10^-32 ( // 10의 -32승)\r\n\r\n3.1.3 산술 연산\r\n\r\n자바스크립트에서는 언어에서 제공하는 산술 연산자를 사용하여 숫자를 다룬다. 산술 연산자로는 덧셈을 위한 +와 뺄셈을 위한 -, 곱셈을 위한 \\*, 나눗셈을 위한 /와 나눗셈 연산을 한 후 나머지를 구하는 % 연산자가 있다.\r\n자바스크립트는 기본적인 산술 연산뿐 아니라, 더 복잡한 수치 연산을 Math 객체를 통해 지원한다. Math 객체에는, 수치 연산에 쓰이는 다양한 함수와 상수들이 프로퍼티 형태로 정의되어 있다. 아래의 예제를 보자.\r\n\r\nMath.pow(2,53) // => 9007199254740992: 2의 53승\r\nMath.round(.6) // => 1.0: 반올림\r\nMath.ceil(.6) // => 1.0: 올림\r\nMath.floor(.6) // => 0.0: 내림\r\nMath.abs(-5) // => 5: 절대 값\r\nMath.max(x,y,z) // => 가장 큰 인자를 반환한다.\r\nMath.min(x,y,z) // => 가장 작은 인자를 반환한다.\r\nMath.random() // => 0과 1.0 사이에 임의의 수 x를 반환한다.\r\nMath.PI // n: 원주율\r\nMath.E // e: 자연 로그 상수\r\nMath.sqrt(3) // 3의 제곱근\r\nMath.pow(3, 3) // 3의 세제곱\r\nMath.sin(0) // 삼각함수(Math.cos, Math.atan 등)\r\nMath.log(10) // 자연 로그 10\r\nMath.log(100) /Math.LN10 // 밑이 10인 로그 100\r\nMath.log(512)/Math.LN2 // 밑이 2인 로그 512\r\nMath.exp(3) // Math.E의 3 거듭제곱\r\n\r\n자바스크립트가 지원하는 모든 수리 함수에 대한 자세한 설명은 레퍼런스의 Math 객체 부분을 참고\r\n자바스크립트의 산술 연산은 오버플로와 언더플로, 0으로 나누는 에러를 발생시키지 않는다. 산술 연산의 결과가 표현할 수 있는 가장 큰 수보다 더 크다면 (오버플로overflow), 자바스크립트는 Infinity라고 표현하는 무한대의 값을 출력한다. 비슷하게, 표현 가능한 가장 작은 음수 값보다 더 작은 값은 음의 무한대가 되면 자바스크트는 이 값을 -Infinity로 출력한다.\r\n\r\n언더플로(underflow)는 산술 연산의 결과가 표현할 수 있는 가장 작은 값보다 더 0에 가까울 때 발생한다. 이런 경우에 자바스크립트는 0을 돌려준다. 만약 언더플로가 음수에서 발생했다면 자바스크립트는 특수 값인 '음의 0'을 반환한다. 자바스크립트에서 0으로 나누는 연산은 에러가 아니다. 이런 경우에 무한대 또는 음의 무한대가 반환된다. 그런데 여기에는 한 가지 예외가 있다. 0을 0으로 나누는 것은 정의되지 않은 값을 갖고, 그 결과로 숫자가 아닌 특수한 값을 가진다. 자바스크립트에서는 이러한 값을 NaN으로 출력한다. 또한, NaN은 무한대를 무한대로 나누는 경우와 음수 값에 루트를 씌우는경우, 숫자가 아닌 피연산자로 산술 연산을 시도하는 경우에도 발생한다.\r\n\r\n자바스크립트는 양의 무한대와 숫자가 아닌 값을 표현하기 위해 전역 변수 Infinity, NaN을 미리 정의한다. ECMAScript 3에서 Infinity와 NaN은 읽고 쓰기가 가능한 값이고 값이 변할 수도 있지만, ECMAScript 5에서는 Infinity와 NaN을 읽기 전용 값으로 정의한다. Number 객체에는 Infinity와 NaN이 따로 상수로 정의되어 있으며, 이들 상수는 ECMAScript 3에서도 읽기 전용이다. 다음 예제를 통해 살펴보자.\r\n\r\nInfinity // 읽고 쓰기 가능한 변수로 INfinity로 초기화된다.\r\nNumber.POSITIVE_INFINITY // Infinity와 같은 값이지만 읽기 전용이다.\r\n1/0 // Infinity와 같은 값이다.\r\nNumber.MAX_VALUE + 1 // 역시 Infinity로 평가된다.\r\nNumber.NEGATIVE_INFINITY // 이 표현은 음의 무한대다.\r\n-Infinity\r\n-1/0\r\n-Number.MAX_VALUE - 1\r\nNaN // 읽고 쓰기 가능한 변수로 NaN으로 초기화된다.\r\nNumber.NaN // NaN과 같은 값을 갖지만 읽기 전용 프로퍼티다.\r\n0/0 // NaN으로 평가한다.\r\nNumber.MIN_VALUE/2 // 언더플로: 0으로 간주한다.\r\n-Number.MIN_VALUE/2 // 음의 0으로 간주한다.\r\n-1/Infinity // 이것 또한 음의 0으로 간주한다.\r\n-0\r\n\r\n자바스크립트에서 NaN은 한 가지 독특한 기능을 가지고 있다. NaN은 그 자신뿐만 아니라 다른 값과 같은지 비교할 수 없다. 다시 말해, 변수 x가 NaN인지 판단하기 위해 x == NaN 문을 작성할 수 없다. 대신에 x != x 라고 작성해야 한다. x가 NaN이라면 이 표현식은 참일 것이다. isNaN() 함수는 이러한 경우에 유용하게 사용할 수 있다. 이 함수는 인자가 NaN이거나, 문자열이나 객체처럼 숫자가 아니라면 참을 반환한다. 이와 유사한 함수 isFinite() 는 인자가 NaN, Infinity 또는 -Infinity 이외의 숫자라면 참을 반환한다.\r\n\r\n음의 0도 좀 특이하다. 음의 0은 양의 0과 같은지 (자바스크립트의 엄격한 동치 테스트를 사용하여) 비교할 수 있는데, 나눗셈을 할 때를 제외하고는 거의 같다.\r\n\r\nvar zero = 0; // 일반적인 0\r\nvar negz = -0; // 음의 0\r\nzero === negz // => true: 0과 음의 0은 같다.\r\n1/zero === 1/negz // => false: 무한대와 음의 무한대는 같지 않다.\r\n\r\n3.1.4 이진 부동소수점과 반올림 오류\r\n\r\n무한히 많은 실수가 있지만 자바스크립트에서는 한정된 숫자만 부동소수점 형태로 표현할 수 있다. 자바스크립트에서 실수 연산을 할 때는 근사 값으로 표현한다.\r\n자바스크립트(뿐만 아니라 다른 현대적인 프로그래밍 언어)에서 사용하는 IEEE-754 부동소수점 표현 방식은 1/2, 1/8 1/1024 같은 분수를 정확하게 표현할 수 있는 이진 표현법(binary representation)이다. 하지만 가장 많이 사용하는(특히 간단한 계산을 할 때 주로 사용하는) 분수는 10진수 분수로 1/10, 1/100등인데, 이진 표현법으로는 0.1과 같은 간단한 값도 정확하게 표현할 수 없다.\r\n\r\n자바스크립트에서 숫자는 높은 정밀도를 가지고 있어서 0.1에 근접한 근사치를 낼 수 있지만, 정확하게 표현할 수 없다는 점은 문제를 야기할 수 있다. 다음 코드를 살펴보자.\r\n\r\nvar x = .3 - .2; // 0.3 - 0.2\r\nvar y = .2 - .1; // 0.2 - 0.1\r\nx == y // => false: 두 값은 같지 않다.\r\nx == .1 // => false: 0.3 - 0.2는 0.1이 아니다.\r\ny == .1 // => true: 0.2 - 0.1은 0.1과 같다.\r\n\r\n반올림 오류 때문에, .3 근사치와 .2 근사치의 차는 .2와 .1의 근사치 사이의 차이와 같지 않다. 이는 자바스크립트가 가진 결함이 아니라 이진 부동소수점 숫자를 사용하기 때문에 벌어지는 현상이며, 이진 부동소수점 숫자를 사용하는 프로그래밍 언어에서 볼 수 있는 공통적인 현상이다. 또한 코드의 x와 y 값은 서로 매우 근접하고 정답 (0.1)에 가까운 값이다. 계산된 값은 대부분 적절하지만, 값들을 동등 비교할 경우에는 문제가 발생한다. 자바스크립트의 다음 버전은 이런 반올림 문제를 피하는 십진수 타입을 지원 할 것이다. 하지만 그때까지 민감한 금융 계산에는 환산된 정수 값을 이용해야 할 수도 있다. 소수점이 포함된 달러(\\$) 대신 정수 값인 센트로 화폐 단위를 변경하는 경우처럼 말이다.\r\n\r\n3,1,5 날짜와 시간\r\n\r\n코어 자바스크립트는 날짜와 시간을 표현하는 객체를 생성하는 Date() 생성자를 제공한다. Date 객체는 간단한 날짜 계산을 하는 메서드를 가지고 있다. Date 객체는 숫자 같은 원시 타입이 아니다.\r\n\r\nvar then = new Date(2010, 0, 1); // 2010년 1월 1일\r\nvar later = new Date(2010, 0, 1, 17, 10, 30); // 2010년 1월 1일, 오후 5시 10분 30초\r\n\r\nvar now = new Date(); // 현재 날짜와 시간\r\nvar elapsed = now - then; // 밀리초로 날짜 계산\r\n\r\nlater.getFullYear() // 2010\r\nlater.getMonth() // 0: 월은 0부터 시작한다.\r\nlater.getDate() // 1: 일은 1로 시작한다.\r\nlater.getDay() // 5: 요일. 0은 일요일, 5는 금요일\r\nlater.getHours() // 17: 오후 5시\r\nlater.getUTCHours() // 시간대에 의존한 UTC 시간\r\nlater.toString() //\r\nlater.toUTCString() //\r\nlater.toLocaleDateString() //\r\nlater.toLocaleTimeString() //\r\nlater.toISOString() // ECMAScript 5에서만 지원한다.\r\n\r\n3.2 텍스트\r\n\r\n문자열(string)은 16비트 값들이 연속적으로 나열된 변경이 불가능한 값으로, 각 문자는 유니코드 문자로 표현된다.(string은 텍스트를 표현하는 자바스크립트 타입이다). 문자열의 길이 값은 문자열에 들어 있는 16비트 값의 개수다. 자바스크립트에서 문자열(그리고 배열)은 0 기반의 인덱싱을 사용한다. 따라서 첫 번째 16비트 값은 인덱스 0번째에 위치하고, 두 번째는 인덱스 1번째에 위치한다. 빈 문자열은 길이 값이 0이다. 자바스크립트에는 문자 하나를 표현하는 타입이 없다. 그러므로 하나의 16비트 값을 표현하기 위해서는 길이가 1인 문자열을 사용하면 된다.\r\n\r\n3.2.1 문자열 리터럴\r\n\r\n자바스크립트 프로그램에서 문자열 그대로를 포함하려면 단순히 문자열을 작은 따옴표 혹은 큰따옴표(' 또는 \" )로 둘러싸면 된다. 큰따옴표는 작은따옴표로 둘러싸인 문자열에 포함될 수 있고 작은따옴표 역시 큰따옴표로 싸여있는 문자열안에 포함될 수 있다. 예제를 통해, 문자열 리터럴을 살펴보자.\r\n\r\n\"\" // 빈 문자열 : 문자가 없다.\r\n'testing'\r\n\"3.14\"\r\n'name=\"myform\"'\r\n\"0'reilly의 책을 더 좋아하지 않습니까?\"\r\n\"이 문자열은 \\n 두 줄이다.\"\r\n\"n는 원지름에 대한 둘레의 비율이다.\"\r\n\r\nECMAScript 5에서는 줄 끝에 역슬래시(\\)를 놓으면 한 줄ㅇ르 여러 줄로 작성할 수 있다. 역슬래시와 그 뒤에 오는 줄 종료자(line terminator)는 문자열 리터럴의 일부가 아니다. 문자열 리터럴에 줄바꿈 문자를 포함시켜야 한다면, 문자 시퀸스 \\n을 사용하라.\r\n\r\n\"two \\nlines\" // 한 줄이 두 줄로 표현되는 한 문자열\r\n\"one\\ // 세 줄로 표현된 한 줄 문자열. ECMASCript 5에서만 가능.\r\nlong\\\r\nline\"\r\n\r\n문자열을 구분하는 작은 따옴표를 사용할 때는 영어에서 can't와 O'Reilly's 같은 단축형 표현과 소유형 단어에 주의해야 한다. 아포스트로피(')가 작은따옴표와 같기 때문에, 작은따옴표로 감싸진 문자열에서 아포스트로피를 '이스케이프(Escape)'시키기 위해서 역슬래시(\\)를 사용해야 한다.\r\n\r\n클리어언트 측 자바스크립트 프로그래밍에서 자바스크립트 코드는 HTML 코드를 포함할 수 있고, HTML 코드도 자바스크립트 코드를 ㅗ함할 수 있다. 자바스크립트처럼 HTML은 문자열을 구분하기 위해 작은따옴표 혹은 큰따옴표를 사용한다. 따라서 자바스크립트와 HTML을 섞어서 사용할 때는 자바스크립트 코드에서 작은따옴표나 큰따옴표 중 하나를 사용하고 HTML 코드에서 나머지 하나를 사용하는 것이 좋다. 다음 예에서 \"Thank you\"는 자바스크립트 표현식 내에서 작은따옴표로 둘러싸여 있고 이것은 다시 HTML 이벤트 처리기 어트리뷰트 내에서 큰따옴표로 둘러싸여 있다.\r\n\r\n<button onclick=\"alert('Thank you')\">Click Me</button>\r\n\r\n3.2.2 문자열 리터럴 내의 이스케이프 문자열\r\n\r\n역슬래시 문자(\\)는 자바스크립트 문자열에서 특별한 목적을 위해 사용한다. 역슬래시 문자는 뒤따라 나오는 문자와 결합될 경우 다른 방식으로는 표현할 수 없는 문자를 표현한다. 예를 들어, \\n은 줄바꿈 문자를 나타내는 이스케이프 시퀸스다.\r\n\r\n또 다른 예로, 앞에서 언급했던 \\' 이스케이프 시퀸스가 있다. \\' 이스케이프 시퀸스는 작은따옴표로 둘러싸인 문자열 리터럴 내에 작은 따옴표 문자를 포함시켜야 할 때 유용하게 사용할 수 있다. 이제 이러한 표현을 이스케이프 시퀸스로 부르는 이유를 알 수 있을 것이다. 역슬래시는 작은따옴표문자를 일반적인 해석 방식에서 벗어나 특수한 방식으로 해석하게 만든다. 다음과 같이 역슬래시를 사용하면 작은따옴표가 문자열의 끝을 나타내는 것이 아니라 영어 단축형 문자를 나타나게 할 수 있다.\r\n\r\n'You\\'re reght, it can\\'t be a quote'\r\n\r\n3.2.3 문자열 다루기\r\n자바스크립트가 지원하는 기본 기능 중 하나는 여러 문자열을 이어붙이는 것이다. 숫자에 + 연산자를 적용하면 숫자들이 더해진다. 하지만 문자열에 적용하면 두 번째 문자열을 첫 번째 문자열에 이어 붙인다. 예를 들면, 다음과 같다.\r\n\r\nmsg = \"Hello, \" + \"world\"; // 문자열을 합친다. \"Hello world\"\r\ngreeting = \"Welcome to my blog,\" + \" \" + name;\r\n\r\n문자열의 길이를 알고 싶다면 length 프로퍼티를 사용하라. 문자열 s의 길이를 알고 싶다면 다음과 같이 한다.\r\n\r\ns.length\r\n\r\nlength 프로퍼티 이외에도 문자열을 다루는 다양한 메서드가 있다(보다 자세한 사항은 레퍼런스 부분을 참고하기 바란다).\r\n\r\nvar s = \"hello, world\" // 'hello world' 를 사용한다\r\ns.charAt(0) // => \"h\": 첫 번째 문자\r\ns.charAt(s.length-1) // => \"d\": 마지막 문자\r\ns.substring(1,4) // => \"ell\": 두 번째, 세번째, 네 번째 문자\r\ns.slice(1,4) // => \"ell\": 두 번째, 세번째, 네 번째 문자\r\ns.slice(-3) // => \"rld\": 마지막 세 문자\r\ns.indexOf(\"l\") // => 2: 문자 l이 위치한 첫 번째 위치\r\ns.lastIndexOf(\"l\") // => 10: 문자 l이 위치한 마지막 위치\r\ns.indexOf(\"l\", 3) // => 3: 세 번째 문자 이후, 문자 \"l\"이 등장하는 첫위치\r\ns.split(\", \") // =>[\"Hello, world\"]: 부분 문자열로 나눈다.\r\ns.replace(\"h\", \"H\") // => \"Hello, world\" : 문자열에서 h를 H로 바꾼다.\r\ns.toUpperCase() // => \"HELLO, WORLD\"\r\n\r\n자바스크립트에서 문자열은 변경되지 않는다. replace()와 toUpperCase() 같은 메서드는 기존 문자열을 변경하지 않고 새 문자열을 반환한다. 즉, 문자열 관련 메서드는 호출 시에 기존 문자열을 수정하지 않는다.\r\nECMAScript 5에서 문자열은 읽기 전용 배열처럼 취급될 수 있고, 대괄호 대신 charAt() 메서드를 사용해도 문자열의 개별 문자(16비트 값)에 접근할 수 있다.\r\n\r\ns = \"hello, world\";\r\ns[0] // => \"h\"\r\ns[s.length-1] // => \"d\"\r\n\r\n파이어폭스를 비롯한 모질라 기반의 웹브라우저는 오랫동안 이런 방식으로 문자열에 접근할 수 있었다. ECMAScript 5에서 표준화가 되기 전에도 대부분의 최신 브라우저(IE를 제외한 브라우저)들이 모질라의 방식을 따르고 있었다.\r\n\r\n3.2.4 패턴 매칭\r\n\r\n자바스크립트는 문자 패턴을 나타내는 객체를 생성하기 위해 RegExp() 생성자를 정의한다. 이 패턴은 정규 표현식이라 부르며, 자바스크립트는 정규 표현식을 위해 펄(Perl)의 구문을 따른다. 문자열과 RegExp 객체는 모두 패턴 매칭과 '검색 후 바꾸기' 기능을 수행하는 메서드를 가지고 있다.\r\n\r\nRegExp는 자바스크립트의 원시 타입이 아니다. Date 객체처럼 RegExp는 유용한 API를 가지고 있는 특별한 종류의 객체다. 정규 표현식 문법은 복잡하고, API 또한 명확하지 않다. 하지만 RegExp는 문자를 다루는 강력한 수단을 제공할 뿐 아니라 일반적으로 사용되기 때문에, 이번 절에서 간단히 개요를 살펴보기로 하자.\r\n\r\nRegExp가 자바스크립트의 기본 데이터 타입은 아니지만, 자바스크립트는 정규식에 대한 리터럴 문법을 가지고 있고(또는 지원하고) 이는 자바스크립트 프로그램으로 바로 해석될 수 있다. 한 쌍의 슬래시 사이에 있는 문자열은 정규 표현식 리터럴을 구성한다. 한 쌍의 슬래시 중 두 번째 슬래시 뒤에는 하나 혹은 그 이상의 문자가 뒤따라 올 수 있는데, 이것은 패턴의 의미를 수정할 수 있다. 예를 들면, 다음과 같다.\r\n\r\n/^HTML/ // HTML로 시작하는 문자열\r\n/[1-9] [0-9]\\*/ // 0 아닌 숫자로 시작하는 문자\r\n/\\bjavascript\\b/i // 대소문자 구별 없이 javascript와 일치하는 문자열\r\n\r\nRegExp 객체에는 유용한 메서드들이 정의되어 있다. 또한 문자열은 RegExp 객체를 인자로 갖는 메서드들을 가지고 있다. 예를 들면, 다음과 같다.\r\n\r\nvar text = \"testing: 1, 2, 3\"; // 간단한 문자열\r\nvar pattern = /\\d+/g // 하나 이상의 모든 숫자와 일치\r\npattern.test(text) // => true: 일치하는 문자열이 존재\r\ntext.search(pattern) // => 9: 첫 번째로 매치하는 문자열의 위치\r\ntext.match(pattern) // => [\"1\", \"2\", \"3\"]: 일치된 항목의 배열\r\ntext.replace(pattern, \"#\"); // => \"testing: #, #, #\"\r\ntext.split(/\\D+/); // => [\"\", \"1\", \"2\", \"3\"]: 숫자가 아닌 문자(열)를 기준으로\r\n분할\r\n\r\n3.3 불리언 값\r\n\r\n불리언(Boolean) 값은 참/거짓, on/off, yes/no를 표현한다. 불리언 값이 될 수 있는 표현식은 항상 예약어인 true와 false 중 하나의 값으로 평가된다. 일반적으로 불리언 값은 자바스크립트 프로그램에서 비교의 결과로 생성된다. 예를 들면, 다음과 같다\r\n\r\na == 4\r\n\r\n이 코드는 변수 a의 값이 숫자 4와 같은지 검사한다. 만약 같다면 이 비교 결과는 불리언 값 true가 된다. a가 4와 같지 않다면 비교 결과는 false가 된다.\r\n일반적으로 불리언 값은 자바스크립트 제어 구조 내에서 사용된다. 예를 들어, 자바스크립트에서 if/else문은 불리언 값이 true 일 경우 한 가지 동작을 수행하고 false일 경우 나머지 동작을 수행한다. 대개 불리언 값을 반환하는 비교문과 이 비교문을 사용하는 문장을 결합해서 사용한다. 그 결과는 다음과 같다.\r\n\r\nif ( a == 4)\r\nb = b + 1;\r\nelse\r\na = a + 1;\r\n\r\n이 코드는 a가 4와 같은지를 검사한다. 만약 그렇다면 b에 1을 더하고 아니라면 a에 1을 더한다. 3.8절에서는 어떤 자바스크립트 값이든 불리언 값으로 변환될수 있음에 대해 설명할 것이다. 다음은 모두 불리언 false 값으로 변한다.\r\n\r\nundefined\r\nnull\r\n0\r\n-0\r\nNaN\r\n\"\" // 빈 문자열\r\n\r\n객체(와 배열)를 포함하는 다른 모든 값은 불리언 값 true로 변환되고, true처럼 동작한다. false와 false로 변환되는 앞의 여섯 값들은 때때로 거짓으로 판정되는 (falsy) 값이라고 불리고, 그 밖의 모든 값들은 참으로 판정되는(truthy) 값이 라고 불린다. 자바스크립트는 언제든지 거짓으로 판정되는 값이 false로, 참으로 판정되는 값이 true로 동작할 거라고 기대한다.\r\n예를 들어, 변수 o가 객체 또는 null 값을 갖고 있다고 가정하자. 다음과 같은 구문을 사용하면 o가 null이 아닌지 여부를 명확히 테스트할 수 있다.\r\n\r\nif ( o ! == null) …\r\n\r\n불일치 연산자 !==는 o와 null을 비교하고 true인지 false인지 평가한다. 하지만 다음 코드와 같이 비교를 생략하는 대신 null이 거짓으로 판정되는 값이고 객체가 참으로 판정되는 값이라는 점을 이용할 수 있다.\r\n\r\nif (o) …\r\n\r\n첫 번째 케이스 if문의 몸체는 o가 null이 아닐 때 실행될 것이다. 두 번째 케이스는 덜 엄격하다. o가 false 혹은 거짓 값(null 이나 undefined)이 아니라면 if의 몸체가 실행될 것이다. 프로그램 내에서 if문이 적절한지는 여러분이 o에 어떤 값이 할당되기를 기대하는지에 달렸다. o과 \"\"가 null과 다른지 구별할 필요가 있다면 명확한 비교를 사용해야 한다.\r\n\r\n불리언 값은 문자열 \"true\" 혹은 \"false\"로 변환할 수 있는 toString() 메서드를 가지고 있지만 그 밖의 메서드는 가지고 있지 않다. 비록 API는 단순하지만, 불리언 값에 사용되는 세 가지 중요한 연산자가 있다.\r\n&& 연산자는 불리언 AND 연산을 수행한다. &&는 두 피 연산자가 참일 때 참으로 평가하고 그렇지 않다면 거짓으로 평가한다. || 연산자는 불리언 OR 연산자이다. ||는 두 피연산자 중 하나라도 참이라면 참으로 평가하고, 두 피연산자 모두 거짓이라면 거짓으로 평가한다. 마지막으로 단항 ! 연산자는 불리언 NOT 연산을 수행한다. !는 피연산자가 거짓이면 참으로, 피연산자가 참이면 거짓으로 평가한다. 예를 들면, 다음과 같다.\r\n\r\nif (( x == 0 && y == 0 ) || ! ( z == 0 )) {\r\n// x와 y는 둘 다 0이거나 z가 0이 아니다\r\n}\r\n\r\n3.4 null과 undefined\r\n\r\nnull은 보통 아무 값도 갖지 않음을 가리킬 때 사용되며, 특별한 값을 평가하는 키워드다. typeof 연산자를 null에 사용하면 문자열 \"object\"를 반환한다. 그 결과로 볼 때, null은 '객체가 없음'을 뜻하는 특수한 객체 값으로 생각할 수 있다. 하지만 실무에서 null은, 값이 null 하나뿐인 어떤 고유한 자료형에 속한 것으로 간주되며, 객체뿐 아니라 수나 문자열 \"값이 없음\"을 나타내는 데도 쓰인다. 대다수 프로그래밍 언어는 자바스크립트의 null과 동등한 값을 가지고 있으며, 보통 null이나 nil이라고 표기한다.\r\n\r\n자바스크립트에는 값이 없음을 나타내는 또 다른 값, undefined가 있다. undefined는 null보다도 심한 부재 상태를 나타낸다. undefined는 초기화되어 있지 않은 변수나, 존재하지 않는 객체 프로퍼티나 배열의 원소 값에 접근하려고 할 때 얻는 값이다. 또한 undefined는 반환값이 없는 함수의 반환값이고, 실 인자가 전달되지 않는 형식인자의 값이다. undefined는 미리 선언된 전역 변수(null처럼 언어 차원의 키워드가 아닌)이며, 정의되지 않은 값(undefined value)으로 초기화된다. ECMAScript3 에서 undefined는 읽고 쓸 수 있는 변수이므로 다른 값으로 설정될 수 있었다. 이러한 문제점은 ECMAScrpit 5에서 수정되었고, undefined는 읽기 전용이 되었다.\r\n\r\ntypeof 연산자를 undefined 값에 사용한다면 \"undefined\"가 반환된다. 이는 undefined가 특별한 고유의 값임을 말한다. 이런 차이에도 불구하고 null과 undefined는 둘 다 값이 없음을 가리키고, 사용할 때 서로 바꿔 사용할 수도 있다. 동치 연산자 ==를 null과 undefined에 사용하면 두 값이 같다고 간주한다(null과 undefined)를 구별하기 위해서는 엄격한 동치 연산자 ===를 사용하라). null과 undefined는 둘 다 false로 판정되는 값이며 불리언 값 false로 변환된다. null과 undefined는 프로퍼티와 메서드를 가지고 있지 않기 때문에, 실제로 프로퍼티 혹은 메서드에 접근하기 위해 . 연산자나 [] 를 사용하면 TypeError가 발생한다.\r\n\r\n시스템 수준에서 예기치 않은 상황에 발생한, 오류성 값 부재를 표현할 때는 주로 undefined를 사용하고, 일반적인 프로그램 수준에서 일반적으로, 또는 예상 가능한 값 부재 상황을 표현하고 싶을 때는 null을 사용한다. 만약 이들 값 중 하나를 변수나 프로퍼티에 할당할 필요가 있거나 함수에 인자로 전달할 필요가 있다면, undefined보다는 null을 사용하는 게 적절하다.\r\n\r\n3.5 전역 객체\r\n\r\n지금까지 자바스크립트의 기본적인 데이터 타입과 값을 설명했다. 반드시 살펴봐야 할 중요한 객체가 있는데, 이는 전역 객체다. 전역 객체(global object)는 매우 중요한 용도로 사용되는 일반적인 자바스크립트 객체다. 전역 객체의 프로퍼티는 자바스크립트 프로그램 전역에서 사용할 수 있게 정의된 심벌이다. 자바스크립트 인터프리터가 시작할 때(혹은 웹브라우저가 새로운 페이지를 불러올 때), 새로운 전역 객체를 만들고 그 프로퍼티들을 초기화한다.\r\n\r\n    • undefined, Infinity, NaN 같은 전역 프로퍼티\r\n    • isNaN(), parseInt(), eval() 같은 전역 함수들\r\n    • Date(), RegExp(), String(), object(), Array() 같은 생성자 함수\r\n    • Math와 JSON 같은 전역 객체\r\n\r\n전역 객체가 생성될 때 초기화되는 프로퍼티들(undefined, Infinity, NaN 등)은 예약어가 아니지만 예약어처럼 취급된다. 이번 장에서도 몇 가지 전역 객체들을 살펴봤다. 이 외의 프로퍼티들은 이 책의 뒷부분에서 살펴보기 바란다. 필요에 따라 코어 자바스크립트 레퍼런스에서 해당 프로퍼티 이름으로 필요한 내용을 참고할 수 있다. 전역 객체는 레퍼런스에서 'Global' 부분을 살펴보면 되겠다. Window객체가 정의하는 클라이언트측 전역 프로퍼티들은 클라이언트 측 레퍼런스에서 찾아볼 수 있다.\r\n최상위 코드(함수의 일부가 아닌 코드)에서는 this 키워드를 통해 전역 객체를 참조할 수 있다.\r\n\r\nvar global = this; // 전역 객체를 참조하는 변수를 정의한다.\r\n\r\n클라이언트 측 자바스크립트에서 Window 객체는 브라우저 창에 포함된 모든 자바스크립트 코드를 위한 전역 객체다. 이 전역 Window 객체는 자기 자신을 참조하는 window 프로퍼티를 갖고 있는데, 전역 객체를 참조할 때 this 대신 사용할 수 있다. Window 객체는 핵심적인 전역 프로퍼티티들을 정의할 뿐만 아니라, 웹브라우저와 클라이언트 측 자바스크립트에서 사용되는 몇 가지 전역 객체들도 정의하고 있다.\r\n최초 전역 객체가 생성될 때, 그 안에는 자바스크립트에서 사용하는 모든 전역 값이 정의된다. 하지만 이 전역 객체는 프로그램별 전역 객체도 갖게 된다. 만약 여러분이 전역 변수를 선언한다면, 이 변수는 전역 객체의 프로퍼티가 되는 것이다.\r\n\r\n3.6 래퍼(wrapper) 객체\r\n\r\n자바스크립트 객체는 복합적인(composite) 값이다. 객체는 프로퍼티 또는 이름 있는 값들의 집합이며, .표기법을 사용하여 프로퍼티의 값을 참조한다. 프로퍼티의 값이 함수일 때, 그 함수를 메서드라 부른다. 객체 o의 메서드 m을 호출하려면 o.m() 이라고 적는다. 다음과 같이, 문자열에도 프로퍼티와 메서드가 있음을 살펴봤었다.\r\n\r\nvar s = \"hello world!\"; // 문자열\r\nvar word = s.substring(s.indexOf(\" \")+1, s.length); // 문자열 프로퍼티 사용\r\n\r\n왜 문자열은 객체도 아닌데 프로퍼티를 가지고 있을까? 여러분이 문자열 s의 프로퍼티를 참조하려고 할 때, 자바스크립트는 new String(s)를 호출한 것처럼 문자열 값을 객체로 변환한다. 이 객체는 문자열 메서드를 상속하며, 프로퍼티 참조를 살펴보는 데 사용된다. 일단 프로퍼티 참조가 해제되면 새로 생성된 임시 객체는 메모리에서 회수된다. (자바스크립트 인터프리터는 실제로는 임시 객체를 생성하고 삭제할 필요는 없으나, 그런 것처럼 동작하긴 해야 한다).\r\n\r\n숫자와 불리언은 문자열과 같은 이유로 메서드를 가지고 있다. 임시 객체는 Number() 혹은 Boolean() 생성자를 통해 만들어지고, 메서드는 임시 객체를 통해 호출된다. null과 undefined 값의 래퍼 객체는 없다. null과 undefined의 프로퍼티에 접근하려고 하면 TypeError가 발생한다. 다음 예제를 살펴보고, 실행되었을때 어떤 일이 발생할지 생각해보자.\r\n\r\nvar s = \"test\"; // 이 문자열을 사용한다.\r\ns.len = 4; // 문자열 프로퍼티에 값을 할당한다.\r\nvar t = s.len; // 프로퍼티를 참조하라.\r\n\r\n이 코드를 실행해 보면 t의 값은 undefined이다. 2행은 생성된 임시 String 객체 의 len 프로퍼티에 4를 할당한다. 그리고 임시 객체는 바로 삭제된다. 3행은 기존 문자열 값과 같은 값을 가진 새로운 String 객체를 생성하고 len 프로퍼티를 읽으려고 한다. 이 프로퍼티는 존재하지 않아서 undefined로 평가된다. 이 코드는 여러분이 문자열이나 숫자, 불리언 값에서 프로퍼티(혹은 메서드)의 값을 읽으려고 할 때, 문자열, 숫자, 불리언 값이 객체처럼 동작하는 것을 보여준다. 하지만 프로퍼티에 어떤 값을 할당한다면, 무시될 것이다. 값을 할당하는 것은 임시 객체에서 수행되며, 지속되지 않는다.\r\n\r\n문자열, 숫자, 불리언의 프로퍼티에 접근하려고 할 때 생성되는 임시 객체는 래퍼(wrapper) 객체로 알려져 있다. 때로, 문자열이나 수 또는 불리언 값과 String 또는 Number, Boolean 객체를 구별해야 할 일이 생길 수도 있을 것이다. 하지만 일반적으로 래퍼 객체는 자바스크립트 엔진에 따라 구현이 다를 수 있으므로, 여러분은 이에 대해 생각할 필요가 없다. 대신 문자열과 숫자, 불리언 값의 프로퍼티가 읽기 전용이고, 이 값들에 새로운 프로퍼티를 정의할 수 없다는 점에서 이 값들이 객체와 다르다는 사실을 알아야 한다.\r\n\r\nString() 과 Number(), Boolean() 생성자를 사용해 명시적으로 (하지만 거의 불필요하거나 유용하지 않은) 래퍼 객체를 생성할 수 있다는 사실도 명심하라.\r\n\r\nvar s = \"test\", n = 1, b = true; // 문자열, 숫자, 불리언 값\r\nvar S = new String(s); // String 객체  \r\nvar N = new Number(n); // Number 객체\r\nvar B = new Boolean(b); // Boolean 객체\r\n\r\n자바스크립트는 래퍼 객체를 필요에 따라 기본 타입으로 변환한다. 그래서 보통 앞선 코드의 객체 S, N, B는 항상 값 s, n, b처럼 작동한다. ==동치 연산자는 값과 그 값의 래퍼 객체를 동등하게 다룬다. 하지만 === 엄격한 동치 연산자로 이것들을 구별할 수 있다. typeof 연산자는 여러분에게 기본 타입과 래퍼 객체의 차이점을 보여줄 것이다.\r\n\r\n3.7 변경 불가능한 원시 타입 값과 변경 가능 객체 참조\r\n\r\n자바스크립트에서 원시 타입(undefined, null, 불리언, 숫자, 문자열) 값과 객체 ( 배열과 함수를 포함한) 사이에는 근본적인 차이점이 있다. 바로 원시 타입의 값은 수정할 수 없다는 점이다. 숫자와 불리언의 경우는 매우 명확하다. 수의 값을 바꾸면, 그것은 다른 수가 되기 때문이다. 하지만 문자열의 경우는 조금 다르다. 문자열은 문자들의 배열과 같기 떄문에, 특정 배열의 원소를 변경할 수 있다고 생각할지 모른다. 하지만 자바스크립트에서는 실제로 문자열의 각 문자를 변경 할 수 없다. 문자열을 수정하는 모든 문자열 메서드는 새로운 문자열을 반환한다. 예를 들면, 다음과 같다.\r\n\r\nvar s = \"hello\"; // \"hello\" 문자열을 사용한다.\r\ns.toUpperCase(); // \"HELLO\"을 반환한다, 하지만 s는 변경되지 않는다.\r\ns // => \"hello\"; 원래의 문자열은 바뀌지 않았다.\r\n\r\n원시 타입은 값으로 비교된다. 두 값은 같은 값이어야만 같다. 이는 숫자와 불리언 값, null, undefined에도 마찬가지다. 이들을 비교할 수 있는 다른 방법은 없다. 하지만 문자열은 원시 타입과 다르다. 서로 다른 문자열 값을 비교할 때, 자바스크립트는 두 문자열의 길이가 같고 각 인덱스에 있는 문자들이 같다면 두 문자열을 같다고 판단한다. 객체는 원시 타입과는 다르다. 먼저, 객체는 자신의 값을 변경할 수 있다(mutable)\r\n\r\nvar o = { x:1 }; // 객체를 선언한다.\r\no.x = 2; // 프로퍼티의 값을 변경함으로써 객체를 변경한다.\r\no.y = 3; // 다시 새로운 프로퍼티를 추가하는 것으로 객체를 변경한다.\r\nvar a = [1,2,3] // 배열은 타입이 고정되어 있지 않다.\r\na[0] = 0; // 하나의 배열 원소 값을 바꾼다.\r\na[3] = 4; // 새로운 하나의 배열 원소를 추가한다.\r\n\r\n객체는 값으로 비교되지 않는다. 다시 말해, 두 객체가 같은 프로퍼티와 값을 가지고 있어도 두 객체는 같지 않다. 그리고 두 배열은 같은 순서로 같은 원소를 갖고 있어도 같지 않다.\r\n\r\nvar o = { x : 1 }, p = { x :1 }; // 같은 프로퍼티를 가지고 있는 두 객체\r\no === p // => false: 같지 않은 다른 두 객체\r\nvar a = [ ], b = [ ]; // 두 개의 빈 배열 a와 b를 선언\r\na === b // => false: 두 배열 a와 b는 같지 않다.\r\n\r\n객체는 참조 타입(reference type)으로 불리는데, 이는 자바스크립트의 원시 타입과 구별하기 위해서다. 이 용어를 사용하자면, 객체의 값은 참조다. 다시 말해, 객체는 참조로 비교된다고 할 수 있다. 두 객체 값은 그들이 같은 객체를 참조한다면 같다.\r\n\r\nvar a = []; // 변수 a는 빈 배열을 참조한다.\r\nbar b = a; // 변수 b는 a와 같은 배열을 참조한다.\r\nb[0] = 1; // 변수 b가 참조하는 배열을 변경한다.\r\na[0] // => 1: 변수 a를 통해서도 바뀐 점을 볼 수 있다.\r\na === ㅠ // => true: 변수 a와 b는 한 객체를 참조하기 때문에 a와 b는 같\r\n다.\r\n\r\n방금 코드를 통해 살펴보았듯이, 객체를 변수에 할당하는 것은 단순히 참조를 할당하는 것이다. 이는 객체의 새로운 복사본을 생성하지 않는다. 객체 혹은 배열의 새로운 복사본을 만들고 싶다면 여러분은 명시적으로 객체의 프로퍼티 또는 배열의 원소를 복사해야 한다. 다음은 for 루프를 사용해 배열 a의 원소를 복사하는 예제다.\r\n\r\nvar a = ['a', 'b', 'c']; // 복사하고자 하는 배열\r\nvar b = []; // 복사해 넣을 배열\r\nfor ( var i = 0; i < a.length; i++ ) { // 배열 a의 각 인덱스\r\nb[i] = a[i]; // a의 원소를 b로 복사한다.\r\n}\r\n\r\n비슷하게, 두 다른 객체 또는 배열을 서로 비교하고 싶다면 그들의 프로퍼티 또는 원소를 비교해야 한다. 다음은 두 배열을 비교하는 함수를 정의한다.\r\n\r\nfunction equalArrays (a,b) {\r\nif (a.length != b.length) return false; // 크기가 다른 배열은 같지 않다.\r\nfor ( var i = 0; i < a.length; i++) // 모든 원소를 순회한다.\r\nif (a[i] !== b[i]) return false; // 일부 원소가 서로 다르다면,\r\n// 두 배열은 같지 않다.\r\nreturn true; // 서로 다른 원소가 없다면 두 배열은 같다.\r\n}\r\n\r\n3.8 타입 변환\r\n\r\n자바스크립트는 타입에 대해 매우 유연하다. 앞서 불리언에 대해 이야기 할 때 이런 점에 대해 살펴보았다. 자바스크립트가 불리언 값을 기대할 때, 여러분은 어떤 타입의 값이든 전달할 수 있고, 자바스크립트는 그 값을 필요에 따라 변환할 것이다. 어떤 값('참'으로 판정되는 값)은 true로 변환하고 다른 값('거짓'으로 판정되는 값)들은 false로 변환한다. 이는 다른 타입들도 마찬가지다. 자바스크립트가 문자열을 원한다면, 문자열이 올 자리에 어떤 값을 전달하더라도 문자열로 변환될 것이다. 자바스크립트가 숫자를 원한다면 숫자가 올 자리에 다른 어떤 값이 오더라도 숫자로 변환될 것이다(또는 의미 있는 변환을 할 수 없다면 NaN으로 변환될 것이다). 몇가지 예를 보자.\r\n\r\n10 + \" object\" // => \"10 object\". 숫자 10은 문자열로 변환된다.\r\n\"7\" \\* \"4\" // => 28: 두 문자열은 숫자로 변환된다.\r\nvar n = 1 - \"x\"; // => NaN: 문자열 \"x\"는 숫자로 변환할 수 없다.\r\nn + \" object\" // => \"NaN object\": NaN은 문자열 \"NaN\"으로 변환된다.\r\n\r\n표 3-2에서는 자바스크립트가 어떻게 값을 다른 타입으로 변환하는지 정리하였다. 굵게 표시된 부분은 여러분이 놀라워할 변환을 강조한다. 빈 부분은 변환이 필요 없고 어떤 변환도 수행되지 않음을 보여준다.\r\n표 3-2에 정리된 원시 타입 간의 변환은 상대적으로 간단하다. 불리언으로의 변환에 대해서는 이미 살펴봤다. 문자열로의 변환은 모든 원시 타입에 대해서 잘 정의되어 있다. 하지만 숫자로의 변환은 조금 까다롭다. 숫자로 파싱할 수 있는 문자열은 숫자로 변환한다. 앞뒤 공백은 허용되지만, 공백이나 숫자가 아닌 문자들이 앞뒤에 붙어 있으면 변환 결과는 NaN이 된다. 놀라워 보일만한 변환 결과들도 있다. true는 1로 변환되고 false와 빈 문자열 \"\"은 0으로 변환되는 것이다.\r\n\r\n원시 타입에서 객체로의 변환은 복잡하지 않다. 원시 타입은 String(), Number(), Boolean() 생성자를 호출함으로써 래퍼 객체로 변환할 수 있다.\r\n예외적으로 null과 undefined는 변환할 수 없다. 객체가 올 자리에 null 또는 undefined를 사용하면 변환 대신 TypeError 예외가 발생한다. 객체에서 원시 타입으로의 변환은 다소 복잡하다.\r\n\r\n                          자바스크립트 타입 변환\r\n\r\n3.8.1 변환과 동치\r\n\r\n자바스크립트는 값의 타입을 유연하게 변환시킬 수 있다. 따라서, 동치 연산자 ==도 유연하게 동작한다. 예를 들어, 다음의 동등 비교 예제들은 모두 true다.\r\n\r\nnull == undefined // 이 두 값은 같다고 판단된다.\r\n\"0\" == 0 // 비교하기 전에 숫자로 변환한다.\r\n0 == false // 불리언은 비교하기 전에 숫자로 변환한다.\r\n\"0\" == false // 두 피연산자는 비교하기 전에 숫자로 변환한다.\r\n\r\n서로 변환 가능한 값이라고 해서 동치인 것은 아니다. 예를 들어 undefined가 불리언 값이 올 자리에 사용되면 undefiend는 false로 변환된다. 하지만 이것이 undefined == false 임을 의미하지는 않는다. 자바스크립트에는 다양한 연산자와 구문이 있고, 각각의 타입 변환 방식은 서로 다를 수 있다. if문은 undefined를 false로 변환하지만, == 연산자는 피연산자를 불리언으로 변환하지 않는다.\r\n\r\n3.8.2 명시적 변환\r\n\r\n자바스크립트는 많은 형 변환을 자동으로 수행하지만, 명시적 변환이 필요할 때가 있다. 코드를 깔끔하게 유지하기 위해, 변환을 명시적으로 하는 것을 더 선호 할 수도 있을 것이다.\r\n명시적으로 타입 변환을 수행하는 가장 간단한 방법은 Boolean(), Number(), String(), Object() 함수를 사용하는 것이다. new 연산자 없이 호출되면, 이 함수들은 변환 함수로 작동하고 표 3-2에 요약된 변환을 수행한다.\r\n\r\nNumber(\"3\") // => 3\r\nString(false) // => \"false\" false.toString()도 마찬가지다.\r\nBoolean( [ ] ) // => true\r\nObject(3) // => new Number(3)\r\n\r\nnull과 undefined를 제외한 모든 값은 toString() 메서드를 가지고 있으며, 이 메서드의 결과는 보통 String() 함수가 반환하는 값과 같다. 표 3-2는 null과 undefined를 객체로 변환하려고 하면 TypeError가 발생한다고 명시하고 있다. 그러나 Object() 함수는 이런 경우에 예외를 발생시키지 않는다. 대신 새로 생성된 빈 객체를 반환한다.\r\n어떤 자바스크립트 연산자는 암시적(implicit) 타입 변환을 수행하므로 종종 타입 변환 목적으로 사용된다. + 연산자는 한 피연산자가 문자열이라면 다른 피연산자를 문자열로 변환한다. 단항 연산자는 +는 피연산자를 숫자로 변환한다. 단항 연산자 !는 피연산자를 불리언으로 변환한 다음 부정 (negate) 연산을 한다. 그래서 나온 것이, 아래의 타입 변환 숙어(idiom)들이다.\r\n\r\nx + \"\" // String(x)와 같다\r\n+x // Number(x)와 같다. 결과는 x-0이다.\r\n!!x // Boolean(x)과 같다. 두 개의 !를 주목하라\r\n\r\n자를 정형화하고 해석하는 것은 컴퓨터 프로그램에서 일반적인 작업이다. 이러한 작업을 위해서 자바스크립트는 숫자를 문자로 변환하거나 문자를 숫자로 변환할 때, 결과 값의 형태를 좀 더 자세히 표현할 수 있는 함수와 메서드를 지원하고 있다.\r\nNumber 클래스에 정의된 toString() 메서드는 기수(radix)를 정하는 선택적 인자를 받는다. 이 인자들을 전달하지 않는다면 기수를 10으로 하여 변환을 수행한다. 2에서 36까지의 값을 전달하면 해당 숫자를 기수로 하여 변환한다.\r\n\r\nvar n = 17;\r\nbinary_string = n.toString(2); // \"10001\"로 평가된다.\r\noctal_string = \"0\" + n.toString(8); // \"021\"로 평가된다.\r\nhex_string = \"0x\" + n.toString(16); // \"ox11\"로 평가된다.\r\n\r\n금융 또는 과학적인 데이터를 문자열로 변환하는 경우, 소수점 이하 자릿수를 제어하고 싶을 수도 있고, 지수 표기법(exponential notaion)을 사용하고 싶을 수도 있다. Number 클래스는 그런 용도에 맞는 세 가지 메서드를 제공한다. toFixed() 메서드는 결과 문자열의 소수점 이하 자릿수 개수를 인자와 똑같이 맞춘 문자열을 반환한다. toFixed() 메서드는 지수 표기법을 사용하지 않는다. toExponential() 메서드는 지수 표기법을 사용하여 소수점 앞에 숫자 하나와 소수점 뒤에 인자로 지정한 만큼의 자릿수를 놓는 방식으로 숫자를 문자열로 변환한다(유효 자릿수의 숫자가 지정한 값보다 1 크다는 의미다).\r\n\r\ntoPrecision() 메서드는 여러분이 정의한 유효 자릿수로 숫자를 문자열로 변환한다. toPrecision()은 유효 자릿수가 숫자의 전체 정수 부분을 표시할 정도로 크지 않다면 지수 표기법을 사용한다. 이 세 가지 메서드 모두, 결과 문자열 내에서 나머지 숫자들을 적절히 반올림하거나, 필요할 경우 0을 붙인다는 점에 유의하라. 예를 들면, 다음과 같다.\r\n\r\nvar n = 123456.789\r\nn.toFixed(0); // \"123457\"\r\nn.toFixed(2); // \"123456.79\"\r\nn.toFixed(5); // \"123456.78900\"\r\nn.toExponential(1); // \"1.2e+5\"\r\nn.toExponential(3); // \"1.235e+5\"\r\nn.toPrecision(4); // \"1.235e+5\"\r\nn.toPrecision(7); // \"123456.8\"\r\nn.toPrecision(10); // \"123456.7890\"\r\n\r\n여러분이 문자열을 Number() 변환 함수로 넘긴다면, 변환 함수는 문자열을 정수 혹은 실수 리터럴로 해석할 것이다. Number() 함수는 10진수 정수만 처리할 수 있고 그 뒤에 숫자 아닌 문자가 오는 것을 허용하지 않는다. 한편 parseInt()와 parseFloat() 함수는 리터럴의 일부가 숫자가 아니어도 된다는 점에서 Number()보다 좀 더 유연하게 동작한다. 참고로 이 두 함수들은 Number 클래스의 메서드가 아닌 전역 함수다. parseInt()는 정수만 변환할 수 있지만 parseFloat()는 정수와 부동소수점 모두 변환할 수 있다. 만약 문자열이 '0x'나 'OX'로 시작하면 parseInt() 는 문자열을 16진수 숫자로 인식한다.\r\n\r\nparseInt()와 parseFloat() 모두 앞부분 빈 공백을 무시하고 숫자 다음에 나오는 숫자 아닌 문자들도 무시한다. 첫 번째 공백이 아닌 문자가 유효한 숫자 리터럴이 아니라면 NaN을 반환한다.\r\n\r\nparseInt(\"3 blind mice\") // => 3\r\nparseFloat(\" 3.14 meters\") // => 3.14\r\nparseInt(\"-12.34\") // => -12\r\nparseInt(\"0xFF\") // => 255\r\nparseInt(\"-0XFF\") // => -255\r\nparseFloat(\".1\") // => 0.1\r\nparseInt(\"0.1\") // => 0\r\nparseInt(\".1\") // => NaN: 정수는 \".\"로 시작할 수 없다\r\nparseFloat(\"$72.47\");                              // => NaN: 숫자는 \"$\"로 시작할 수 없다\r\n\r\nparseInt()는 해석될 숫자의 기수(밑)를 정의하는 선택적인 두 번째 인자를 받는다. 숫자는 2와 36 사이에서 유효하다. 예를 들면 아래와 같다.\r\n\r\nparseInt(\"11\", 2); // => 3 (1*2 + 1)\r\nparseInt(\"ff\", 16); // => 255 (15*16 + 15)\r\nparseInt(\"zz\", 36); // => 1295 (35*36 + 35)\r\nparseInt(\"077\", 8); // => 63 (7*8 + 7)\r\nparseInt(\"077\", 10); // => 77 (7\\*10 + 7)\r\n\r\n3.8.3 객체에서 원시 타입으로 변환\r\n\r\n객체에서 불리언으로의 변환은 간단하다. 모든 객체(배열과 함수를 포함한)는 true로 변환된다. 이는 래퍼 객체도 마찬가지다. new Boolean(false)는 원시 타입이 아니라 객체이므로 true로 변환된다.\r\n객체에서 문자열로 그리고 객체에서 숫자로의 변환은 변환될 객체의 메서드를 호출함으로써 수행된다. 이 과정은 자바스크립트 객체가 변환을 수행하는 두개의 서로 다른 메서드를 가지고 있기 떄문에 다소 복잡하다. 그리고 다음과 같은 특별한 경우가 있어서 다소 복잡하다.\r\n\r\n이번 절에서 설명한 문자열과 숫자로의 전환 규칙은 오직 네이티브 객체에만 적용 가능하다. 호스트 객체(예를 들어 웹브라우저에서 정의한)는 자체 알고리즘에 따라서 숫자와 문자열로 변환이 가능하다.\r\n모든 객체는 두 개의 타입 변환 메서드를 상속한다. 첫 번째 메서드는 toString() 인데, 이 메서드는 객체를 문자열로 표현하여 반환한다. 이 기본 toString() 메서드가 반환하는 문자열에는 별로 흥미로운 구석이 없다.\r\n\r\n( { x:1, y:2}).toString() // => \"[object Object]\"\r\n\r\n많은 클래스들이 toString() 메서드를 재정의한다. 예를 들어, Array 클래스에 정의된 toString() 메서드는 각 배열 원소를 문자열로 변환하고, 배열 원소 사이에 쉼표를 삽입하여 이어붙인 문자열을 결과로 반환한다. Function 클래스에 정의된 toString() 메서드는 자바스크립트 구현체가 정의하는 함수의 내부 표현형(representation)을 반환한다. 실제로, 많은 자바스크립트 구현체에서 보통 사용자 정의 함수를 자바스크립트 소스 코드 형태의 문자열로 변환한다. Date 클래스에 정의된 toString() 메서드는 사람이 읽을 수 있는(그리고 자바스크립트가 파싱할 수 있는) 날짜와 시간 문자열을 반환한다. RegExp 클래스에 정의된 toString() 메서드는 RegExp 객체를 RegExp 리터럴처럼 보이는 문자열로 변환한다.\r\n\r\n[1,2,3].toString() // => \"1,2,3\"\r\n(funtion(x) { f(x); }).toString() // => \"function(x) {\\n f(x); \\n}\"\r\n/\\d+/g.toString() // => \"/\\\\d+/g\"\r\nnew Date(2010, 0,1).toString() // => \"Fri jan 01 2010 00:00:00 GMT=0800 (PST)\"\r\n\r\n다른 변환 함수로는 valueOf()가 있다. 이 메서드가 하는 일은 잘 정의되어 있지 않다. 원래 이 함수는 객체를 잘 표현하는 원시 타입 값을 반환해야 한다. 그런데 객체는 결합된 값(compound value)이고 대부분의 객체는 하나의 원시 타입 값으로 표현할 수 없기 때문에, 기본적으로 valueOf() 메서드는 원시 타입을 반환하지 않고 단순히 객체 그 자신을 반환한다. 래퍼 클래스는 래핑된 원시 타입의 값을 반환하는 valueOf() 메서드를 정의 한다. 배열, 함수, 정규 표현식은 단순히 기본 메서드를 상속한다. 이와 같은 타입의 객체에서 valueOf()를 호출하면 단순히 객체 그 자체를 반환한다. Date 클래스의 valueOf() 메서드는 객체 내부적으로 날짜를 표현하기 위해 쓰는 값(즉, 현재 시각과 1970년 1월 1일의 차를 밀리초로 표현한 값)을 반환한다.\r\n\r\nvar d = new Date(2010, 0, 1); // 2010년 1월 1일, (태평양 시간)\r\nd.valueOf() // => 1262332800000\r\n\r\n지금껏 설명한 toString()과 valueOf() 메서드를 사용하여 우리는 객체에서 문자열로 그리고 객체에서 숫자로의 변환을 할 수 있다. 하지만, 자바스크립트가 객체에서 원시 타입으로의 변환을 좀 특수하게 처리하는 경우도 있다. 이에 대해서는 이번 절 마지막에서 알아본다.\r\n자바스크립트는 아래의 절차를 거쳐 객체를 문자열로 변환한다.\r\n\r\n    • 객체가 toString() 메서드를 가지고 있다면, 자바스크립트는 이 메서드를 호출한다. toString()이 원시 타입 값을 반환한다면, 자바스크립트는 이 값을 문자열로 변환하여 (이미 문자열이 아니라면) 반환한다. 원시 타입에서 문자열로의 전환 방법은 표 3-2를 참고하기 바란다.\r\n    • 객체가 toString() 메서드를 가지고 있지 않거나 이 메서드가 원시 타입 값을 ㅏㄴ환하지 않는다면 자바스크립트는 valueOf() 메서드를 찾는다. valueOf() 메서드가 존재한다면 자바스크립트는 이 메서드를 호출한다. 만약에 반환값이 원시 타입이라면 자바스크립트는 이 값을 문자열(이미 문자열이 아니라면)로 변환하여 반환한다.\r\n    • 그렇지 않다면 자바스크립트는 toString() 또는 valueOf()로 부터 원시 타입 값을 얻을 수 없기 때문에 TypeError를 발생시킬 것이다.\r\n\r\n객체를 숫자로 전환할 때는 문자열과 같은 방식으로 전환하지만, valueOf() 메서드를 먼저 호출한다.\r\n\r\n    • 객체가 원시 타입의 값을 반환하는 valueOf() 메서드를 가지고 있다면, 자바스크립트는 반환된 가ㅅ을 (필요하다면) 숫자로 변환하여 반환한다.\r\n    • 그렇지 않고, 객체가 원시 타입 값 반환하는 toString() 메서드를 가지고 있다면 자바스크립트는 이 값을 변환하여 반환한다.\r\n    • 이 외의 경우, 자바스크립트는 TypeError를 발생시킨다.\r\n\r\n객체에서 숫자로의 변환에 대한 앞의 설명을 보면, 왜 빈 배열이 숫자 0으로 변환되는지, 왜 한 개의 원소를 가진 배열이 숫자로 변환되는지를 이핼할 수 있다. 배열은 기본적으로 원시 타입 값 대신 객체를 반환하는 valueOf() 메서드를 상속하기 때문에, 배열에서 숫자로의 변환은 toString() 메서드에 의존한다. 빈 배열은 빈 문자열로 변환된다. 그리고 다시 빈 문자열은 숫자 0으로 변환된다. 한개의 원소를 가진 배열은 해당 원소와 같은 문자열로 변환한다. 만약 배열이 한개의 숫자만 가지고 있다면 이 숫자는 문자열로 변환되고, 그 다음에숫자로 다시 변환된다.\r\n\r\n자바스크립트에서 + 연산자는 숫자 덧셈과 문자열 붙이기를 수행한다. + 연산자의 피연산자 중 하나가 객체라면, 자바스크립트는 객체를 다른 산술 연산처럼 객체에서 숫자로 변환하는 대신 객체에서 원시 타입으로 변환한다. == 동치 연산자도 비슷하다. 객체를 원시 타입 값과 비교할 때는, 객체를 원시 타입으로 변환한다.\r\n\r\n+와 == 연산자는 객체를 원시 타입으로 변환할 때 Date 타입 객체는 특별하게 취급한다. Date 클래스는 코어 자바스크립트에 포함되어 있는 타입 가운데, 문자열로의 변환 절차와 수로의 변환 절차를 전부 구현하고 있는 유일한 타입이다. 기본적으로 객체에서 원시 타입으로의 변환은 객체에서 숫자로의 변환이고, 이때 valueOf() 를 먼저 사용한다. Date 객체에 한해서만 객체에서 문자열로 변환하며, 이때 toString()을 먼저 사용한다. 그런데 이러한 변환 과정은 앞서 설명한 것과는 미묘하게 다르다. valueOf()나 toString() 에서 반환된 원시 값은 숫자나 문자열로 변환되지 않고 바로 사용되는 것이다.\r\n\r\n< 연산자와 다른 관계 연산자들은 == 연산자가 그랬듯이 객체에서 원시 타입으로의 변환을 수행한다. 하지만 Date 객체를 특별하게 취급하진 않는다. valueof()를 먼저 시도하고, 그 뒤에야 toString()을 시도한다. 그 결과 값은 숫자나 문자열로 추가 변환 없이 바로 사용된다.\r\n\r\n+, ==, != 그리고 관계 연산자들만이 오직 이런 특별한 종류의 문자열-원사 타입 변환을 수행한다. 다른 연산자들은 지정된 타입으로 좀 더 명시적으로 변환하고, Date를 위한 특ㅕ한 처리 절차를 가지고 있지도 않다. 예를 들어 - 연산자는 피연산자를 숫자로 변환한다. 다음 코드는 =, -, ==, > 연산자와 Date 객체와의 상호작용을 보여준다.\r\n\r\nvar now = new Date(); // Date 객체 생성\r\ntypeof ( now + 1) // => \"string\": +는 날짜를 문자열로 변환시킨다.\r\ntypeof ( now = 1) // => \"number\": -는 객체에서 숫자로 변환시킨다.\r\nnow == now.toString() // => true: 암시적 그리고 명확한 문자열 변환.\r\nnow > ( now -1) // => true: > Date에서 숫자로 변환하라.\r\n\r\n3.9 변수 선언\r\n\r\n자바스크립트에서는 변수를 사용하기 전에 변수 선언(declaration)을 해야 한다. 변수는 다음과 같이 var 키워드를 이용하여 선언한다.\r\n\r\nvar i;\r\nvar sum;\r\n\r\nvar 키워드를 이용하여 여러 개의 변수를 선언할 수도 있다.\r\n\r\nvar i, sum;\r\n\r\n그리고 변수 선언과 동시에 초기화를 할 수도 있다.\r\n\r\nvar message = \"hello\";\r\nvar i = 0, j = 0, k = 0;\r\n\r\nvar 문에서 변수에 초기 값을 지정하지 않는다면, 변수는 값이 설정될 때까지 undefined 값을 갖게 된다.\r\nvar 문은 for와 for/in 루프 안에 올 수도 있다. 이를 통해 루프 문법 안에서 루프 변수(loop variable)를 간결하게 정의할 수 있다.\r\n\r\nfor(var i = 0; i < 10; i++) console.log(i);\r\nfor(var i = 0, j = 10; i < 10; i++, j-- \\_ console.log(i\\*j);\r\nfor(var p in o ) console.log(p);\r\n\r\nC나 자바 같은 정적 타입의 언어를 다룬 적이 있다면, 자바스크립트 변수 선언에는 타입을 명시하지 않음을 알 수 있을 것이다. 예를 들어, 자바스크립트에서는 변수에 숫자를 할당했다가 나중에 문자열을 할당해도 문법적으로 문제가 없다.\r\n\r\nvar i = 10;\r\ni = \"ten\";\r\n\r\n3.9.1 반복된 선언과 생략된 선언\r\n\r\nvar 문장에서는 변수를 하나 이상 선언할 수 있다. 반복된 변수 선언에 초기값이 부여된 경우, 선언문은 마치 대입문 처럼 동작한다.\r\n선언하지 않은 변수를 읽으려 하면 자바스크립트는 에러를 발생 시킨다. ECMAScript 5 엄격 모드에서는 선언하지 않은 변수에 값을 넣으려해도 에러가 발생한다. 하지만 역사적으로 비-엄격 모드(non-strict mode)에서는 선언하지 않은 변수에 값을 배정하면, 그 변수는 전역 객체의 속성으로 생성되어, 마치 미리 선언했던 전역 변수처럼 동작하게 된다(하지만 완전히 같지는 않다.) 이는 전역 변수를 선언하지 않은 채 사용할 수 있다는 의미다. 하지만 이것은 나쁜 슨괍이며 버그의 근원이므로, 항상 변수는 var로 선언하도록 해야 한다.\r\n\r\n3.10 변수의 유효범위\r\n\r\n변수의 유효범위란 프로그램에서 어떤 변수가 정의되어 있는 영역을 말한다. 전역 변수의 유효범위는 전역적이다. 전역 변수(global variable)는 자바스크립트 코드 전체에 걸쳐 정의되어 있다. 반면, 어떤 함수 안에서 선언된 변수는 오직 해당 함수 몸체 안에서만 정의된다. 이런 변수는 지역 변수(local variable)라 불리며,유효범위도 지역적이다. 함수의 매개변수 역시 지역 변수이며 오직 해당 함수 내부에서만 정의된다.\r\n\r\n같은 이름을 갖는 경우, 함수 내부에서 지역 변수는 전역 변수에 우선한다. 지역 변수 혹은 함수 매개변수를 전역 변수와 같은 이름으로 선언하면, 전역 변수를 감춰버리게 된다.\r\n\r\nvar scope = \"global\"; // 전역 변수를 선언한다.\r\nfunction checkscope() {\r\nvar scope = \"local\"; // 전역변수와 같은 이름으로 지역 변수를 선언한다.\r\nreturn scope; // 전역 변수가 아닌 지역 변수를 반환한다.\r\n}\r\ncheckscope() // => \"local\"\r\n\r\n전역 유효범위에서는 var문을 사용하지 않고 전역 변수를 선언할 수 있지만, 지역 변수를 선언하기 위해서는 반드시 var를 사용해야 한다. 그렇게 하지 않을 때 어떤 일이 발생하는지 다음 예제를 통해 살펴보자.\r\n\r\nscope = \"global\"; // var 없이 전역 변수를 선언한다.\r\n\r\nfunction checkscope2() {\r\nscope = \"local\"; // 이런! 전역 변수를 바꿔버렸네!\r\nmyscope = \"local\"; // 암묵적으로 전역 변수를 선언한다.\r\nreturn [scope, myscope]; // 두 변수의 값을 반환한다.\r\n}\r\ncheckscope2() // => [\"local\", \"local\"] : 부작용 발견!\r\nscope // => \"local\": 전역 변수가 바뀌었다.\r\nmyscope // => \"local\": 전역 네임스페이스가 지역 변수로 오염되었다.\r\n\r\n함수 정의는 중첩될 수 있다. 각 함수에는 자신만의 유효범위가 있다. 따라서 지역 유효범위도 여러 단계로 중첩될 수 있다. 다음 코드를 살펴보자.\r\n\r\nvar scope = \"global scope\"; // 전역 변수\r\n\r\nfunction checkscope() {\r\nvar scope = \"local scope\"; // 지역 변수\r\nfunction nested() {  \r\n var scope = \"nested scope\"; // 함수 안에 포함된 유효범위의 지역 변수\r\nreturn scope; // nested() 안의 변수를 반환한다.\r\n}\r\nreturn nested();\r\n}\r\ncheckscope() // => \"nested scope\"\r\n\r\n3.10.1 함수 유효범위와 끌어올림(hoisting)\r\n\r\nC같은 프로그래밍 언어에서 블록 안에 있는 코드는 자신만의 유효범위를 가지며, 변수는 해당 변수가 선언되지 않은 블록 밖에서는 보이지 않는다. 이를 블록 유효범위(block scope)라 부르는데, 자바스크립트에는 블록 유효범위의 개념이 없다. 대신에, 자바스크립트는 함수 유효범위를 사용한다. 변수는 해당 변수가 정의된 함수 안에서 보일 뿐 아니라, 그 함수 안에 중첩된 함수 안에서도 보인다.\r\n다음 코드에서 변수 i, j, k는 다른 위치에 선언되지만 모두 같은 유효범위를 갖는다. 다시 말해, 세 변수는 모두 함수의 몸체 안에 정의되어 있다.\r\n\r\nfunction test(0) {\r\nvar i = 0; // i는 함수 전체에 걸쳐 정의된다.\r\nif (typeof o == \"object\") {\r\nvar j = 0; // j는 블록뿐만 아니라  \r\n // 함수 전체에 걸쳐 정의된다.\r\n\r\n         for(var k = 0; k < 10; k++ ) {            // k는 반복문 외에도 함수 전체에 걸쳐 정의된다.\r\n               console.log(k);                         // 숫자 0부터 9까지 출력한다.\r\n          }\r\n          console.log(k);                              // k는 여전히 정의되어 있다.\r\n                                                          // 10을 출력한다.\r\n      }\r\n      console.log(j);                                  // j는 정의되어 있고,\r\n                                                          // 초기화되어 있지 않을 것이다.\r\n\r\n}\r\n\r\n자바스크립트의 함수 유효범위(function scope)는, 어떤 함수 안에서 선언된 모든 변수는 그 함수 전체에 걸쳐 유효하다는 의미다. 흥미롭게도, 이는 변수가 미처 선언되기 전에도 유효하다는 뜻이기도 하다. 이런 자바스크립트의 특징은 비공식적으로 끌어올림(hoisting)이라고 알려져 있다. 자바스크립트 코드는 함수안에 있는 모든 변수를 함수 맨 꼭대기로 '끌어올린' 것처럼(하지만 배정문까지 끌어올리지는 않는다) 동작한다. 다음 예제를 통해 살펴보자.\r\n\r\nvar scope = \"global\";\r\nfunction f() {\r\nconsole.log(scope); // \"global\"이 아니라 \"undefined\"를 출력한다.\r\nvar scope = \"local\"; // 여기서 초기화하지만, 정의는 다른 곳에서 이루어졌다.\r\nconsole.log(scope); // \"local\"을 출력한다.\r\n}\r\n\r\n지역 변수를 선언하는 var문이 아직 실행되지 않았기 떄문에 여러분은 이 함수의 1행이 \"global\"을 출력할 거라고 착각할 수 있다. 하지만, 함수 유효범위 규칙 때문에 실제로는 그렇지 않다. 지역 변수는 함수 전체에 걸쳐서 정의된다. 즉, 같은 이름의 전역 변수는 함수 전체에서 이 지역 변수에 의해 감춰진다. 지역 변수가 함수 전체에 걸쳐 정의되었더라도 var문이 실행되고 나서야 실제로 초기화된다. 따라서 이 함수는 다음 코드와 같다. 그리고 변수 선언은 함수 맨 꼭대기로 '끌어올려(hoisted)'지고, 초기화는 원래대로 세 번째 줄 대입문이 처리하게 된다.\r\n\r\nfunction f() {\r\nvar scope; // 지역 변수는 함수 맨 꼭대기에서 선언한다.\r\nconsole.log(scope); // scope 변수는 존재하지만 아직 \"undefined\" 값이다.\r\nscope = \"local\"; // 이제 scope 변수가 초기화되고 제대로 된 값이 있다.\r\nconsole.log(scope); // 여기서는 우리가 기대한 값이 들어 있다.\r\n}\r\n\r\n블록 유효범위를 가진 프로그래밍 언어에서 일반적으로 변수를 선언하는 좋은 프로그래밍 방법은, 가능한 한 그 변수가 사용되는 가장 가까운 곳에서 선언하는 것이다. 하지만 자바스크립트는 블록 유효범위를 가지고 있지 않기 때문에 어떤 개발자는 모든 변수를 변수가 사용되는 위치와 가까운 곳에 선언하지 않고 함수의 맨 꼭대기에 선언할지도 모른다. 그렇게 하면 변수의 진정한 유효범위가 소스 코드에 정확하게 반영될 것이다.\r\n\r\n3.10.2 프로퍼티로서의 변수\r\n\r\n전역 자바스크립트 변수를 선언한다는 것은, 실제로는 전역 객체의 프로퍼티를 정의하는 것이다. 변수를 선언하려고 var를 사용하면, 생성된 프로퍼티는 수정 가능하지 않고(unconfigurable) 이것은 delete 연산자로 소멸시킬 수 없다는 뜻이다. 앞서 엄격 모드가 아닌 상황에서 선언하지 않은 변수에 값을 대입하려고 하면 자바스크립트는 자동으로 전역 변수를 생성한다고 얘기했었다. 이런 식으로 생성된 변수는 전역 객체의 평범하고 수정 가능한 (configurable) 프로퍼티이며 삭제할 수도 있다.\r\n\r\nvar truevar = 1; // 올바르게 선언한 전역 변수, 삭제할 수 없다.\r\nfakevar = 2; // 삭제 가능한 전역 변수\r\nthis.fakevar2 = 3; // 삭제 가능한 전역 변수\r\ndelete truevar // => false: 변수는 삭제할 수 없다.\r\ndelete fakevar // => true: 변수는 삭제된다.\r\ndelete this.fakevar2 // => true: 변수는 삭제된다.\r\n\r\n자바스크립트 전역 변수는 전역 객체의 프로퍼티로, 이는 ECMAScript 명세에 규정되어 있다. 지역 변수에는 그런 규정이 없지만, 변수를 각 함수 호출과 연관된 객체의 프로퍼티로 생각해도 된다. ECMAScript 3 명세는 이러한 객체를 '호출 객체(call object)'라고 하고, ECMAScript 5 명세는 이를 '선언적 환경 기록(declarative environment record)'이라 부른다. 자바스크립트는 this 키워드로 전역 객체를 참조할 수 있도록 한다. 하지만 지역 변수가 저장된 객체를 참조할 방법은 제공하지 않는다. 지역 변수를 들고 있는 이런 객체들의 속성은 구현 세부사항에 해당하는 것이라서 우리가 신경 쓸 필요가 없다. 하지만 지역 변수 객체가 존재한다는 개념은 중요하고, 다음 절에서 좀 더 자세히 설명한다.\r\n\r\n3.10.3 유효범위 체인\r\n\r\n자바스크립트는 언어적으로 유효범위를 가지고 있는 (lexically scoped) 언어다. 변수의 유효범위란 정의된 변수를 사용 가능한 소스 코드의 집합으로 생각할 수 있다. 전역 변수는 프로그램 전체에 걸쳐 유효하다. 지역 변수는 변수가 선언된 함수 전체에 걸쳐 유효하고, 그 안에 중첩된 함수 내에서도 유효하다.\r\n우리가 지역 변수를 (구현 세부사항에 속하는 어떤) 객체의 프로퍼티로 생각한다면, 변수 유효범위를 다른 관점으로 볼 수도 있다. 자바스크립트의 모든 코드 무더기는 (전역 코드이건 함수이건) 그것과 연관된 유효범위 체인(scope chain)을 가지고 있다. 이 유효범위 체인은 해당 코드 무더기의 '범위 안(in scope)'에 있는 변수를 정의하는 객체의 체인, 다시 말해 리스트다. 자바스크립트가 변수 x의 값을 얻어야 할 때 (변수 해석(variable resolution 이라 일컫는 과정) 처음 체인에 있는 객체에서 x를 찾기 시작한다. 만약 이 객체가 이름이 x인 프로퍼티를 가지고 있다면, 그대로 사용한다. 만약 첫 번째 객체가 x 프로퍼티를 가지고 있지 않다면 자바스크립트는 체인에 있는 다음 객체에서 x 프로퍼티를 찾는다. 두 번째 객체가 x 프로퍼티를 가지고 있지 않다면 또 다음 객체에서 찾는다. x가 유효범위 체인 안에 있는 객체의 프로퍼티가 아니라면 x 는 유효범위 안에 없기 때문에 ReferenceError가 발생한다.\r\n\r\n최상위 자바스크립트 코드의 경우(어떤 함수에도 속하지 않는 코드), 유효범위 체인은 단 하나의 '전역 객체'만으로 이루어진다. 중첩되지 않은 함수의 유효 범위 체인은 두 개의 객체로 이루어진다. 하나는 함수 매개변수와 지역 변수를 정의하는 객체고, 다른 하나는 전역 객체다. 중첩된 함수에서 유효범위 체인은 세 개 이상의 객체를 갖는다. 객체의 유효범위 체인이 어떻게 생성되는지는 반드시 이해해야 한다. 함수가 정의될 때, 함수는 유효범위 체인을 저장한다. 함수가 호출될 때, 해당 함수의 지역 변수를 저장하기 위해서 새로운 객체를 하나 생성하고, 해당 객체를 기존에 저장된 유효범위 체인에 추가한다. 중첩 함수의 경우에는 외부에서 함수를 호출할 때마다 유효범위 체인이 조금씩 달라진다. 물론 중첩된 함수의 코드는 항상 동일하지만, 그 코드에 관계된 유효범위 체인은 함수를 호출할 때마다 달라지게 된다.\r\n이 유효범위 체인의 개념은 with문(5.7.1 참고)을 이해하는 데 도움이 되고, 클로저(8.6절 참고)를 이해하는 데도 굉장히 중요하다.\r\n","excerpt":"프로그래밍 언어로 다룰 수 있는 값의 유형을 데이터 타입이라고 한다. 프로그래밍 언어의 가장 기본적인 특징 중 하나는 바로 그 언어가 지원하는 데이터 타입의 종류다. 한편, 프로그램은 값이 유지될 필요가 있을 때, 변수에 값을 할당(저장)한다. 변수…","fields":{"slug":"/javascript-study_2/"},"frontmatter":{"date":"Oct 21, 2021","title":"javascript 타입 값 변수","tags":["javascript"],"update":"Oct 21, 2021"}}},{"node":{"rawMarkdownBody":"\r\n자바스크립트 프로그램은 unicode 문자 집합을 사용해 작성된다. unicode는 ASCII나 Latin-1의 상위 집합이고 지구상에서 사용되는 대부분의 문자를 표현할 수 있다.\r\n\r\n자바스크립트는 대소문자를 구분하는 언어다. 다시 말해 키워드, 변수, 함수 이름, 식별자들은 모두 항상 대소문자를 구분해 입력해야 한다. 그러나 HTML은 대소문자를 구별하지 않는다. HTML이 클라이언트 측 자바스크립트와 밀접한 연관이 있기 떄문에 이 점이 약한 혼동될 수 있다. 많은 클라이언트 측 자바스크립트 객체와 프로퍼티 이름은 HTML 태그나 태그 속성(attribute)의 이름과 동일하다. 그런데 HTML에서는 태그나 속성 이름을 대소문자 구분 없이 입력해도 되지만, 자바스크립트에서는 모두 소문자로 입력해야 한다.\r\n\r\n2.1.2 공백, 줄바꿈, 제어 문자\r\n자바스크립트는 프로그램 코드 내의 토큰(토큰이란 프로그래밍 언어에서 더 이상 나눌수 없는 최소한의 단위이며, 키워드나 변수의 이름, 숫자 등이 여기에 해당한다.) 들 사이에 있는 공백들을 무시한다.\r\n\r\n2.2 주석\r\n\r\n자바스크ㅂ트는 두 가지 형태의 주석을 지원한다. //와 줄 끝 사이에 있는 텍스트는 모두 주석으로 취급되어 자바스크립트에 의해 무시된다. /_와 _/ 사이의 텍스트도 모두 주석으로 취급된다. 이때, 주석은 여러 줄에 걸쳐 나타날수 있지만 서로 중첩될 수 없다. 다음의 코드는 모두 올바른 자바스크립트 주석이다.\r\n\r\n// 한 줄짜리 주석\r\n/_ 이것도 주석 _/ // 또 다른 주석/\\*\r\n\r\n- 또 다른 주석\r\n- 여러 줄에 걸쳐 있다. \\*/\r\n\r\n2.3 리터럴\r\n\r\n리터럴(literal)은 프로그램에 직접 나타나는 데이터 값이다. 다음의 코드는 모두 리터럴이다.\r\n12 // 숫자 12\r\n1.2 // 숫자 1.2\r\n\"hello world\" // 문자열\r\n'Hi' // 다른 문자열\r\ntrue // 불리언 값\r\nfalse // 다른 불리언 값\r\n/javascript/hi // '정규 표현식' 리터럴(패턴 매칭용)\r\nnull // 객체가 존재하지 않음\r\n\r\n배열이나 객체 리터럴을 위한 좀 더 복잡한 표션식도 지원한다. 예를 들어, 다음과 같다.\r\n{ x:1, y:2 } // 객체 초기자\r\n[1,2,3,4,5] // 배열 초기자\r\n\r\n2.4 식별자와 예약어\r\n\r\n식별자(identifier)는 간단히 말해 이름이다. 자바스크립트에서 식별자는 변수나 함수에 이름을 붙이거나 코드 내 반복문에서 쓸 레이블을 붙이는 데 사용된다. 자바스크립트 식별자의 시작은 알파벳, 밑줄(\\_) 혹은 달러(\\$) 표시여야 한다. 이어지는 문자들은 알파벳이나 숫자, 밑줄 혹은 달러 표시여야 한다(식별자의 첫 글자로 숫자를 허용하지 않는 이유는 자바스크립트가 숫자와 식별자를 쉽게 구별하기 위함이다). 다음은 모두 올바른 식별자다.\r\n\r\ni\r\nmy_variable_name\r\nv13\r\n\\_dummy\r\n\\$str\r\n\r\n다른 언어와 마찬가지로, 자바스크립트에도 언어 내부적으로 사용할 용도로 예약된 식별자들이 있다. 이러한 '예약어(reserved keyword)'는 식별자(변수명, 함수명, 레이블)로 사용할 수 없다.\r\n\r\n2.4.1 예약어\r\n\r\n자바스크립트는 몇 가지 식별자를 미리 선점하고 있다. 다음은 프로그램 내에서 식별자로 사용할 수 없는 단어들이다.\r\n\r\nbreak delete function return typeof\r\ncase do if switch var\r\ncatct else in this void\r\ncontinue false instanceof throw while\r\ndebugger finally new true with\r\ndefault for null try\r\nclass const enum export extends import super\r\n\r\n또한, 보통 자바스크립트 코드에서는 식별자로 사용할 수 있지만, 엄격모드 (strict mode)에서는 사용할 수 없는 단어도 있다.\r\n\r\nimplements let priviate public yield interface package protected static\r\n\r\n엄격모드에서는 아래의 식별자도 사용이 제한된다. 이 식별자들은 완전히 예약어는 아니지만 변수나 함수 혹은 매개변수 이름으로 사용할 수 없다.\r\n\r\narguments eval\r\n\r\n자바스크립트는 다음과 같이 몇 가지 전역 변수와 함수를 정의하고 있다. 이 단어들은 프로그램 내에서 변수나 함수 이름으로 사용해서는 안 된다.\r\n\r\narguments encodeURI infinity number regexp\r\nArray encodeURIComponent isFinite Object String\r\nBoolean Error isNaN parseFloat SyntaxError\r\nDate eval JSON parseInt TypeError\r\ndecodeURI EvalError Math RangeError undefined\r\ndecodeURIComponent function NaN ReferenceError URIError\r\n\r\n자바스크립트에서는 정의된 전역 변수와 전역 함수가 구현체마다 다를 수 있고, 자바스크립트 내장 방식(클리어이언트 측, 서버 측 등)에 따라 전역 프로퍼티 목록도 다를 수 있다.\r\n\r\n2.5 선택적인 세미콜론 사용\r\n\r\n다른 프로그래밍 언어와 마찬가지로 자바스크립트에서도 문장을 구분하기 위해 세미콜론을 사용한다. 이 점은 코드를 좀 더 의미 있게 만드는 측면에서 볼 때 중요하다. 구분자가 없으면 한 문장의 끝에 다음 문장의 시작이 올수 있고, 그다음 문장도 마찬가지다. 자바스크립트에서는 여러 문장이 서로 다른 줄에 나타나는 경우 세미콜론을 생략할 수 있다( 또한 프로그램의 끝이나 다음 토큰이 } 일 경우에도 세미콜론을 생략할 수 있다).\r\n어떤 스타일을 선택하든 자바스크립트에서 세미콜론이 필수가 아닌 몇 가지 경우에 대해 자세히 이해하고 있어야 한다. 다음 코드를 살펴보자. 두 문장이 각각 다른 줄에 작성되어 있으므로, 첫 행의 세미콜론은 생략할 수 있다.\r\n\r\na = 3;\r\nb = 4;\r\n\r\n그러나 코드가 다음과 같이 작성된 경우에는 첫 번째 세미콜론이 반드시 필요하다.\r\n\r\na = 3; b = 4;\r\n\r\n자바스크립트가 항상 모든 줄바꿈을 세미콜론으로 해석하는 것은 아니다. 일반적으로 세미콜론 없이 코드를 해석할 수 없는 경우에만 줄바꿈을 세미콜론으로 해석한다. 더 형식적으로 말하자면 자바스크립트는 다음 줄에 나오는 공백 아닌 첫 문자를 현재 문장과 이어서 해석 할 수 없을 경우에만 줄바꿈을 세미콜론으로 취급한다. 다음 코드를 살펴보자.\r\n\r\nvar a\r\na\r\n=\r\n3\r\nconsole.log(a)\r\n\r\n자바스크립트는 이 코드를 다음과 같이 해석한다.\r\n\r\nvar a ; a = 3; console.log(a);\r\n\r\n자바스크립트는 첫 번째 줄바꿈을 세미콜론으로 취급하는데, 이는 세미콜론 없이 var a a 코드를 해석할 수 없기 때문이다. 두 번째 a는 그 자체로 실행문 a;이 될 수 있지만, 좀 더 긴 문장인 a =3; 으로 해석할 수 있기 떄문에 두 번째 줄바꿈을 세미콜론으로 취급하지 않는다. 이러한 문장 종료 규칙은 상황에 따라 일부 의도하지 않는 결과를 초래할 수 있다. 다음의 코드는 두 가지 별개의 문장을 작성한 것처럼 보인다.\r\n\r\nvar y = x + f\r\n(a+b).toString()\r\n\r\n하지만 두 번째 줄의 괄호가 첫 줄의 함수 f를 호출하는 것으로 해석될 수 있기 때문에 자바스크립트는 이 코드를 이렇게 해석한다.\r\n\r\nvar y = x + f(a+b).toString();\r\n\r\n이는 십중팔구 코드의 저자가 의도한 해석이 아닐 가능성이 크다. 이 경우에 두개의 별개 문장으로 작동하게 하려면 명시적으로 세미콜론을 사용해야 한다. 일반적으로, 문장이 (, {, /, +, -로 시작하면 자바스크립트 인터프리터는 해당 문장을 이전 문장에 이어서 해석한다. 문장이 /나 +, -로 시작하는 경우는 극히 드물지만, (나 [로 시작하는 문장은 최소한 자바스크립트 프로그래밍에서는 자주 볼 수 있다. 일부 프로그래머들은 문장의 시작 부분에 방어적인 세미콜론을 넣기도 한다. 이렇게 문장을 작성할 경우, 바로 전 문장의 끝에 세미콜론을 빼먹었어도 항상 그 다음 문장은 올바로 해석된다.\r\n\r\nvar x = 0 // 세미콜론이 생략됐다.\r\n\r\n;[x, x+1, x+2].forEach(console.log) //문장 앞에 넣은 방어적인 세미콜론이 이 문장을 위의 문장과 구분되게\r\n해준다.\r\n\r\n지금까지 자바스크립트에서 줄바꿈을 세미콜론으로 해석하는 일반적인 규칙에 대해 살펴봤다. 다음 줄을 첫 줄의 문장과 이어서 하나로 처리할 수 없는 경우에만 줄바꿈을 세미콜론으로 해석한다는 일반 규칙에는 두 가지 예외가 있다. 첫번째 예외는 return, break, continue문을 사용했을 경우다. 만약 줄 바꿈이 return, break, continue 문 바로 다음에 올 경우(줄바꿈 문자 이전까지 어떠한 토큰도 사용하지 않았을 경우)에 자바스크립트는 줄바꿈을 세미콜론으로 해석한다. 예를 들어, 다음과 같은 예제를 살펴보자.\r\n\r\nreturn\r\ntrue;\r\n\r\n자바스크립트는 여러분이 다음의 코드를 작성하려 했다고 간주한다.\r\n\r\nreturn; true;\r\n\r\n하지만 여러분이 원했던 코드는 아마도 다음과 같을 것이다.\r\n\r\nreturn true;\r\n\r\n여기서 알아야 할 점은 return, break, continue와 다음에 오는 키워드 사이에 줄바꿈을 하지 말아야 한다는 것이다. 만약에 줄바꿈을 할 경우, 좀처럼 디버깅하기 힘들고 예상치 못한 경우로 프로그램이 비정상적으로 종료될 수도 있다. 두 번째 예외는 ++나 -- 연산자가 포함된 경우다. 이러한 연산자는 피연산자가 전에 오면 전치(prefix) 연산자가 되고, 피연산자가 다음에 올 경우 후치(postfix) 연산자가 된다. 만약 이러한 연산자들을 후치 연산자로 사용할 경우에는 반드시 연산자가 적용되는 표현식과 동일한 줄에 나타나야 한다. 이렇지 않으면, 줄바꿈은 무조건 세미콜론으로 해석되고 ++나 --는 줄바꿈 다음 피연산자의 전치 연산자로 해석될 것이다. 예를 들어, 아래의 코드를 살펴보자.\r\n\r\nx\r\n++\r\ny\r\n\r\n위 코드는 x++; y가 아니라 x; ++y로 해석된다.\r\n","excerpt":"자바스크립트 프로그램은 unicode 문자 집합을 사용해 작성된다. unicode는 ASCII나 Latin-1의 상위 집합이고 지구상에서 사용되는 대부분의 문자를 표현할 수 있다. 자바스크립트는 대소문자를 구분하는 언어다. 다시 말해 키워드, 변수,…","fields":{"slug":"/javascript-study_1/"},"frontmatter":{"date":"Sep 28, 2021","title":"javascript 어휘구조","tags":["javascript"],"update":"Sep 28, 2021"}}},{"node":{"rawMarkdownBody":"\r\nHello world 예제\r\n기본적으로 이 앱은 여러분이 작성할 수 있는 가장 간단한 Express 앱일 것입니다. 이 앱은 하나의 파일로 된 앱이며 Express 생성기를 통해 얻게 되는 앱과는 같지 않습니다. (이 예제와 달리 Express 생성기를 통해 얻게 되는 앱은 다양한 목적을 위한 여러 JavaScript 파일, Jade 템플리트 및 하위 디렉토리를 포함하는 전체 앱에 대한 스캐폴딩을 작성합니다.)\r\n먼저, myapp이라는 이름의 디렉토리를 작성한 후 이 디렉토리로 이동하여 npm init를 실행하십시오. 이후 설치 안내서에 따라 express를 종속 항목으로서 설치하십시오.\r\nmyapp 디렉토리에 app.js라는 이름의 파일을 작성한 후 다음과 같은 코드를 추가하십시오.\r\n\r\nvar express = require('express');\r\nvar app = express();\r\napp.get('/', function (req, res) {\r\nres.send('Hello World!');\r\n});\r\napp.listen(3000, function () {\r\nconsole.log('Example app listening on port 3000!');\r\n});\r\n앱은 서버를 시작하며 3000번 포트에서 연결을 청취합니다. 앱은 루트 URL(/) 또는 라우트에 대한 요청에 “Hello World!”로 응답합니다. 다른 모든 경로에 대해서는 404 Not Found로 응답합니다.\r\nreq(요청) 및 res(응답)는 Node가 제공하는 동일한 오브젝트이며, 따라서 req.pipe(), req.on('data', callback) 그리고 Express의 관여가 필요 없는 다른 모든 항목을 호출할 수 있습니다.\r\n다음의 명령을 이용하여 앱을 실행하십시오.\r\n\r\n\\$ node app.js\r\n이후 브라우저에서 http://localhost:3000/을 로드하여 결과물을 확인하십시오.\r\n\r\n출처: <https://expressjs.com/ko/starter/hello-world.html>\r\n\r\nExpress 애플리케이션 생성기\r\n애플리케이션의 골격을 신속하게 작성하려면 애플리케이션 생성기 도구인 express를 사용하십시오.\r\n다음의 명령을 이용해 express를 설치하십시오.\r\n\r\n\\$ npm install express-generator -g\r\n다음과 같이 -h 옵션을 이용해 명령의 옵션을 표시하십시오.\r\n\r\n\\$ express -h\r\nUsage: express [options][dir]\r\nOptions:\r\n-h, --help output usage information\r\n--version output the version number\r\n-e, --ejs add ejs engine support\r\n--hbs add handlebars engine support\r\n--pug add pug engine support\r\n-H, --hogan add hogan.js engine support\r\n--no-view generate without view engine\r\n-v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)\r\n-c, --css <engine> add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)\r\n--git add .gitignore\r\n-f, --force force on non-empty directory\r\n예를 들면, 다음의 예에서는 *myapp*라는 이름의 Express 앱을 현재 작업 디렉토리에 작성합니다.\r\n\r\n\\$ express --view=pug myapp\r\ncreate : myapp\r\ncreate : myapp/package.json\r\ncreate : myapp/app.js\r\ncreate : myapp/public\r\ncreate : myapp/public/javascripts\r\ncreate : myapp/public/images\r\ncreate : myapp/routes\r\ncreate : myapp/routes/index.js\r\ncreate : myapp/routes/users.js\r\ncreate : myapp/public/stylesheets\r\ncreate : myapp/public/stylesheets/style.css\r\ncreate : myapp/views\r\ncreate : myapp/views/index.pug\r\ncreate : myapp/views/layout.pug\r\ncreate : myapp/views/error.pug\r\ncreate : myapp/bin\r\ncreate : myapp/bin/www\r\n이후 다음과 같이 종속 항목을 설치하십시오.\r\n\r\n$ cd myapp\r\n$ npm install\r\nMacOS 또는 Linux에서는 다음 명령을 사용하여 앱을 실행하십시오.\r\n\r\n\\$ DEBUG=myapp:\\* npm start\r\nWindows에서는 다음 명령을 사용하십시오.\r\n\r\n> set DEBUG=myapp:\\* & npm start\r\n> 이후 브라우저에서 http://localhost:3000/을 로드하여 앱에 액세스하십시오.\r\n> 생성된 앱은 다음과 같은 디렉토리 구조를 갖습니다.\r\n\r\n.\r\n├── app.js\r\n├── bin\r\n│ └── www\r\n├── package.json\r\n├── public\r\n│ ├── images\r\n│ ├── javascripts\r\n│ └── stylesheets\r\n│ └── style.css\r\n├── routes\r\n│ ├── index.js\r\n│ └── users.js\r\n└── views\r\n├── error.pug\r\n├── index.pug\r\n└── layout.pug\r\n7 directories, 9 files\r\n생성기에 의해 작성된 앱 구조는 Express 앱을 구조화하는 여러 방법 중 하나에 불과합니다. 이러한 구조를 사용하거나 사용자의 요구사항에 가장 적합하도록 구조를 수정하십시오.\r\n\r\n출처: <https://expressjs.com/ko/starter/generator.html>\r\n\r\n기본 라우팅\r\n라우팅은 URI(또는 경로) 및 특정한 HTTP 요청 메소드(GET, POST 등)인 특정 엔드포인트에 대한 클라이언트 요청에 애플리케이션이 응답하는 방법을 결정하는 것을 말합니다.\r\n각 라우트는 하나 이상의 핸들러 함수를 가질 수 있으며, 이러한 함수는 라우트가 일치할 때 실행됩니다.\r\n라우트 정의에는 다음과 같은 구조가 필요합니다.\r\n\r\napp.METHOD(PATH, HANDLER)\r\n여기서,\r\n• app은 express의 인스턴스입니다.\r\n• METHOD는 HTTP 요청 메소드입니다.\r\n• PATH는 서버에서의 경로입니다.\r\n• HANDLER는 라우트가 일치할 때 실행되는 함수입니다.\r\n이 학습서에서는 app이라는 이름의 express 인스턴스가 작성되며 서버가 실행 중인 것으로 가정합니다. 앱의 작성 및 시작에 익숙하지 않은 경우에는 Hello world 예제를 참조하십시오.\r\n다음 예에서는 간단한 라우트의 정의를 설명합니다.\r\n홈 페이지에서 Hello World!로 응답:\r\n\r\napp.get('/', function (req, res) {\r\nres.send('Hello World!');\r\n});\r\n애플리케이션의 홈 페이지인 루트 라우트(/)에서 POST 요청에 응답:\r\n\r\napp.post('/', function (req, res) {\r\nres.send('Got a POST request');\r\n});\r\n/user 라우트에 대한 PUT 요청에 응답:\r\n\r\napp.put('/user', function (req, res) {\r\nres.send('Got a PUT request at /user');\r\n});\r\n/user 라우트에 대한 DELETE 요청에 응답:\r\n\r\napp.delete('/user', function (req, res) {\r\nres.send('Got a DELETE request at /user');\r\n});\r\n라우팅에 대한 자세한 내용을 확인하려면 라우팅 안내서를 참조하십시오.\r\n\r\n출처: <https://expressjs.com/ko/starter/basic-routing.html>\r\n\r\nExpress에서 정적 파일 제공\r\n이미지, CSS 파일 및 JavaScript 파일과 같은 정적 파일을 제공하려면 Express의 기본 제공 미들웨어 함수인 express.static을 사용하십시오.\r\n정적 자산이 포함된 디렉토리의 이름을 express.static 미들웨어 함수에 전달하면 파일의 직접적인 제공을 시작할 수 있습니다. 예를 들면, 다음과 같은 코드를 이용하여 public이라는 이름의 디렉토리에 포함된 이미지, CSS 파일 및 JavaScript 파일을 제공하십시오.\r\n\r\napp.use(express.static('public'));\r\n이제 다음과 같이 public 디렉토리에 포함된 파일을 로드할 수 있습니다.\r\n\r\nhttp://localhost:3000/images/kitten.jpg\r\nhttp://localhost:3000/css/style.css\r\nhttp://localhost:3000/js/app.js\r\nhttp://localhost:3000/images/bg.png\r\nhttp://localhost:3000/hello.html\r\nExpress는 정적 디렉토리에 대해 상대적으로 파일을 검색하며, 따라서 정적 디렉토리의 이름은 URL의 일부가 아닙니다.\r\n여러 개의 정적 자산 디렉토리를 이용하려면 다음과 같이 express.static 미들웨어 함수를 여러 번 호출하십시오.\r\n\r\napp.use(express.static('public'));\r\napp.use(express.static('files'));\r\nExpress는 express.static 미들웨어 함수를 이용해 정적 디렉토리를 설정한 순서대로 파일을 검색합니다.\r\nexpress.static 함수를 통해 제공되는 파일에 대한 가상 경로 접두부(파일 시스템 내에 해당 경로가 실제로 존재하지 않는 경우)를 작성하려면, 아래에 표시된 것과 같이 정적 디렉토리에 대한 마운트 경로를 지정하십시오.\r\n\r\napp.use('/static', express.static('public'));\r\n이제 /static 경로 접두부를 통해 public 디렉토리에 포함된 파일을 로드할 수 있습니다.\r\n\r\nhttp://localhost:3000/static/images/kitten.jpg\r\nhttp://localhost:3000/static/css/style.css\r\nhttp://localhost:3000/static/js/app.js\r\nhttp://localhost:3000/static/images/bg.png\r\nhttp://localhost:3000/static/hello.html\r\n그러나 express.static 함수에 제공되는 경로는 node 프로세스가 실행되는 디렉토리에 대해 상대적입니다. Express 앱을 다른 디렉토리에서 실행하는 경우에는 다음과 같이 제공하기 원하는 디렉토리의 절대 경로를 사용하는 것이 더 안전합니다.\r\n\r\napp.use('/static', express.static(\\_\\_dirname + '/public'));\r\n\r\n출처: <https://expressjs.com/ko/starter/static-files.html>\r\n\r\n라우팅\r\n라우팅은 애플리케이션 엔드 포인트(URI)의 정의, 그리고 URI가 클라이언트 요청에 응답하는 방식을 말합니다. 라우팅에 대한 소개는 기본 라우팅을 참조하십시오.\r\n다음 코드는 매우 기본적인 라우트의 예입니다.\r\n\r\nvar express = require('express');\r\nvar app = express();\r\n// respond with \"hello world\" when a GET request is made to the homepage\r\napp.get('/', function(req, res) {\r\nres.send('hello world');\r\n});\r\n라우트 메소드\r\n라우트 메소드는 HTTP 메소드 중 하나로부터 파생되며, express 클래스의 인스턴스에 연결됩니다.\r\n다음 코드는 앱의 루트에 대한 GET 및 POST 메소드에 대해 정의된 라우트의 예입니다.\r\n\r\n// GET method route\r\napp.get('/', function (req, res) {\r\nres.send('GET request to the homepage');\r\n});\r\n// POST method route\r\napp.post('/', function (req, res) {\r\nres.send('POST request to the homepage');\r\n});\r\nExpress는 HTTP 메소드에 해당하는 다음과 같은 라우팅 메소드를 지원합니다. get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search 및 connect.\r\n올바르지 않은 JavaScript 변수 이름으로 변환되는 메소드를 라우팅하려면 대괄호 표기법을 사용하십시오. 예를 들면 app['m-search']('/', function ... 등과 같습니다.\r\n특수한 라우팅 메소드인 app.all()은 어떠한 HTTP 메소드로부터도 파생되지 않습니다. 이 메소드는 모든 요청 메소드에 대해 한 경로에서 미들웨어 함수를 로드하는 데 사용됩니다.\r\n다음 예에서는, GET, POST, PUT 또는 DELETE 메소드를 사용하는 경우, 또는 http 모듈에서 지원되는 기타 모든 HTTP 요청 메소드를 사용하는 경우 등의 “/secret”에 대한 요청을 위하여 핸들러가 실행됩니다.\r\n\r\napp.all('/secret', function (req, res, next) {\r\nconsole.log('Accessing the secret section ...');\r\nnext(); // pass control to the next handler\r\n});\r\n라우트 경로\r\n라우트 경로는, 요청 메소드와의 조합을 통해, 요청이 이루어질 수 있는 엔드포인트를 정의합니다. 라우트 경로는 문자열, 문자열 패턴 또는 정규식일 수 있습니다.\r\nExpress는 라우트 경로의 일치를 위해 path-to-regexp를 사용합니다. 라우트 경로를 정의할 수 있는 모든 가능성을 확인하려면 path-to-regexp 문서를 참조하십시오. Express Route Tester는 기본적인 Express 라우트의 테스트를 위한 편리한 도구이지만, 패턴 일치는 지원하지 않습니다.\r\n조회 문자열은 라우트 경로의 일부가 아닙니다.\r\n문자열을 기반으로 하는 라우트 경로의 몇 가지 예는 다음과 같습니다.\r\n다음의 라우트 경로는 요청을 루트 라우트 /에 일치시킵니다.\r\n\r\napp.get('/', function (req, res) {\r\nres.send('root');\r\n});\r\n다음의 라우트 경로는 요청을 /about에 일치시킵니다.\r\n\r\napp.get('/about', function (req, res) {\r\nres.send('about');\r\n});\r\n다음의 라우트 경로는 요청을 /random.text에 일치시킵니다.\r\n\r\napp.get('/random.text', function (req, res) {\r\nres.send('random.text');\r\n});\r\n문자열 패턴을 기반으로 하는 라우트 경로의 몇 가지 예는 다음과 같습니다.\r\n다음의 라우트 경로는 acd 및 abcd와 일치합니다.\r\n\r\napp.get('/ab?cd', function(req, res) {\r\nres.send('ab?cd');\r\n});\r\n다음의 라우트 경로는 abcd, abbcd 및 abbbcd 등과 일치합니다.\r\n\r\napp.get('/ab+cd', function(req, res) {\r\nres.send('ab+cd');\r\n});\r\n다음의 라우트 경로는 abcd, abxcd, abRABDOMcd 및 ab123cd 등과 일치합니다.\r\n\r\napp.get('/ab*cd', function(req, res) {\r\nres.send('ab*cd');\r\n});\r\n다음의 라우트 경로는 /abe 및 /abcde와 일치합니다.\r\n\r\napp.get('/ab(cd)?e', function(req, res) {\r\nres.send('ab(cd)?e');\r\n});\r\n?, +, \\* 및 () 문자는 정규식 문자의 서브세트입니다. 하이픈(-) 및 점(.)은 문자열 기반 경로에 의해 문자 그대로 해석됩니다.\r\n정규식을 기반으로 하는 라우트 경로의 예:\r\n다음의 라우트 경로는 라우트 이름에 “a”가 포함된 모든 항목과 일치합니다.\r\n\r\napp.get(/a/, function(req, res) {\r\nres.send('/a/');\r\n});\r\n다음의 라우트 경로는 butterfly 및 dragonfly와 일치하지만, butterflyman 및 dragonfly man 등과 일치하지 않습니다.\r\n\r\napp.get(/.*fly\\$/, function(req, res) {\r\nres.send('/.*fly\\$/');\r\n});\r\n라우트 핸들러\r\n미들웨어와 비슷하게 작동하는 여러 콜백 함수를 제공하여 요청을 처리할 수 있습니다. 유일한 차이점은 이러한 콜백은 next('route')를 호출하여 나머지 라우트 콜백을 우회할 수도 있다는 점입니다. 이러한 메커니즘을 이용하면 라우트에 대한 사전 조건을 지정한 후, 현재의 라우트를 계속할 이유가 없는 경우에는 제어를 후속 라우트에 전달할 수 있습니다.\r\n다음 예에 나타난 것과 같이, 라우트 핸들러는 함수나 함수 배열의 형태 또는 둘을 조합한 형태일 수 있습니다.\r\n하나의 콜백 함수는 하나의 라우트를 처리할 수 있습니다. 예를 들면 다음과 같습니다.\r\n\r\napp.get('/example/a', function (req, res) {\r\nres.send('Hello from A!');\r\n});\r\n2개 이상의 콜백 함수는 하나의 라우트를 처리할 수 있습니다(next 오브젝트를 반드시 지정해야 함). 예를 들면 다음과 같습니다.\r\n\r\napp.get('/example/b', function (req, res, next) {\r\nconsole.log('the response will be sent by the next function ...');\r\nnext();\r\n}, function (req, res) {\r\nres.send('Hello from B!');\r\n});\r\n하나의 콜백 함수 배열은 하나의 라우트를 처리할 수 있습니다. 예를 들면 다음과 같습니다.\r\n\r\nvar cb0 = function (req, res, next) {\r\nconsole.log('CB0');\r\nnext();\r\n}\r\nvar cb1 = function (req, res, next) {\r\nconsole.log('CB1');\r\nnext();\r\n}\r\nvar cb2 = function (req, res) {\r\nres.send('Hello from C!');\r\n}\r\napp.get('/example/c', [cb0, cb1, cb2]);\r\n독립적인 함수와 함수 배열의 조합은 하나의 라우트를 처리할 수 있습니다. 예를 들면 다음과 같습니다.\r\n\r\nvar cb0 = function (req, res, next) {\r\nconsole.log('CB0');\r\nnext();\r\n}\r\nvar cb1 = function (req, res, next) {\r\nconsole.log('CB1');\r\nnext();\r\n}\r\napp.get('/example/d', [cb0, cb1], function (req, res, next) {\r\nconsole.log('the response will be sent by the next function ...');\r\nnext();\r\n}, function (req, res) {\r\nres.send('Hello from D!');\r\n});\r\n응답 메소드\r\n다음 표에 표시된 응답 오브젝트에 대한 메소드(res)는 응답을 클라이언트로 전송하고 요청-응답 주기를 종료할 수 있습니다. 라우트 핸들러로부터 다음 메소드 중 어느 하나도 호출되지 않는 경우, 클라이언트 요청은 정지된 채로 방치됩니다.\r\n메소드 설명\r\nres.download() 파일이 다운로드되도록 프롬프트합니다.\r\nres.end() 응답 프로세스를 종료합니다.\r\nres.json() JSON 응답을 전송합니다.\r\nres.jsonp() JSONP 지원을 통해 JSON 응답을 전송합니다.\r\nres.redirect() 요청의 경로를 재지정합니다.\r\nres.render() 보기 템플리트를 렌더링합니다.\r\nres.send() 다양한 유형의 응답을 전송합니다.\r\nres.sendFile 파일을 옥텟 스트림의 형태로 전송합니다.\r\nres.sendStatus() 응답 상태 코드를 설정한 후 해당 코드를 문자열로 표현한 내용을 응답 본문으로서 전송합니다.\r\napp.route()\r\napp.route()를 이용하면 라우트 경로에 대하여 체인 가능한 라우트 핸들러를 작성할 수 있습니다. 경로는 한 곳에 지정되어 있으므로, 모듈식 라우트를 작성하면 중복성과 오타가 감소하여 도움이 됩니다. 라우트에 대한 자세한 정보는 Router() 문서를 참조하십시오.\r\napp.route()를 사용하여 정의된 체인 라우트 핸들러의 예는 다음과 같습니다.\r\n\r\napp.route('/book')\r\n.get(function(req, res) {\r\nres.send('Get a random book');\r\n})\r\n.post(function(req, res) {\r\nres.send('Add a book');\r\n})\r\n.put(function(req, res) {\r\nres.send('Update the book');\r\n});\r\nexpress.Router\r\nexpress.Router 클래스를 사용하면 모듈식 마운팅 가능한 핸들러를 작성할 수 있습니다. Router 인스턴스는 완전한 미들웨어이자 라우팅 시스템이며, 따라서 “미니 앱(mini-app)”이라고 불리는 경우가 많습니다.\r\n다음 예에서는 라우터를 모듈로서 작성하고, 라우터 모듈에서 미들웨어 함수를 로드하고, 몇몇 라우트를 정의하고, 기본 앱의 한 경로에 라우터 모듈을 마운트합니다.\r\n다음의 내용이 입력된 birds.js라는 이름의 라우터 파일을 앱 디렉토리에 작성하십시오.\r\n\r\nvar express = require('express');\r\nvar router = express.Router();\r\n// middleware that is specific to this router\r\nrouter.use(function timeLog(req, res, next) {\r\nconsole.log('Time: ', Date.now());\r\nnext();\r\n});\r\n// define the home page route\r\nrouter.get('/', function(req, res) {\r\nres.send('Birds home page');\r\n});\r\n// define the about route\r\nrouter.get('/about', function(req, res) {\r\nres.send('About birds');\r\n});\r\nmodule.exports = router;\r\n이후 앱 내에서 다음과 같이 라우터 모듈을 로드하십시오.\r\n\r\nvar birds = require('./birds');\r\n...\r\napp.use('/birds', birds);\r\n앱은 이제 /birds 및 /birds/about에 대한 요청을 처리할 수 있게 되었으며, 해당 라우트에 대한 특정한 미들웨어 함수인 timeLog를 호출할 것입니다.\r\n\r\n출처: <https://expressjs.com/ko/guide/routing.html>\r\n","excerpt":"Hello world 예제\n기본적으로 이 앱은 여러분이 작성할 수 있는 가장 간단한 Express 앱일 것입니다. 이 앱은 하나의 파일로 된 앱이며 Express 생성기를 통해 얻게 되는 앱과는 같지 않습니다. (이 예제와 달리 Express 생성기…","fields":{"slug":"/Express-study_1/"},"frontmatter":{"date":"Sep 20, 2021","title":"Express guide","tags":["express"],"update":"Sep 20, 2021"}}},{"node":{"rawMarkdownBody":"\r\n명령어 복습하기\r\n\r\n프로젝트 생성하기\r\nnpm init react-app .\r\n터미널에서 원하는 디렉토리에 들어가서 npm init react-app .를 입력하면 현재 디렉토리에 리액트 프로젝트를 생성합니다.\r\n\r\n개발 모드 실행하기\r\nnpm start (npm run start)\r\n터미널에서 npm run start를 입력하면 개발 모드 서버가 실행됩니다.\r\n\r\n실행 중인 서버 종료하기\r\nctrl + c\r\n서버가 실행 중인 터미널에서 ctrl + c를 입력하면 서버가 종료됩니다.\r\n\r\n개발된 프로젝트 빌드하기\r\nnpm run build\r\n터미널에서 npm run build를 입력하면 빌드를 시작합니다.\r\n\r\n빌드한 것 로컬에서 실행하기\r\nnpx serve build\r\n터미널에서 npx serve build를 입력하면 serve 프로그램을 다운 받고 build 폴더에서 서버가 실행됩니다.\r\n","excerpt":"명령어 복습하기 프로젝트 생성하기\nnpm init react-app .\n터미널에서 원하는 디렉토리에 들어가서 npm init react-app .를 입력하면 현재 디렉토리에 리액트 프로젝트를 생성합니다. 개발 모드 실행하기\nnpm start (npm…","fields":{"slug":"/React-study_6/"},"frontmatter":{"date":"Sep 01, 2021","title":"React 배포하기","tags":["react"],"update":"Sep 01, 2021"}}},{"node":{"rawMarkdownBody":"\r\n사실 CSS 파일을 불러오거나 이미지 파일을 불러오는 기능은 리액트 고유의 기능이 아니라 Create React App이라는 프로그램이 대신 설정해 준 기능입니다. (참고: Create React App 문서)\r\n\r\n클래스네임을 좀 더 편리하게 쓰는 방법\r\n\r\n디자인을 적용하는 방법\r\n이미지 불러오기\r\n이미지 파일은 import 구문을 통해 불러오고, 불러온 이미지 주소를 src 속성으로 사용하면 됩니다.\r\n\r\nimport diceImg from './assets/dice.png';\r\n\r\nfunction Dice() {\r\nreturn <img src={diceImg} alt=\"주사위 이미지\" />;\r\n}\r\n\r\nexport default App;\r\n인라인 스타일\r\n리액트에서 인라인 스타일은 문자열이 아닌 객체형으로 사용합니다. 프로퍼티 이름은 CSS 속성 이름으로, 프로퍼티 값은 CSS 속성 값으로 쓰는데요, 이때 프로퍼티 이름은 아래의 boarderRadius 처럼 대시 기호 없이 카멜 케이스로 써야 한다는 점도 꼭 기억해두세요.\r\n\r\nimport diceImg from './assets/dice.png';\r\n\r\nconst style = {\r\nborderRadius: '50%',\r\nwidth: '120px',\r\nheight: '120px',\r\n};\r\n\r\nfunction Dice() {\r\nreturn <img style={style} src={diceImg} alt=\"주사위 이미지\" />;\r\n}\r\n\r\nexport default App;\r\nCSS 파일 불러오기\r\nimport 구문으로 파일을 불러올 수 있는데요, 이때 from 키워드 없이 쓰면 됩니다.\r\n\r\nimport diceImg from './assets/dice.png';\r\nimport './Dice.css';\r\n\r\nfunction Dice() {\r\nreturn <img src={diceImg} alt=\"주사위 이미지\" />;\r\n}\r\n\r\nexport default App;\r\n클래스네임 사용하기\r\nCSS 파일에 정의된 클래스명을 className prop에 문자열로 넣어주면 됩니다. 이때 재사용성을 위해 className prop을 부모 컴포넌트에서 받으면 더 좋습니다.\r\n\r\nimport diceImg from './assets/dice.png';\r\nimport './Dice.css';\r\n\r\nfunction Dice({ className = '' }) {\r\nconst classNames = `Dice ${className}`;\r\nreturn <img className={classNames} src={diceImg} alt=\"주사위 이미지\" />;\r\n}\r\n\r\nexport default App;\r\n편리하게 클래스네임을 쓰는 방법\r\n앞에서는 여러 className을 템플릿 문자열로 합쳐서 사용했습니다. 몇 개 없을 때는 상관없지만, 개수가 늘어날수록 아래처럼 알아보기 힘들어진다는 문제점이 있는데요.\r\n\r\n템플릿 문자열을 사용한 예\r\nfunction Button({ isPending, color, size, invert, children }) {\r\nconst classNames = `Button ${isPending ? 'pending' : ''} ${color} ${size} ${invert ? 'invert' : ''}`;\r\nreturn <button className={classNames}>{children}</button>;\r\n}\r\n\r\nexport default Button;\r\n배열을 사용한 예\r\nfunction Button({ isPending, color, size, invert, children }) {\r\nconst classNames = [\r\n'Button',\r\nisPending ? 'pending' : '',\r\ncolor,\r\nsize,\r\ninvert ? 'invert' : '',\r\n].join('');\r\nreturn <button className={classNames}>{children}</button>;\r\n}\r\n\r\nexport default Button;\r\n위 예시 코드처럼 지저분하게 느껴지고, 매번 반복되는 코드를 작성한다는 번거로움이 있습니다. 개발자들은 이럴 때 라이브러리라는 걸 쓰는데요, 다른 개발자가 미리 만들어 놓은 코드를 이용해서 편하게 개발하는 겁니다.\r\n\r\n클래스네임의 경우에도 편리하게 사용할 수 있는 라이브러리가 많이 있는데요, 그중에서도 이번에 소개할 라이브러리는 바로 classnames라는 라이브러리입니다. 아래 예시 코드를 보시면 아시겠지만, 클래스네임에만 집중할 수 있어 훨씬 읽기 편해집니다. 이렇게 적절한 라이브러리를 쓰면 개발 생산성이 굉장히 좋아지죠.\r\n\r\nclassnames 라이브러리를 사용한 예\r\nimport classNames from 'classnames';\r\n\r\nfunction Button({ isPending, color, size, invert, children }) {\r\nreturn (\r\n<button\r\nclassName={classNames(\r\n'Button',\r\nisPending && 'pending',\r\ncolor,\r\nsize,\r\ninvert && 'invert',\r\n)}>\r\n{ children }\r\n</button >\r\n);\r\n}\r\n\r\nexport default Button;\r\nclassnames 은 NPM이라는 프로그램을 통해 설치할 수 있습니다. 터미널에서 npm install classnames 을 입력하고 설치한 다음에, 위 예시처럼 import 로 불러와서 사용하면 됩니다. NPM 저장소 사이트로 들어가면 사용 방법과 설명이 나와있음.\r\n\r\nNPM classnames 패키지: https://www.npmjs.com/package/classnames\r\n","excerpt":"사실 CSS 파일을 불러오거나 이미지 파일을 불러오는 기능은 리액트 고유의 기능이 아니라 Create React App이라는 프로그램이 대신 설정해 준 기능입니다. (참고: Create React App 문서) 클래스네임을 좀 더 편리하게 쓰는 방법…","fields":{"slug":"/React-study_5/"},"frontmatter":{"date":"Aug 24, 2021","title":"React 디자인 적용하는 방법과 팁","tags":["react"],"update":"Aug 24, 2021"}}},{"node":{"rawMarkdownBody":"\r\nState\r\nstate는 리액트에서 화면을 그려내는 데 굉장히 중요한 역할을 합니다.\r\n\r\nState라는 단어는 한국어로 '상태'라는 뜻이 있는데요. 리액트에서의 state도 그 의미가 다르지 않습니다.\r\n\r\n상태가 바뀔 때마다 화면을 새롭게 그려내는 방식으로 동작을 하는 것이죠.\r\n\r\n리액트에서 state를 만들고, state를 바꾸기 위해서는 일단 useState라는 함수를 활용해야 합니다.\r\n\r\nimport { useState } from 'react';\r\n\r\n// ...\r\n\r\nconst [num, setNum] = useState(1);\r\n\r\n// ...\r\n보통 이렇게 Destructuring 문법으로 작성하는데요. useState 함수가 초깃값을 아규먼트로 받고 그에 따른 실행 결과로 요소 2개를 가진 배열의 형태로 리턴을 하기 때문입니다.\r\n\r\n이때 첫 번째 요소가 바로 state이고, 두 번째 요소가 이 state를 바꾸는 setter 함수인데요.\r\n\r\n참고로 위 코드에서도 볼 수 있듯 첫 번째 변수는 원하는 state의 이름(num)을 지어주고, 두 번째 변수에는 state 이름 앞에 set을 붙인 다음 카멜 케이스로 이름을 지어주는 것(setNum)이 일반적입니다.\r\n\r\nstate는 변수에 새로운 값을 할당하는 방식으로 변경하는 것이 아니라 이 setter 함수를 활용해야 하는데요. setter 함수는 호출할 때 전달하는 아규먼트 값으로 state 값을 변경해 줍니다.\r\n\r\n그래서 아래 코드처럼 setter 함수를 활용해서 이벤트 핸들러를 등록해두면, 이벤트가 발생할 때마다 상태가 변하면서 화면이 새로 그려지는 것이죠!\r\n\r\nimport { useState } from 'react';\r\nimport Button from './Button';\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nconst [num, setNum] = useState(1);\r\n\r\nconst handleRollClick = () => {\r\nsetNum(3); // num state를 3으로 변경!\r\n};\r\n\r\nconst handleClearClick = () => {\r\nsetNum(1); // num state를 1로 변경!\r\n};\r\n\r\nreturn (\r\n<div>\r\n<Button onClick={handleRollClick}>던지기</Button>\r\n<Button onClick={handleClearClick}>처음부터</Button>\r\n<Dice color=\"red\" num={num} />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\n참조형 State\r\n자바스크립트의 자료형은 크게 기본형(Primitive type)과 참조형(Reference type)로 나눌 수 있다는 사실, 모두 알고 계시죠?\r\n\r\n특히 참조형 값들은 조금 독특한 특성을 가지고 있어서 변수로 다룰 때도 조금 주의해야 할 부분들이 있었는데요. state를 활용할 때도 마찬가지입니다!\r\n\r\n// ...\r\n\r\nconst [gameHistory, setGameHistory] = useState([]);\r\n\r\nconst handleRollClick = () => {\r\nconst nextNum = random(6);\r\ngameHistory.push(nextNum);\r\nsetGameHistory(gameHistory); // state가 제대로 변경되지 않는다!\r\n};\r\n\r\n// ...\r\n위 코드에서 볼 수 있듯 배열 값을 가진 gameHistory에 push 메소드를 이용해서 배열의 값을 변경한 다음, 변경된 배열을 setter 함수로 state를 변경하려고 하면 코드가 제대로 동작하지 않습니다.\r\n\r\ngameHistory state는 배열 값 자체를 가지고 있는 게 아니라 그 배열의 주솟값을 참조하고 있는 건데요. 때문에 push 메소드로 배열 안에 요소를 변경했다고 하더라도 결과적으로 참조하는 배열의 주솟값은 변경된 것이 아니게 됩니다.\r\n\r\n결과적으로 리액트 입장에서는 gameHistory state가 참조하는 주솟값은 여전히 똑같기 때문에 상태(state)가 바뀌었다고 판단하지 않는 것이죠!\r\n\r\n그래서 참조형 state를 활용할 때는 반드시 새로운 참조형 값을 만들어 state를 변경해야 합니다.\r\n\r\n가장 간단한 방법은 Spread 문법(...) 을 활용하는 것이겠죠?\r\n\r\n// ...\r\n\r\nconst [gameHistory, setGameHistory] = useState([]);\r\n\r\nconst handleRollClick = () => {\r\nconst nextNum = random(6);\r\nsetGameHistory([...gameHistory, nextNum]); // state가 제대로 변경된다!\r\n};\r\n\r\n// ...\r\n이 참조형 state의 특성을 이해하지 못하면, 간혹 state가 제대로 변경되지 않는 버그가 발생했을 때 원인을 제대로 찾지 못하는 경우가 발생할 수도 있는데요.\r\n\r\n참조형 state를 활용할 땐 반드시 새로운 참조형 값을 만들어서 state를 변경해야 한다는 점.\r\n","excerpt":"State\nstate는 리액트에서 화면을 그려내는 데 굉장히 중요한 역할을 합니다. State라는 단어는 한국어로 '상태'라는 뜻이 있는데요. 리액트에서의 state도 그 의미가 다르지 않습니다. 상태가 바뀔 때마다 화면을 새롭게 그려내는 방식으로 …","fields":{"slug":"/React-study_4/"},"frontmatter":{"date":"Aug 23, 2021","title":"React state 정리하기","tags":["react"],"update":"Aug 23, 2021"}}},{"node":{"rawMarkdownBody":"\r\nJSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다.\r\n\r\nProps는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 모여서 컴포넌트를 정의한 함수의 첫 번째 파라미터로 전달됩니다.\r\n\r\nApp.js\r\n\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<Dice color=\"blue\" />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\nDice.js\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\n\r\nfunction Dice(props) {\r\nconsole.log(props)\r\nreturn <img src={diceBlue01} alt=\"주사위\" />;\r\n}\r\n\r\nexport default Dice;\r\n위 코드들 처럼 App 함수에서 사용하는 Dice 컴포넌트에 color라는 속성을 blue로 지정해주고, Dice 함수 내부에서 props라는 파라미터를 하나 만들어 출력해보면 브라우저 콘솔에는 다음과 같은 출력 결과가 나타나게 됩니다.\r\n\r\n{ color: \"blue\" }\r\n그래서 컴포넌트를 활용할 때 속성값을 다양하게 전달하고 이 props 값을 활용하면, 똑같은 컴포넌트라도 전달된 속성값에 따라 서로 다른 모습을 그려낼 수도 있게 됩니다.\r\n\r\nApp.js\r\n\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<Dice color=\"red\" num={2} />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\nDice.js\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\nimport diceBlue02 from './assets/dice-blue-2.svg';\r\n// ...\r\nimport diceRed01 from './assets/dice-red-1.svg';\r\nimport diceRed02 from './assets/dice-red-2.svg';\r\n// ...\r\n\r\nconst DICE_IMAGES = {\r\nblue: [diceBlue01, diceBlue02],\r\nred: [diceRed01, diceRed02],\r\n};\r\n\r\nfunction Dice(props) {\r\nconst src = DICE_IMAGES[props.color][props.num - 1];\r\nconst alt = `${props.color} ${props.num}`;\r\nreturn <img src={src} alt={alt} />;\r\n}\r\n\r\nexport default Dice;\r\n참고로, 이렇게 props가 객체 형태를 띠고 있으니 Destructuring 문법을 활용해서 조금 더 간결하게 코드를 작성할 수도 있겠죠?\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\nimport diceBlue02 from './assets/dice-blue-2.svg';\r\n// ...\r\nimport diceRed01 from './assets/dice-red-1.svg';\r\nimport diceRed02 from './assets/dice-red-2.svg';\r\n// ...\r\n\r\nconst DICE_IMAGES = {\r\nblue: [diceBlue01, diceBlue02],\r\nred: [diceRed01, diceRed02],\r\n};\r\n\r\nfunction Dice({ color = 'blue', num = 1 }) {\r\nconst src = DICE_IMAGES[color][num - 1];\r\nconst alt = `${color} ${num}`;\r\nreturn <img src={src} alt={alt} />;\r\n}\r\n\r\nexport default Dice;\r\nChildren\r\nprops에는 children이라는 조금 특별한 프로퍼티(prop, 프롭)가 있습니다.\r\n\r\nJSX 문법으로 컴포넌트를 작성할 때 컴포넌트를 단일 태그가 아니라 여는 태그와 닫는 태그의 형태로 작성하면, 그 안에 작성된 코드가 바로 이 children 값에 담기게 됩니다.\r\n\r\nButton.js\r\n\r\nfunction Button({ children }) {\r\nreturn <button>{children}</button>;\r\n}\r\n\r\nexport default Button;\r\nApp.js\r\n\r\nimport Button from './Button';\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<div>\r\n<Button>던지기</Button>\r\n<Button>처음부터</Button>\r\n</div>\r\n<Dice color=\"red\" num={2} />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\n그래서 JSX 문법으로 컴포넌트를 작성할 때 어떤 정보를 전달할 때는 일반적인 props의 속성값을 주로 활용하고, 화면에 보여질 모습을 조금 더 직관적인 코드로 작성하고자 할 때 children 값을 활용할 수가 있습니다.\r\n\r\n참고로 이 children을 활용하면 단순히 텍스트만 작성하는 걸 넘어서 컴포넌트 안에 컴포넌트를 작성할 수도 있고, 컴포넌트 안에 복잡한 태그들을 더 작성할 수도 있다.\r\n","excerpt":"JSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다. Props는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 …","fields":{"slug":"/React-study_3/"},"frontmatter":{"date":"Aug 22, 2021","title":"React Props 문법","tags":["react"],"update":"Aug 22, 2021"}}},{"node":{"rawMarkdownBody":"\r\n리액트 엘리먼트\r\nJSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst element = <h1>안녕 리액트!</h1>;\r\nconsole.log(element);\r\nReactDOM.render(element, document.getElementById('root'));\r\n{\\$\\$typeof: Symbol(react.element), type: \"h1\", key: null, ref: null, props: {…}, …}\r\n이런 객체를 리액트 엘리먼트라고 부르는데요.\r\n\r\n이 리액트 엘리먼트를 ReactDOM.render 함수의 아규먼트로 전달하게 되면, 리액트가 객체 형태의 값을 해석해서 HTML 형태로 브라우저에 띄워주는 것이죠.\r\n\r\n리액트 엘리먼트는 리액트로 화면을 그려내는데 가장 기본적인 요소입니다.\r\n\r\n리액트 컴포넌트\r\n리액트 컴포넌트는 리액트 엘리먼트를 조금 더 자유롭게 다루기 위한 하나의 문법입니다.\r\n\r\n컴포넌트를 만드는 가장 간단한 방법은 자바스크립트의 함수를 활용하는 건데요.\r\n아래 코드에서 JSX 문법으로 작성된 하나의 요소를 리턴하는 Hello 함수가 바로 하나의 컴포넌트입니다.\r\n\r\n이렇게 요소를 컴포넌트로 작성하게 되면 다양한 장점들이 있는데,\r\n자세한 내용은 이후의 개념들을 하나씩 배워나가면서 차차 알아보도록 합시다!\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nfunction Hello() {\r\nreturn <h1>안녕 리액트</h1>;\r\n}\r\n\r\nconst element = (\r\n<>\r\n<Hello />\r\n<Hello />\r\n<Hello />\r\n</>\r\n);\r\n\r\nReactDOM.render(element, document.getElementById('root'));\r\n그리고 이렇게 컴포넌트를 작성하면,\r\n위 코드에서 element 변수 안의 JSX 코드에서 볼 수 있듯 컴포넌트 함수 이름을 통해 하나의 태그처럼 활용할 수가 있습니다.\r\n\r\n이런 특성을 모듈 문법으로 활용하면 훨씬 더 독립적으로 컴포넌트 특성에 집중해서 코드를 작성할 수가 있습니다.\r\n\r\n예시: Dice.js\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\n\r\nfunction Dice() {\r\nreturn <img src={diceBlue01} alt=\"주사위\" />;\r\n}\r\n\r\nexport default Dice;\r\n예시: App.js\r\n\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<Dice />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\n한 가지 주의해야 할 부분은, 리액트 컴포넌트의 이름은 반드시 첫 글자를 대문자로 작성해야 한다는 것입니다.\r\n컴포넌트 이름의 첫 글자가 소문자라면 오류가 발생하니깐 꼭 주의!\r\n","excerpt":"리액트 엘리먼트\nJSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다. import ReactDOM from 'react-dom'; const element = 안녕 리액트!;\nconsole.log(element);\nReactDOM.r…","fields":{"slug":"/React-study_2/"},"frontmatter":{"date":"Aug 21, 2021","title":"React commponent 문법","tags":["react"],"update":"Aug 21, 2021"}}},{"node":{"rawMarkdownBody":"\r\nJSX란?\r\nJSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(<h1>안녕 리액트!</h1>, document.getElementById('root'));\r\nJSX 문법\r\nJSX는 자바스크립트로 HTML과 같은 문법을 사용할 수 있도록 만들어주는 편리한 문법이지만, 그만큼 꼭 지켜야 할 규칙들도 있습니다.\r\n\r\nHTML과 다른 속성명\r\n\r\n1. 속성명은 카멜 케이스로 작성하기!\r\n   JSX 문법에서도 태그에 속성을 지정해 줄 수 있습니다. 단, 여러 단어가 조합된 몇몇 속성들을 사용할 때는 반드시 카멜 케이스(Camel Case)로 작성해야 합니다.\r\n   사실 여러 단어가 조합된 HTML 속성들이 많진 않지만, 예를 들면 onclick, onblur, onfocus 등과 같은 이벤트 속성이나, tabindex 같은 속성들이 있습니다.\r\n   이런 속성들은 모두 onClick, onBlur, onFocus, onMouseDown, onMouseOver, tabIndex 처럼 작성하는 것이죠!\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n<button onClick= ... >클릭!</button>,\r\ndocument.getElementById('root')\r\n);\r\n단, 예외적으로 HTML에서 비표준 속성을 다룰 때 활용하는 data-\\* 속성은 카멜 케이스(Camel Case)가 아니라 기존의 HTML 문법 그대로 작성하셔야 합니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <div>\r\n    상태 변경: \r\n    <button className=\"btn\" data-status=\"대기중\">대기중</button>\r\n    <button className=\"btn\" data-status=\"진행중\">진행중</button>\r\n    <button className=\"btn\" data-status=\"완료\">완료</button>\r\n  </div>,\r\n  document.getElementById('root')\r\n);\r\n2. 자바스크립트 예약어와 같은 속성명은 사용할 수 없다!\r\nJSX 문법도 결국은 자바스크립트 문법이기 때문에, for나 class처럼 자바스크립트의 문법에 해당하는 예약어와 똑같은 이름의 속성명은 사용할 수 없습니다.\r\n그래서 HTML의 for의 경우에는 자바스크립트의 반복문 키워드 for와 겹치기 때문에 htmlFor로, HTML의 class 속성도 자바스크립트의 클래스 키워드 class와 겹치기 때문에 className으로 작성해 주어야 합니다.\r\n\r\nReact 공식 문서 - 어트리뷰트의 차이\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <form>\r\n    <label htmlFor=\"name\">이름</label>\r\n    <input id=\"name\" className=\"name-input\" type=\"text\" />\r\n  </form>,\r\n  document.getElementById('root')\r\n);\r\n반드시 하나의 요소로 감싸기 - Fragment\r\nJSX 문법을 활용할 때는 반드시 하나의 요소로 감싸주어야 합니다. 그래서 아래 코드처럼 여러 개의 요소를 작성하면 오류가 발생하는데요.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <p>안녕</p>\r\n  <p>리액트!</p>,\r\n  document.getElementById('root')\r\n);\r\n이럴 때는 아래 코드처럼 여러 태그를 감싸는 부모 태그를 만들어 하나의 요소로 만들어 주어야 합니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <div>\r\n    <p>안녕</p>\r\n    <p>리액트!</p>\r\n  </div>,\r\n  document.getElementById('root')\r\n);\r\n하지만 이렇게 작성한다면 때로는 꼭 필요하지 않은 부모 태그가 작성될 수 있겠죠? 그럴 땐 Fragment로 감싸주면 의미 없는 부모 태그를 만들지 않아도 여러 요소를 작성할 수 있습니다.\r\n\r\nimport { Fragment } from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n<Fragment>\r\n\r\n<p>안녕</p>\r\n<p>리액트!</p>\r\n</Fragment>,\r\ndocument.getElementById('root')\r\n);\r\n참고로 Fragment는 아래 코드처럼 빈 태그로 감싸는 단축 문법으로 활용할 수도 있습니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n<>\r\n\r\n<p>안녕</p>\r\n<p>리액트!</p>\r\n</>,\r\ndocument.getElementById('root')\r\n);\r\n자바스크립트 표현식 넣기\r\nJSX 문법에서 중괄호({})를 활용하면 자바스크립트 표현식을 넣을 수 있습니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst product = '맥북';\r\n\r\nReactDOM.render(\r\n\r\n  <h1>나만의 {product} 주문하기</h1>,\r\n  document.getElementById('root')\r\n);\r\n이런 부분들을 잘 활용하면, 아래 코드처럼 중괄호 안에서 문자열을 조합할 수도 있고 변수에 이미지 주소를 할당해서 img 태그의 src 속성값을 전달해 줄 수도 있고, 이벤트 핸들러를 좀 더 편리하게 등록할 수도 있습니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst product = 'MacBook';\r\nconst model = 'Air';\r\nconst imageUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/MacBook_with_Retina_Display.png/500px-MacBook_with_Retina_Display.png'\r\n\r\nfunction handleClick(e) {\r\nalert('곧 도착합니다!');\r\n}\r\n\r\nReactDOM.render(\r\n<>\r\n\r\n<h1>{product + ' ' + model} 주문하기</h1>\r\n<img src={imageUrl} alt=\"제품 사진\" />\r\n<button onClick={handleClick}>확인</button>\r\n</>,\r\ndocument.getElementById('root')\r\n);\r\n단, JSX 문법에서 중괄호는 자바스크립트 표현식을 다룰 때 활용하기 때문에, 중괄호 안에서 for, if문 등의 문장은 다룰 수 없다는 점은 꼭 기억해 주세요.\r\n그런데도 만약 JSX 문법을 활용할 때 조건문이 꼭 필요하다면 조건 연산자를, 반복문이 꼭 필요하다면 배열의 반복 메소드를 활용하자.\r\n","excerpt":"JSX란?\nJSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다. import ReactDOM from 'react-do…","fields":{"slug":"/React-study_1/"},"frontmatter":{"date":"Aug 20, 2021","title":"React JSX 문법","tags":["react"],"update":"Aug 20, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)\r\ngit blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력\r\ngit revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성\r\n","excerpt":"git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)\ngit blame : 특정 파…","fields":{"slug":"/Git-study_5/"},"frontmatter":{"date":"Aug 17, 2021","title":"Git 협업하기 정리 노트","tags":["git"],"update":"Aug 17, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit branch [새 브랜치 이름] : 새로운 브랜치를 생성\r\ngit checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동\r\ngit branch -d [기존 브랜치 이름] : 브랜치 삭제\r\ngit checkout [기존 브랜치 이름] : 그 브랜치로 이동\r\ngit merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지\r\ngit merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감\r\n","excerpt":"git branch 새 브랜치 이름 : 새로운 브랜치를 생성\ngit checkout -b 새 브랜치 이름 : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동\ngit branch -d 기존 브랜치 이름 : 브랜치 삭제\ngit checkout 기존 브랜…","fields":{"slug":"/Git-study_4/"},"frontmatter":{"date":"Aug 17, 2021","title":"branch 정리 노트","tags":["git"],"update":"Aug 17, 2021"}}},{"node":{"rawMarkdownBody":"\r\nGit 써보기\r\ngit init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\r\ngit config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)\r\ngit config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)\r\ngit add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기\r\ngit add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit reset [파일 이름] : staging area에 올렸던 파일 다시 내리기\r\ngit status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)\r\ngit commit -m \"커밋 메시지\" : 현재 staging area에 있는 것들 커밋으로 남기기\r\ngit help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력\r\n\r\nGitHub 시작하기\r\ngit push -u(또는 --set-upstream) origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.\r\ngit push : 위의 커맨드를 한번 실행하고 난 후에는 git push라고만 쳐도 로컬 레포지토리의 내용을 리모트 레포지토리에 올릴 수 있습니다.\r\ngit pull : 바로 위의 위에 있는 커맨드를 한번 실행하고 난 후에는 git pull이라고만 쳐도 리모트 레포지토리의 내용을 로컬 레포지토리로 가져옵니다.\r\ngit clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기\r\n\r\nGit에서 커밋 다루기\r\ngit log : 커밋 히스토리를 출력\r\ngit log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.\r\ngit show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인\r\ngit commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦\r\ngit config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로는 별명으로도 해당 커맨드를 실행할 수 있게 설정\r\ngit diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교\r\ngit reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)\r\n(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)\r\n\r\n    \t(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)\r\n\r\n    \t(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)\r\n\r\n    \t그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨\r\n\r\ngit tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임\r\n\r\nGit에서 브랜치 사용하기\r\ngit branch [새 브랜치 이름] : 새로운 브랜치를 생성\r\ngit checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동\r\ngit branch -d [기존 브랜치 이름] : 브랜치 삭제\r\ngit checkout [기존 브랜치 이름] : 그 브랜치로 이동\r\ngit merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지\r\ngit merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감\r\n\r\nGit 실전 I\r\ngit fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)\r\ngit blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력\r\ngit revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성\r\n\r\nGit 실전 Ⅱ\r\ngit reflog : HEAD가 그동안 가리켜왔던 커밋들의 기록을 출력\r\ngit log --all --graph : 모든 브랜치의 커밋 히스토리를, 커밋 간의 관계가 잘 드러나도록 그래프 형식으로 출력\r\ngit rebase [브랜치 이름] : A, B 브랜치가 있는 상태에서 지금 HEAD가 A 브랜치를 가리킬 때, git rebase B를 실행하면 A, B 브랜치가 분기하는 시작점이 된 공통 커밋 이후로부터 존재하는 A 브랜치 상의 커밋들이 그대로 B 브랜치의 최신 커밋 이후로 이어붙여짐(git merge와 같은 효과를 가지지만 커밋 히스토리가 한 줄로 깔끔하게 된다는 차이점이 있음)\r\ngit stash : 현재 작업 내용을 스택 영역에 저장\r\ngit stash apply [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용\r\ngit stash drop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 스택에서 삭제\r\ngit stash pop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용하면서 스택에서 삭제\r\ngit cherry-pick [커밋 아이디] : 특정 커밋의 내용을 현재 커밋에 반영\r\n! 그 밖에 알아야할 사실\r\n\r\n(1) git commit이라고만 쓰고 실행하면 커밋 메시지를 입력할 수 있는 텍스트 에디터 창이 뜹니다. 거기서 커밋 메시지를 입력하고 저장하고 나면 커밋이 이루어집니다.\r\n\r\n(2) git push와 git pull은 그 작업 단위가 브랜치입니다. 예를 들어, master 브랜치에서 git push를 하면 master 브랜치의 내용만 리모트 레포지토리의 master 브랜치로 전송되지, premium 브랜치의 내용이 전송되는 것은 아닙니다.(git push에 --all이라는 옵션을 주면 모든 브랜치의 내용을 전송할 수 있기는 합니다.)\r\n","excerpt":"Git 써보기\ngit init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\ngit config user.name 'codeit' : 현재 사용자의 …","fields":{"slug":"/Git-study_6/"},"frontmatter":{"date":"Aug 17, 2021","title":"Git 내용 총정리 노트","tags":["git"],"update":"Aug 17, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.\r\ngit push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기\r\ngit pull : 리모트 레포지토리의 내용을 로컬 레포지토리로 가져오기\r\ngit clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기\r\n","excerpt":"git push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.\ngit push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기\ngit pull : 리모트 레포지토리의 내용을 로컬 …","fields":{"slug":"/Git-study_2/"},"frontmatter":{"date":"Aug 16, 2021","title":"GitHub 시작하기 정리 노트","tags":["git"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\r\ngit config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)\r\ngit config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)\r\ngit add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기\r\ngit add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit reset [파일 이름] : staging area에 올렸던 파일 다시 내리기\r\ngit status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)\r\ngit commit -m \"커밋 메시지\" : 현재 staging area에 있는 것들 커밋으로 남기기\r\ngit help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력\r\n","excerpt":"git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\ngit config user.name 'codeit' : 현재 사용자의 아이디를 'co…","fields":{"slug":"/Git-study_1/"},"frontmatter":{"date":"Aug 16, 2021","title":"Git 써보기 정리 노트","tags":["git"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit log : 커밋 히스토리를 출력\r\ngit log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.\r\ngit show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인\r\ngit commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦\r\ngit config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로 별명으로 해당 커맨드를 실행할 수 있도록 설정\r\ngit diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교\r\ngit reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)\r\n(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)\r\n\r\n    \t(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)\r\n\r\n    \t(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)\r\n\r\n    \t그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨\r\n\r\ngit tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임\r\n","excerpt":"git log : 커밋 히스토리를 출력\ngit log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 …","fields":{"slug":"/Git-study_3/"},"frontmatter":{"date":"Aug 16, 2021","title":"commit 정리 노트","tags":["git"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\n![](screenshot.png)\r\n\r\n이미지 파일이 첨부된 게시물의 예제입니다.\r\n\r\n폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다.\r\n\r\n게시물 파일명은 index.md 로 합니다.\r\n\r\n이미지 파일은 폴더 내에 위치시킵니다.\r\n\r\n자세한 가이드는 [Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 확인해주세요.\r\n","excerpt":"이미지 파일이 첨부된 게시물의 예제입니다. 폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다. 게시물 파일명은 index.md 로 합니다. 이미지 파일은 폴더 내에 위치시킵니다. 자세한 가이드는 Documents를 확인해주세요.","fields":{"slug":"/image-post-example.md/"},"frontmatter":{"date":"Mar 24, 1991","title":"Image, 이미지 게시물 예제","tags":["undefined"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}