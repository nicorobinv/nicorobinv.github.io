{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\nJSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다.\r\n\r\nProps는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 모여서 컴포넌트를 정의한 함수의 첫 번째 파라미터로 전달됩니다.\r\n\r\nApp.js\r\n\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<Dice color=\"blue\" />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\nDice.js\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\n\r\nfunction Dice(props) {\r\nconsole.log(props)\r\nreturn <img src={diceBlue01} alt=\"주사위\" />;\r\n}\r\n\r\nexport default Dice;\r\n위 코드들 처럼 App 함수에서 사용하는 Dice 컴포넌트에 color라는 속성을 blue로 지정해주고, Dice 함수 내부에서 props라는 파라미터를 하나 만들어 출력해보면 브라우저 콘솔에는 다음과 같은 출력 결과가 나타나게 됩니다.\r\n\r\n{ color: \"blue\" }\r\n그래서 컴포넌트를 활용할 때 속성값을 다양하게 전달하고 이 props 값을 활용하면, 똑같은 컴포넌트라도 전달된 속성값에 따라 서로 다른 모습을 그려낼 수도 있게 됩니다.\r\n\r\nApp.js\r\n\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<Dice color=\"red\" num={2} />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\nDice.js\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\nimport diceBlue02 from './assets/dice-blue-2.svg';\r\n// ...\r\nimport diceRed01 from './assets/dice-red-1.svg';\r\nimport diceRed02 from './assets/dice-red-2.svg';\r\n// ...\r\n\r\nconst DICE_IMAGES = {\r\nblue: [diceBlue01, diceBlue02],\r\nred: [diceRed01, diceRed02],\r\n};\r\n\r\nfunction Dice(props) {\r\nconst src = DICE_IMAGES[props.color][props.num - 1];\r\nconst alt = `${props.color} ${props.num}`;\r\nreturn <img src={src} alt={alt} />;\r\n}\r\n\r\nexport default Dice;\r\n참고로, 이렇게 props가 객체 형태를 띠고 있으니 Destructuring 문법을 활용해서 조금 더 간결하게 코드를 작성할 수도 있겠죠?\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\nimport diceBlue02 from './assets/dice-blue-2.svg';\r\n// ...\r\nimport diceRed01 from './assets/dice-red-1.svg';\r\nimport diceRed02 from './assets/dice-red-2.svg';\r\n// ...\r\n\r\nconst DICE_IMAGES = {\r\nblue: [diceBlue01, diceBlue02],\r\nred: [diceRed01, diceRed02],\r\n};\r\n\r\nfunction Dice({ color = 'blue', num = 1 }) {\r\nconst src = DICE_IMAGES[color][num - 1];\r\nconst alt = `${color} ${num}`;\r\nreturn <img src={src} alt={alt} />;\r\n}\r\n\r\nexport default Dice;\r\nChildren\r\nprops에는 children이라는 조금 특별한 프로퍼티(prop, 프롭)가 있습니다.\r\n\r\nJSX 문법으로 컴포넌트를 작성할 때 컴포넌트를 단일 태그가 아니라 여는 태그와 닫는 태그의 형태로 작성하면, 그 안에 작성된 코드가 바로 이 children 값에 담기게 됩니다.\r\n\r\nButton.js\r\n\r\nfunction Button({ children }) {\r\nreturn <button>{children}</button>;\r\n}\r\n\r\nexport default Button;\r\nApp.js\r\n\r\nimport Button from './Button';\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<div>\r\n<Button>던지기</Button>\r\n<Button>처음부터</Button>\r\n</div>\r\n<Dice color=\"red\" num={2} />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\n그래서 JSX 문법으로 컴포넌트를 작성할 때 어떤 정보를 전달할 때는 일반적인 props의 속성값을 주로 활용하고, 화면에 보여질 모습을 조금 더 직관적인 코드로 작성하고자 할 때 children 값을 활용할 수가 있습니다.\r\n\r\n참고로 이 children을 활용하면 단순히 텍스트만 작성하는 걸 넘어서 컴포넌트 안에 컴포넌트를 작성할 수도 있고, 컴포넌트 안에 복잡한 태그들을 더 작성할 수도 있다.\r\n","excerpt":"JSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다. Props는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 …","fields":{"slug":"/React-stydy_3/"},"frontmatter":{"date":"Aug 22, 2021","title":"React Props 문법","tags":["react"],"update":"Aug 22, 2021"}}},{"node":{"rawMarkdownBody":"\r\n리액트 엘리먼트\r\nJSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst element = <h1>안녕 리액트!</h1>;\r\nconsole.log(element);\r\nReactDOM.render(element, document.getElementById('root'));\r\n{\\$\\$typeof: Symbol(react.element), type: \"h1\", key: null, ref: null, props: {…}, …}\r\n이런 객체를 리액트 엘리먼트라고 부르는데요.\r\n\r\n이 리액트 엘리먼트를 ReactDOM.render 함수의 아규먼트로 전달하게 되면, 리액트가 객체 형태의 값을 해석해서 HTML 형태로 브라우저에 띄워주는 것이죠.\r\n\r\n리액트 엘리먼트는 리액트로 화면을 그려내는데 가장 기본적인 요소입니다.\r\n\r\n리액트 컴포넌트\r\n리액트 컴포넌트는 리액트 엘리먼트를 조금 더 자유롭게 다루기 위한 하나의 문법입니다.\r\n\r\n컴포넌트를 만드는 가장 간단한 방법은 자바스크립트의 함수를 활용하는 건데요.\r\n아래 코드에서 JSX 문법으로 작성된 하나의 요소를 리턴하는 Hello 함수가 바로 하나의 컴포넌트입니다.\r\n\r\n이렇게 요소를 컴포넌트로 작성하게 되면 다양한 장점들이 있는데,\r\n자세한 내용은 이후의 개념들을 하나씩 배워나가면서 차차 알아보도록 합시다!\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nfunction Hello() {\r\nreturn <h1>안녕 리액트</h1>;\r\n}\r\n\r\nconst element = (\r\n<>\r\n<Hello />\r\n<Hello />\r\n<Hello />\r\n</>\r\n);\r\n\r\nReactDOM.render(element, document.getElementById('root'));\r\n그리고 이렇게 컴포넌트를 작성하면,\r\n위 코드에서 element 변수 안의 JSX 코드에서 볼 수 있듯 컴포넌트 함수 이름을 통해 하나의 태그처럼 활용할 수가 있습니다.\r\n\r\n이런 특성을 모듈 문법으로 활용하면 훨씬 더 독립적으로 컴포넌트 특성에 집중해서 코드를 작성할 수가 있습니다.\r\n\r\n예시: Dice.js\r\n\r\nimport diceBlue01 from './assets/dice-blue-1.svg';\r\n\r\nfunction Dice() {\r\nreturn <img src={diceBlue01} alt=\"주사위\" />;\r\n}\r\n\r\nexport default Dice;\r\n예시: App.js\r\n\r\nimport Dice from './Dice';\r\n\r\nfunction App() {\r\nreturn (\r\n\r\n<div>\r\n<Dice />\r\n</div>\r\n);\r\n}\r\n\r\nexport default App;\r\n한 가지 주의해야 할 부분은, 리액트 컴포넌트의 이름은 반드시 첫 글자를 대문자로 작성해야 한다는 것입니다.\r\n컴포넌트 이름의 첫 글자가 소문자라면 오류가 발생하니깐 꼭 주의!\r\n","excerpt":"리액트 엘리먼트\nJSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다. import ReactDOM from 'react-dom'; const element = 안녕 리액트!;\nconsole.log(element);\nReactDOM.r…","fields":{"slug":"/React-study_2/"},"frontmatter":{"date":"Aug 21, 2021","title":"React commponent 문법","tags":["react"],"update":"Aug 21, 2021"}}},{"node":{"rawMarkdownBody":"\r\nJSX란?\r\nJSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(<h1>안녕 리액트!</h1>, document.getElementById('root'));\r\nJSX 문법\r\nJSX는 자바스크립트로 HTML과 같은 문법을 사용할 수 있도록 만들어주는 편리한 문법이지만, 그만큼 꼭 지켜야 할 규칙들도 있습니다.\r\n\r\nHTML과 다른 속성명\r\n\r\n1. 속성명은 카멜 케이스로 작성하기!\r\n   JSX 문법에서도 태그에 속성을 지정해 줄 수 있습니다. 단, 여러 단어가 조합된 몇몇 속성들을 사용할 때는 반드시 카멜 케이스(Camel Case)로 작성해야 합니다.\r\n   사실 여러 단어가 조합된 HTML 속성들이 많진 않지만, 예를 들면 onclick, onblur, onfocus 등과 같은 이벤트 속성이나, tabindex 같은 속성들이 있습니다.\r\n   이런 속성들은 모두 onClick, onBlur, onFocus, onMouseDown, onMouseOver, tabIndex 처럼 작성하는 것이죠!\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n<button onClick= ... >클릭!</button>,\r\ndocument.getElementById('root')\r\n);\r\n단, 예외적으로 HTML에서 비표준 속성을 다룰 때 활용하는 data-\\* 속성은 카멜 케이스(Camel Case)가 아니라 기존의 HTML 문법 그대로 작성하셔야 합니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <div>\r\n    상태 변경: \r\n    <button className=\"btn\" data-status=\"대기중\">대기중</button>\r\n    <button className=\"btn\" data-status=\"진행중\">진행중</button>\r\n    <button className=\"btn\" data-status=\"완료\">완료</button>\r\n  </div>,\r\n  document.getElementById('root')\r\n);\r\n2. 자바스크립트 예약어와 같은 속성명은 사용할 수 없다!\r\nJSX 문법도 결국은 자바스크립트 문법이기 때문에, for나 class처럼 자바스크립트의 문법에 해당하는 예약어와 똑같은 이름의 속성명은 사용할 수 없습니다.\r\n그래서 HTML의 for의 경우에는 자바스크립트의 반복문 키워드 for와 겹치기 때문에 htmlFor로, HTML의 class 속성도 자바스크립트의 클래스 키워드 class와 겹치기 때문에 className으로 작성해 주어야 합니다.\r\n\r\nReact 공식 문서 - 어트리뷰트의 차이\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <form>\r\n    <label htmlFor=\"name\">이름</label>\r\n    <input id=\"name\" className=\"name-input\" type=\"text\" />\r\n  </form>,\r\n  document.getElementById('root')\r\n);\r\n반드시 하나의 요소로 감싸기 - Fragment\r\nJSX 문법을 활용할 때는 반드시 하나의 요소로 감싸주어야 합니다. 그래서 아래 코드처럼 여러 개의 요소를 작성하면 오류가 발생하는데요.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <p>안녕</p>\r\n  <p>리액트!</p>,\r\n  document.getElementById('root')\r\n);\r\n이럴 때는 아래 코드처럼 여러 태그를 감싸는 부모 태그를 만들어 하나의 요소로 만들어 주어야 합니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n\r\n  <div>\r\n    <p>안녕</p>\r\n    <p>리액트!</p>\r\n  </div>,\r\n  document.getElementById('root')\r\n);\r\n하지만 이렇게 작성한다면 때로는 꼭 필요하지 않은 부모 태그가 작성될 수 있겠죠? 그럴 땐 Fragment로 감싸주면 의미 없는 부모 태그를 만들지 않아도 여러 요소를 작성할 수 있습니다.\r\n\r\nimport { Fragment } from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n<Fragment>\r\n\r\n<p>안녕</p>\r\n<p>리액트!</p>\r\n</Fragment>,\r\ndocument.getElementById('root')\r\n);\r\n참고로 Fragment는 아래 코드처럼 빈 태그로 감싸는 단축 문법으로 활용할 수도 있습니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n<>\r\n\r\n<p>안녕</p>\r\n<p>리액트!</p>\r\n</>,\r\ndocument.getElementById('root')\r\n);\r\n자바스크립트 표현식 넣기\r\nJSX 문법에서 중괄호({})를 활용하면 자바스크립트 표현식을 넣을 수 있습니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst product = '맥북';\r\n\r\nReactDOM.render(\r\n\r\n  <h1>나만의 {product} 주문하기</h1>,\r\n  document.getElementById('root')\r\n);\r\n이런 부분들을 잘 활용하면, 아래 코드처럼 중괄호 안에서 문자열을 조합할 수도 있고 변수에 이미지 주소를 할당해서 img 태그의 src 속성값을 전달해 줄 수도 있고, 이벤트 핸들러를 좀 더 편리하게 등록할 수도 있습니다.\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst product = 'MacBook';\r\nconst model = 'Air';\r\nconst imageUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/MacBook_with_Retina_Display.png/500px-MacBook_with_Retina_Display.png'\r\n\r\nfunction handleClick(e) {\r\nalert('곧 도착합니다!');\r\n}\r\n\r\nReactDOM.render(\r\n<>\r\n\r\n<h1>{product + ' ' + model} 주문하기</h1>\r\n<img src={imageUrl} alt=\"제품 사진\" />\r\n<button onClick={handleClick}>확인</button>\r\n</>,\r\ndocument.getElementById('root')\r\n);\r\n단, JSX 문법에서 중괄호는 자바스크립트 표현식을 다룰 때 활용하기 때문에, 중괄호 안에서 for, if문 등의 문장은 다룰 수 없다는 점은 꼭 기억해 주세요.\r\n그런데도 만약 JSX 문법을 활용할 때 조건문이 꼭 필요하다면 조건 연산자를, 반복문이 꼭 필요하다면 배열의 반복 메소드를 활용하자.\r\n","excerpt":"JSX란?\nJSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다. import ReactDOM from 'react-do…","fields":{"slug":"/React-study_1/"},"frontmatter":{"date":"Aug 20, 2021","title":"React JSX 문법","tags":["react"],"update":"Aug 20, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)\r\ngit blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력\r\ngit revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성\r\n","excerpt":"git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)\ngit blame : 특정 파…","fields":{"slug":"/Git-study_5/"},"frontmatter":{"date":"Aug 17, 2021","title":"Git 협업하기 정리 노트","tags":["git"],"update":"Aug 17, 2021"}}},{"node":{"rawMarkdownBody":"\r\nGit 써보기\r\ngit init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\r\ngit config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)\r\ngit config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)\r\ngit add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기\r\ngit add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit reset [파일 이름] : staging area에 올렸던 파일 다시 내리기\r\ngit status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)\r\ngit commit -m \"커밋 메시지\" : 현재 staging area에 있는 것들 커밋으로 남기기\r\ngit help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력\r\n\r\nGitHub 시작하기\r\ngit push -u(또는 --set-upstream) origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.\r\ngit push : 위의 커맨드를 한번 실행하고 난 후에는 git push라고만 쳐도 로컬 레포지토리의 내용을 리모트 레포지토리에 올릴 수 있습니다.\r\ngit pull : 바로 위의 위에 있는 커맨드를 한번 실행하고 난 후에는 git pull이라고만 쳐도 리모트 레포지토리의 내용을 로컬 레포지토리로 가져옵니다.\r\ngit clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기\r\n\r\nGit에서 커밋 다루기\r\ngit log : 커밋 히스토리를 출력\r\ngit log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.\r\ngit show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인\r\ngit commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦\r\ngit config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로는 별명으로도 해당 커맨드를 실행할 수 있게 설정\r\ngit diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교\r\ngit reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)\r\n(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)\r\n\r\n    \t(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)\r\n\r\n    \t(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)\r\n\r\n    \t그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨\r\n\r\ngit tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임\r\n\r\nGit에서 브랜치 사용하기\r\ngit branch [새 브랜치 이름] : 새로운 브랜치를 생성\r\ngit checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동\r\ngit branch -d [기존 브랜치 이름] : 브랜치 삭제\r\ngit checkout [기존 브랜치 이름] : 그 브랜치로 이동\r\ngit merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지\r\ngit merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감\r\n\r\nGit 실전 I\r\ngit fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)\r\ngit blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력\r\ngit revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성\r\n\r\nGit 실전 Ⅱ\r\ngit reflog : HEAD가 그동안 가리켜왔던 커밋들의 기록을 출력\r\ngit log --all --graph : 모든 브랜치의 커밋 히스토리를, 커밋 간의 관계가 잘 드러나도록 그래프 형식으로 출력\r\ngit rebase [브랜치 이름] : A, B 브랜치가 있는 상태에서 지금 HEAD가 A 브랜치를 가리킬 때, git rebase B를 실행하면 A, B 브랜치가 분기하는 시작점이 된 공통 커밋 이후로부터 존재하는 A 브랜치 상의 커밋들이 그대로 B 브랜치의 최신 커밋 이후로 이어붙여짐(git merge와 같은 효과를 가지지만 커밋 히스토리가 한 줄로 깔끔하게 된다는 차이점이 있음)\r\ngit stash : 현재 작업 내용을 스택 영역에 저장\r\ngit stash apply [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용\r\ngit stash drop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 스택에서 삭제\r\ngit stash pop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용하면서 스택에서 삭제\r\ngit cherry-pick [커밋 아이디] : 특정 커밋의 내용을 현재 커밋에 반영\r\n! 그 밖에 알아야할 사실\r\n\r\n(1) git commit이라고만 쓰고 실행하면 커밋 메시지를 입력할 수 있는 텍스트 에디터 창이 뜹니다. 거기서 커밋 메시지를 입력하고 저장하고 나면 커밋이 이루어집니다.\r\n\r\n(2) git push와 git pull은 그 작업 단위가 브랜치입니다. 예를 들어, master 브랜치에서 git push를 하면 master 브랜치의 내용만 리모트 레포지토리의 master 브랜치로 전송되지, premium 브랜치의 내용이 전송되는 것은 아닙니다.(git push에 --all이라는 옵션을 주면 모든 브랜치의 내용을 전송할 수 있기는 합니다.)\r\n","excerpt":"Git 써보기\ngit init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\ngit config user.name 'codeit' : 현재 사용자의 …","fields":{"slug":"/Git-study_6/"},"frontmatter":{"date":"Aug 17, 2021","title":"Git 내용 총정리 노트","tags":["git"],"update":"Aug 17, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit branch [새 브랜치 이름] : 새로운 브랜치를 생성\r\ngit checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동\r\ngit branch -d [기존 브랜치 이름] : 브랜치 삭제\r\ngit checkout [기존 브랜치 이름] : 그 브랜치로 이동\r\ngit merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지\r\ngit merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감\r\n","excerpt":"git branch 새 브랜치 이름 : 새로운 브랜치를 생성\ngit checkout -b 새 브랜치 이름 : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동\ngit branch -d 기존 브랜치 이름 : 브랜치 삭제\ngit checkout 기존 브랜…","fields":{"slug":"/Git-study_4/"},"frontmatter":{"date":"Aug 17, 2021","title":"branch 정리 노트","tags":["git"],"update":"Aug 17, 2021"}}},{"node":{"rawMarkdownBody":"\r\n오늘의 느낀점..github에서 저장소 생성할시에 readme 파일 생성하는건 잘생각하고 하자...\r\n","excerpt":"오늘의 느낀점..github에서 저장소 생성할시에 readme 파일 생성하는건 잘생각하고 하자...","fields":{"slug":"/first-post/"},"frontmatter":{"date":"Aug 16, 2021","title":"Blog test","tags":["undefined"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\r\ngit config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)\r\ngit config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)\r\ngit add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기\r\ngit add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기\r\ngit reset [파일 이름] : staging area에 올렸던 파일 다시 내리기\r\ngit status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)\r\ngit commit -m \"커밋 메시지\" : 현재 staging area에 있는 것들 커밋으로 남기기\r\ngit help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력\r\n","excerpt":"git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성\ngit config user.name 'codeit' : 현재 사용자의 아이디를 'co…","fields":{"slug":"/Git-study_1/"},"frontmatter":{"date":"Aug 16, 2021","title":"Git 써보기 정리 노트","tags":["git"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit log : 커밋 히스토리를 출력\r\ngit log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.\r\ngit show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인\r\ngit commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦\r\ngit config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로 별명으로 해당 커맨드를 실행할 수 있도록 설정\r\ngit diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교\r\ngit reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)\r\n(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)\r\n\r\n    \t(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)\r\n\r\n    \t(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)\r\n\r\n    \t그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨\r\n\r\ngit tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임\r\n","excerpt":"git log : 커밋 히스토리를 출력\ngit log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 …","fields":{"slug":"/Git-study_3/"},"frontmatter":{"date":"Aug 16, 2021","title":"commit 정리 노트","tags":["git"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\ngit push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.\r\ngit push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기\r\ngit pull : 리모트 레포지토리의 내용을 로컬 레포지토리로 가져오기\r\ngit clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기\r\n","excerpt":"git push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.\ngit push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기\ngit pull : 리모트 레포지토리의 내용을 로컬 …","fields":{"slug":"/Git-study_2/"},"frontmatter":{"date":"Aug 16, 2021","title":"GitHub 시작하기 정리 노트","tags":["git"],"update":"Aug 16, 2021"}}},{"node":{"rawMarkdownBody":"\r\n![](screenshot.png)\r\n\r\n이미지 파일이 첨부된 게시물의 예제입니다.\r\n\r\n폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다.\r\n\r\n게시물 파일명은 index.md 로 합니다.\r\n\r\n이미지 파일은 폴더 내에 위치시킵니다.\r\n\r\n자세한 가이드는 [Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 확인해주세요.\r\n","excerpt":"이미지 파일이 첨부된 게시물의 예제입니다. 폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다. 게시물 파일명은 index.md 로 합니다. 이미지 파일은 폴더 내에 위치시킵니다. 자세한 가이드는 Documents를 확인해주세요.","fields":{"slug":"/image-post-example.md/"},"frontmatter":{"date":"Mar 24, 1991","title":"Image, 이미지 게시물 예제","tags":["undefined"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}