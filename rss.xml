<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Dev.seungwon Jang | Feed]]></title><description><![CDATA[seungwon Jang's Development Blog]]></description><link>https://nicorobinv.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 31 Aug 2021 15:26:27 GMT</lastBuildDate><item><title><![CDATA[React 배포하기]]></title><description><![CDATA[명령어 복습하기 프로젝트 생성하기
npm init react-app .
터미널에서 원하는 디렉토리에 들어가서 npm init react-app .를 입력하면 현재 디렉토리에 리액트 프로젝트를 생성합니다. 개발 모드 실행하기
npm start (npm…]]></description><link>https://nicorobinv.github.io/React-study_6/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_6/</guid><pubDate>Wed, 01 Sep 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;명령어 복습하기&lt;/p&gt;
&lt;p&gt;프로젝트 생성하기
npm init react-app .
터미널에서 원하는 디렉토리에 들어가서 npm init react-app .를 입력하면 현재 디렉토리에 리액트 프로젝트를 생성합니다.&lt;/p&gt;
&lt;p&gt;개발 모드 실행하기
npm start (npm run start)
터미널에서 npm run start를 입력하면 개발 모드 서버가 실행됩니다.&lt;/p&gt;
&lt;p&gt;실행 중인 서버 종료하기
ctrl + c
서버가 실행 중인 터미널에서 ctrl + c를 입력하면 서버가 종료됩니다.&lt;/p&gt;
&lt;p&gt;개발된 프로젝트 빌드하기
npm run build
터미널에서 npm run build를 입력하면 빌드를 시작합니다.&lt;/p&gt;
&lt;p&gt;빌드한 것 로컬에서 실행하기
npx serve build
터미널에서 npx serve build를 입력하면 serve 프로그램을 다운 받고 build 폴더에서 서버가 실행됩니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React 디자인 적용하는 방법과 팁]]></title><description><![CDATA[사실 CSS 파일을 불러오거나 이미지 파일을 불러오는 기능은 리액트 고유의 기능이 아니라 Create React App이라는 프로그램이 대신 설정해 준 기능입니다. (참고: Create React App 문서) 클래스네임을 좀 더 편리하게 쓰는 방법…]]></description><link>https://nicorobinv.github.io/React-study_5/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_5/</guid><pubDate>Tue, 24 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;사실 CSS 파일을 불러오거나 이미지 파일을 불러오는 기능은 리액트 고유의 기능이 아니라 Create React App이라는 프로그램이 대신 설정해 준 기능입니다. (참고: Create React App 문서)&lt;/p&gt;
&lt;p&gt;클래스네임을 좀 더 편리하게 쓰는 방법&lt;/p&gt;
&lt;p&gt;디자인을 적용하는 방법
이미지 불러오기
이미지 파일은 import 구문을 통해 불러오고, 불러온 이미지 주소를 src 속성으로 사용하면 됩니다.&lt;/p&gt;
&lt;p&gt;import diceImg from &apos;./assets/dice.png&apos;;&lt;/p&gt;
&lt;p&gt;function Dice() {
return &lt;img src={diceImg} alt=&quot;주사위 이미지&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default App;
인라인 스타일
리액트에서 인라인 스타일은 문자열이 아닌 객체형으로 사용합니다. 프로퍼티 이름은 CSS 속성 이름으로, 프로퍼티 값은 CSS 속성 값으로 쓰는데요, 이때 프로퍼티 이름은 아래의 boarderRadius 처럼 대시 기호 없이 카멜 케이스로 써야 한다는 점도 꼭 기억해두세요.&lt;/p&gt;
&lt;p&gt;import diceImg from &apos;./assets/dice.png&apos;;&lt;/p&gt;
&lt;p&gt;const style = {
borderRadius: &apos;50%&apos;,
width: &apos;120px&apos;,
height: &apos;120px&apos;,
};&lt;/p&gt;
&lt;p&gt;function Dice() {
return &lt;img style={style} src={diceImg} alt=&quot;주사위 이미지&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default App;
CSS 파일 불러오기
import 구문으로 파일을 불러올 수 있는데요, 이때 from 키워드 없이 쓰면 됩니다.&lt;/p&gt;
&lt;p&gt;import diceImg from &apos;./assets/dice.png&apos;;
import &apos;./Dice.css&apos;;&lt;/p&gt;
&lt;p&gt;function Dice() {
return &lt;img src={diceImg} alt=&quot;주사위 이미지&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default App;
클래스네임 사용하기
CSS 파일에 정의된 클래스명을 className prop에 문자열로 넣어주면 됩니다. 이때 재사용성을 위해 className prop을 부모 컴포넌트에서 받으면 더 좋습니다.&lt;/p&gt;
&lt;p&gt;import diceImg from &apos;./assets/dice.png&apos;;
import &apos;./Dice.css&apos;;&lt;/p&gt;
&lt;p&gt;function Dice({ className = &apos;&apos; }) {
const classNames = &lt;code class=&quot;language-text&quot;&gt;Dice ${className}&lt;/code&gt;;
return &lt;img className={classNames} src={diceImg} alt=&quot;주사위 이미지&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default App;
편리하게 클래스네임을 쓰는 방법
앞에서는 여러 className을 템플릿 문자열로 합쳐서 사용했습니다. 몇 개 없을 때는 상관없지만, 개수가 늘어날수록 아래처럼 알아보기 힘들어진다는 문제점이 있는데요.&lt;/p&gt;
&lt;p&gt;템플릿 문자열을 사용한 예
function Button({ isPending, color, size, invert, children }) {
const classNames = &lt;code class=&quot;language-text&quot;&gt;Button ${isPending ? &amp;#39;pending&amp;#39; : &amp;#39;&amp;#39;} ${color} ${size} ${invert ? &amp;#39;invert&amp;#39; : &amp;#39;&amp;#39;}&lt;/code&gt;;
return &lt;button className={classNames}&gt;{children}&lt;/button&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Button;
배열을 사용한 예
function Button({ isPending, color, size, invert, children }) {
const classNames = [
&apos;Button&apos;,
isPending ? &apos;pending&apos; : &apos;&apos;,
color,
size,
invert ? &apos;invert&apos; : &apos;&apos;,
].join(&apos;&apos;);
return &lt;button className={classNames}&gt;{children}&lt;/button&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Button;
위 예시 코드처럼 지저분하게 느껴지고, 매번 반복되는 코드를 작성한다는 번거로움이 있습니다. 개발자들은 이럴 때 라이브러리라는 걸 쓰는데요, 다른 개발자가 미리 만들어 놓은 코드를 이용해서 편하게 개발하는 겁니다.&lt;/p&gt;
&lt;p&gt;클래스네임의 경우에도 편리하게 사용할 수 있는 라이브러리가 많이 있는데요, 그중에서도 이번에 소개할 라이브러리는 바로 classnames라는 라이브러리입니다. 아래 예시 코드를 보시면 아시겠지만, 클래스네임에만 집중할 수 있어 훨씬 읽기 편해집니다. 이렇게 적절한 라이브러리를 쓰면 개발 생산성이 굉장히 좋아지죠.&lt;/p&gt;
&lt;p&gt;classnames 라이브러리를 사용한 예
import classNames from &apos;classnames&apos;;&lt;/p&gt;
&lt;p&gt;function Button({ isPending, color, size, invert, children }) {
return (
&amp;#x3C;button
className={classNames(
&apos;Button&apos;,
isPending &amp;#x26;&amp;#x26; &apos;pending&apos;,
color,
size,
invert &amp;#x26;&amp;#x26; &apos;invert&apos;,
)}&gt;
{ children }
&lt;/button &gt;
);
}&lt;/p&gt;
&lt;p&gt;export default Button;
classnames 은 NPM이라는 프로그램을 통해 설치할 수 있습니다. 터미널에서 npm install classnames 을 입력하고 설치한 다음에, 위 예시처럼 import 로 불러와서 사용하면 됩니다. NPM 저장소 사이트로 들어가면 사용 방법과 설명이 나와있음.&lt;/p&gt;
&lt;p&gt;NPM classnames 패키지: &lt;a href=&quot;https://www.npmjs.com/package/classnames&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://www.npmjs.com/package/classnames&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React state 정리하기]]></title><description><![CDATA[State
state는 리액트에서 화면을 그려내는 데 굉장히 중요한 역할을 합니다. State라는 단어는 한국어로 '상태'라는 뜻이 있는데요. 리액트에서의 state도 그 의미가 다르지 않습니다. 상태가 바뀔 때마다 화면을 새롭게 그려내는 방식으로 …]]></description><link>https://nicorobinv.github.io/React-study_4/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_4/</guid><pubDate>Mon, 23 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;State
state는 리액트에서 화면을 그려내는 데 굉장히 중요한 역할을 합니다.&lt;/p&gt;
&lt;p&gt;State라는 단어는 한국어로 &apos;상태&apos;라는 뜻이 있는데요. 리액트에서의 state도 그 의미가 다르지 않습니다.&lt;/p&gt;
&lt;p&gt;상태가 바뀔 때마다 화면을 새롭게 그려내는 방식으로 동작을 하는 것이죠.&lt;/p&gt;
&lt;p&gt;리액트에서 state를 만들고, state를 바꾸기 위해서는 일단 useState라는 함수를 활용해야 합니다.&lt;/p&gt;
&lt;p&gt;import { useState } from &apos;react&apos;;&lt;/p&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;p&gt;const [num, setNum] = useState(1);&lt;/p&gt;
&lt;p&gt;// ...
보통 이렇게 Destructuring 문법으로 작성하는데요. useState 함수가 초깃값을 아규먼트로 받고 그에 따른 실행 결과로 요소 2개를 가진 배열의 형태로 리턴을 하기 때문입니다.&lt;/p&gt;
&lt;p&gt;이때 첫 번째 요소가 바로 state이고, 두 번째 요소가 이 state를 바꾸는 setter 함수인데요.&lt;/p&gt;
&lt;p&gt;참고로 위 코드에서도 볼 수 있듯 첫 번째 변수는 원하는 state의 이름(num)을 지어주고, 두 번째 변수에는 state 이름 앞에 set을 붙인 다음 카멜 케이스로 이름을 지어주는 것(setNum)이 일반적입니다.&lt;/p&gt;
&lt;p&gt;state는 변수에 새로운 값을 할당하는 방식으로 변경하는 것이 아니라 이 setter 함수를 활용해야 하는데요. setter 함수는 호출할 때 전달하는 아규먼트 값으로 state 값을 변경해 줍니다.&lt;/p&gt;
&lt;p&gt;그래서 아래 코드처럼 setter 함수를 활용해서 이벤트 핸들러를 등록해두면, 이벤트가 발생할 때마다 상태가 변하면서 화면이 새로 그려지는 것이죠!&lt;/p&gt;
&lt;p&gt;import { useState } from &apos;react&apos;;
import Button from &apos;./Button&apos;;
import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
const [num, setNum] = useState(1);&lt;/p&gt;
&lt;p&gt;const handleRollClick = () =&gt; {
setNum(3); // num state를 3으로 변경!
};&lt;/p&gt;
&lt;p&gt;const handleClearClick = () =&gt; {
setNum(1); // num state를 1로 변경!
};&lt;/p&gt;
&lt;p&gt;return (&lt;/p&gt;
&lt;div&gt;
&lt;Button onClick={handleRollClick}&gt;던지기&lt;/Button&gt;
&lt;Button onClick={handleClearClick}&gt;처음부터&lt;/Button&gt;
&lt;Dice color=&quot;red&quot; num={num} /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
참조형 State
자바스크립트의 자료형은 크게 기본형(Primitive type)과 참조형(Reference type)로 나눌 수 있다는 사실, 모두 알고 계시죠?&lt;/p&gt;
&lt;p&gt;특히 참조형 값들은 조금 독특한 특성을 가지고 있어서 변수로 다룰 때도 조금 주의해야 할 부분들이 있었는데요. state를 활용할 때도 마찬가지입니다!&lt;/p&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;p&gt;const [gameHistory, setGameHistory] = useState([]);&lt;/p&gt;
&lt;p&gt;const handleRollClick = () =&gt; {
const nextNum = random(6);
gameHistory.push(nextNum);
setGameHistory(gameHistory); // state가 제대로 변경되지 않는다!
};&lt;/p&gt;
&lt;p&gt;// ...
위 코드에서 볼 수 있듯 배열 값을 가진 gameHistory에 push 메소드를 이용해서 배열의 값을 변경한 다음, 변경된 배열을 setter 함수로 state를 변경하려고 하면 코드가 제대로 동작하지 않습니다.&lt;/p&gt;
&lt;p&gt;gameHistory state는 배열 값 자체를 가지고 있는 게 아니라 그 배열의 주솟값을 참조하고 있는 건데요. 때문에 push 메소드로 배열 안에 요소를 변경했다고 하더라도 결과적으로 참조하는 배열의 주솟값은 변경된 것이 아니게 됩니다.&lt;/p&gt;
&lt;p&gt;결과적으로 리액트 입장에서는 gameHistory state가 참조하는 주솟값은 여전히 똑같기 때문에 상태(state)가 바뀌었다고 판단하지 않는 것이죠!&lt;/p&gt;
&lt;p&gt;그래서 참조형 state를 활용할 때는 반드시 새로운 참조형 값을 만들어 state를 변경해야 합니다.&lt;/p&gt;
&lt;p&gt;가장 간단한 방법은 Spread 문법(...) 을 활용하는 것이겠죠?&lt;/p&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;p&gt;const [gameHistory, setGameHistory] = useState([]);&lt;/p&gt;
&lt;p&gt;const handleRollClick = () =&gt; {
const nextNum = random(6);
setGameHistory([...gameHistory, nextNum]); // state가 제대로 변경된다!
};&lt;/p&gt;
&lt;p&gt;// ...
이 참조형 state의 특성을 이해하지 못하면, 간혹 state가 제대로 변경되지 않는 버그가 발생했을 때 원인을 제대로 찾지 못하는 경우가 발생할 수도 있는데요.&lt;/p&gt;
&lt;p&gt;참조형 state를 활용할 땐 반드시 새로운 참조형 값을 만들어서 state를 변경해야 한다는 점.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Props 문법]]></title><description><![CDATA[JSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다. Props는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 …]]></description><link>https://nicorobinv.github.io/React-study_3/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_3/</guid><pubDate>Sun, 22 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다.&lt;/p&gt;
&lt;p&gt;Props는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 모여서 컴포넌트를 정의한 함수의 첫 번째 파라미터로 전달됩니다.&lt;/p&gt;
&lt;p&gt;App.js&lt;/p&gt;
&lt;p&gt;import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;Dice color=&quot;blue&quot; /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
Dice.js&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;&lt;/p&gt;
&lt;p&gt;function Dice(props) {
console.log(props)
return &lt;img src={diceBlue01} alt=&quot;주사위&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
위 코드들 처럼 App 함수에서 사용하는 Dice 컴포넌트에 color라는 속성을 blue로 지정해주고, Dice 함수 내부에서 props라는 파라미터를 하나 만들어 출력해보면 브라우저 콘솔에는 다음과 같은 출력 결과가 나타나게 됩니다.&lt;/p&gt;
&lt;p&gt;{ color: &quot;blue&quot; }
그래서 컴포넌트를 활용할 때 속성값을 다양하게 전달하고 이 props 값을 활용하면, 똑같은 컴포넌트라도 전달된 속성값에 따라 서로 다른 모습을 그려낼 수도 있게 됩니다.&lt;/p&gt;
&lt;p&gt;App.js&lt;/p&gt;
&lt;p&gt;import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;Dice color=&quot;red&quot; num={2} /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
Dice.js&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;
import diceBlue02 from &apos;./assets/dice-blue-2.svg&apos;;
// ...
import diceRed01 from &apos;./assets/dice-red-1.svg&apos;;
import diceRed02 from &apos;./assets/dice-red-2.svg&apos;;
// ...&lt;/p&gt;
&lt;p&gt;const DICE_IMAGES = {
blue: [diceBlue01, diceBlue02],
red: [diceRed01, diceRed02],
};&lt;/p&gt;
&lt;p&gt;function Dice(props) {
const src = DICE_IMAGES[props.color][props.num - 1];
const alt = &lt;code class=&quot;language-text&quot;&gt;${props.color} ${props.num}&lt;/code&gt;;
return &lt;img src={src} alt={alt} /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
참고로, 이렇게 props가 객체 형태를 띠고 있으니 Destructuring 문법을 활용해서 조금 더 간결하게 코드를 작성할 수도 있겠죠?&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;
import diceBlue02 from &apos;./assets/dice-blue-2.svg&apos;;
// ...
import diceRed01 from &apos;./assets/dice-red-1.svg&apos;;
import diceRed02 from &apos;./assets/dice-red-2.svg&apos;;
// ...&lt;/p&gt;
&lt;p&gt;const DICE_IMAGES = {
blue: [diceBlue01, diceBlue02],
red: [diceRed01, diceRed02],
};&lt;/p&gt;
&lt;p&gt;function Dice({ color = &apos;blue&apos;, num = 1 }) {
const src = DICE_IMAGES[color][num - 1];
const alt = &lt;code class=&quot;language-text&quot;&gt;${color} ${num}&lt;/code&gt;;
return &lt;img src={src} alt={alt} /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
Children
props에는 children이라는 조금 특별한 프로퍼티(prop, 프롭)가 있습니다.&lt;/p&gt;
&lt;p&gt;JSX 문법으로 컴포넌트를 작성할 때 컴포넌트를 단일 태그가 아니라 여는 태그와 닫는 태그의 형태로 작성하면, 그 안에 작성된 코드가 바로 이 children 값에 담기게 됩니다.&lt;/p&gt;
&lt;p&gt;Button.js&lt;/p&gt;
&lt;p&gt;function Button({ children }) {
return &lt;button&gt;{children}&lt;/button&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Button;
App.js&lt;/p&gt;
&lt;p&gt;import Button from &apos;./Button&apos;;
import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;Button&gt;던지기&lt;/Button&gt;
&lt;Button&gt;처음부터&lt;/Button&gt;
&lt;/div&gt;
&lt;Dice color=&quot;red&quot; num={2} /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
그래서 JSX 문법으로 컴포넌트를 작성할 때 어떤 정보를 전달할 때는 일반적인 props의 속성값을 주로 활용하고, 화면에 보여질 모습을 조금 더 직관적인 코드로 작성하고자 할 때 children 값을 활용할 수가 있습니다.&lt;/p&gt;
&lt;p&gt;참고로 이 children을 활용하면 단순히 텍스트만 작성하는 걸 넘어서 컴포넌트 안에 컴포넌트를 작성할 수도 있고, 컴포넌트 안에 복잡한 태그들을 더 작성할 수도 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React commponent 문법]]></title><description><![CDATA[리액트 엘리먼트
JSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다. import ReactDOM from 'react-dom'; const element = 안녕 리액트!;
console.log(element);
ReactDOM.r…]]></description><link>https://nicorobinv.github.io/React-study_2/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_2/</guid><pubDate>Sat, 21 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;리액트 엘리먼트
JSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다.&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;const element = &lt;h1&gt;안녕 리액트!&lt;/h1&gt;;
console.log(element);
ReactDOM.render(element, document.getElementById(&apos;root&apos;));
{$$typeof: Symbol(react.element), type: &quot;h1&quot;, key: null, ref: null, props: {…}, …}
이런 객체를 리액트 엘리먼트라고 부르는데요.&lt;/p&gt;
&lt;p&gt;이 리액트 엘리먼트를 ReactDOM.render 함수의 아규먼트로 전달하게 되면, 리액트가 객체 형태의 값을 해석해서 HTML 형태로 브라우저에 띄워주는 것이죠.&lt;/p&gt;
&lt;p&gt;리액트 엘리먼트는 리액트로 화면을 그려내는데 가장 기본적인 요소입니다.&lt;/p&gt;
&lt;p&gt;리액트 컴포넌트
리액트 컴포넌트는 리액트 엘리먼트를 조금 더 자유롭게 다루기 위한 하나의 문법입니다.&lt;/p&gt;
&lt;p&gt;컴포넌트를 만드는 가장 간단한 방법은 자바스크립트의 함수를 활용하는 건데요.
아래 코드에서 JSX 문법으로 작성된 하나의 요소를 리턴하는 Hello 함수가 바로 하나의 컴포넌트입니다.&lt;/p&gt;
&lt;p&gt;이렇게 요소를 컴포넌트로 작성하게 되면 다양한 장점들이 있는데,
자세한 내용은 이후의 개념들을 하나씩 배워나가면서 차차 알아보도록 합시다!&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;function Hello() {
return &lt;h1&gt;안녕 리액트&lt;/h1&gt;;
}&lt;/p&gt;
&lt;p&gt;const element = (
&amp;#x3C;&gt;
&lt;Hello /&gt;
&lt;Hello /&gt;
&lt;Hello /&gt;
&amp;#x3C;/&gt;
);&lt;/p&gt;
&lt;p&gt;ReactDOM.render(element, document.getElementById(&apos;root&apos;));
그리고 이렇게 컴포넌트를 작성하면,
위 코드에서 element 변수 안의 JSX 코드에서 볼 수 있듯 컴포넌트 함수 이름을 통해 하나의 태그처럼 활용할 수가 있습니다.&lt;/p&gt;
&lt;p&gt;이런 특성을 모듈 문법으로 활용하면 훨씬 더 독립적으로 컴포넌트 특성에 집중해서 코드를 작성할 수가 있습니다.&lt;/p&gt;
&lt;p&gt;예시: Dice.js&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;&lt;/p&gt;
&lt;p&gt;function Dice() {
return &lt;img src={diceBlue01} alt=&quot;주사위&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
예시: App.js&lt;/p&gt;
&lt;p&gt;import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;Dice /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
한 가지 주의해야 할 부분은, 리액트 컴포넌트의 이름은 반드시 첫 글자를 대문자로 작성해야 한다는 것입니다.
컴포넌트 이름의 첫 글자가 소문자라면 오류가 발생하니깐 꼭 주의!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React JSX 문법]]></title><description><![CDATA[JSX란?
JSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다. import ReactDOM from 'react-do…]]></description><link>https://nicorobinv.github.io/React-study_1/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_1/</guid><pubDate>Fri, 20 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JSX란?
JSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다.&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;h1&gt;안녕 리액트!&lt;/h1&gt;, document.getElementById(&apos;root&apos;));
JSX 문법
JSX는 자바스크립트로 HTML과 같은 문법을 사용할 수 있도록 만들어주는 편리한 문법이지만, 그만큼 꼭 지켜야 할 규칙들도 있습니다.&lt;/p&gt;
&lt;p&gt;HTML과 다른 속성명&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;속성명은 카멜 케이스로 작성하기!
JSX 문법에서도 태그에 속성을 지정해 줄 수 있습니다. 단, 여러 단어가 조합된 몇몇 속성들을 사용할 때는 반드시 카멜 케이스(Camel Case)로 작성해야 합니다.
사실 여러 단어가 조합된 HTML 속성들이 많진 않지만, 예를 들면 onclick, onblur, onfocus 등과 같은 이벤트 속성이나, tabindex 같은 속성들이 있습니다.
이런 속성들은 모두 onClick, onBlur, onFocus, onMouseDown, onMouseOver, tabIndex 처럼 작성하는 것이죠!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&lt;button onClick= ... &gt;클릭!&lt;/button&gt;,
document.getElementById(&apos;root&apos;)
);
단, 예외적으로 HTML에서 비표준 속성을 다룰 때 활용하는 data-* 속성은 카멜 케이스(Camel Case)가 아니라 기존의 HTML 문법 그대로 작성하셔야 합니다.&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;div&gt;
    상태 변경: 
    &lt;button className=&quot;btn&quot; data-status=&quot;대기중&quot;&gt;대기중&lt;/button&gt;
    &lt;button className=&quot;btn&quot; data-status=&quot;진행중&quot;&gt;진행중&lt;/button&gt;
    &lt;button className=&quot;btn&quot; data-status=&quot;완료&quot;&gt;완료&lt;/button&gt;
  &lt;/div&gt;,
  document.getElementById(&apos;root&apos;)
);
2. 자바스크립트 예약어와 같은 속성명은 사용할 수 없다!
JSX 문법도 결국은 자바스크립트 문법이기 때문에, for나 class처럼 자바스크립트의 문법에 해당하는 예약어와 똑같은 이름의 속성명은 사용할 수 없습니다.
그래서 HTML의 for의 경우에는 자바스크립트의 반복문 키워드 for와 겹치기 때문에 htmlFor로, HTML의 class 속성도 자바스크립트의 클래스 키워드 class와 겹치기 때문에 className으로 작성해 주어야 합니다.
&lt;p&gt;React 공식 문서 - 어트리뷰트의 차이&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;form&gt;
    &lt;label htmlFor=&quot;name&quot;&gt;이름&lt;/label&gt;
    &lt;input id=&quot;name&quot; className=&quot;name-input&quot; type=&quot;text&quot; /&gt;
  &lt;/form&gt;,
  document.getElementById(&apos;root&apos;)
);
반드시 하나의 요소로 감싸기 - Fragment
JSX 문법을 활용할 때는 반드시 하나의 요소로 감싸주어야 합니다. 그래서 아래 코드처럼 여러 개의 요소를 작성하면 오류가 발생하는데요.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;p&gt;안녕&lt;/p&gt;
  &lt;p&gt;리액트!&lt;/p&gt;,
  document.getElementById(&apos;root&apos;)
);
이럴 때는 아래 코드처럼 여러 태그를 감싸는 부모 태그를 만들어 하나의 요소로 만들어 주어야 합니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;안녕&lt;/p&gt;
    &lt;p&gt;리액트!&lt;/p&gt;
  &lt;/div&gt;,
  document.getElementById(&apos;root&apos;)
);
하지만 이렇게 작성한다면 때로는 꼭 필요하지 않은 부모 태그가 작성될 수 있겠죠? 그럴 땐 Fragment로 감싸주면 의미 없는 부모 태그를 만들지 않아도 여러 요소를 작성할 수 있습니다.
&lt;p&gt;import { Fragment } from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&lt;Fragment&gt;&lt;/p&gt;
&lt;p&gt;안녕&lt;/p&gt;
&lt;p&gt;리액트!&lt;/p&gt;
&lt;/Fragment&gt;,
document.getElementById(&apos;root&apos;)
);
참고로 Fragment는 아래 코드처럼 빈 태그로 감싸는 단축 문법으로 활용할 수도 있습니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&amp;#x3C;&gt;&lt;/p&gt;
&lt;p&gt;안녕&lt;/p&gt;
&lt;p&gt;리액트!&lt;/p&gt;
&lt;/&gt;,
document.getElementById(&apos;root&apos;)
);
자바스크립트 표현식 넣기
JSX 문법에서 중괄호({})를 활용하면 자바스크립트 표현식을 넣을 수 있습니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;const product = &apos;맥북&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;h1&gt;나만의 {product} 주문하기&lt;/h1&gt;,
  document.getElementById(&apos;root&apos;)
);
이런 부분들을 잘 활용하면, 아래 코드처럼 중괄호 안에서 문자열을 조합할 수도 있고 변수에 이미지 주소를 할당해서 img 태그의 src 속성값을 전달해 줄 수도 있고, 이벤트 핸들러를 좀 더 편리하게 등록할 수도 있습니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;const product = &apos;MacBook&apos;;
const model = &apos;Air&apos;;
const imageUrl = &apos;&lt;a href=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/MacBook_with_Retina_Display.png/500px-MacBook_with_Retina_Display.png&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/MacBook_with_Retina_Display.png/500px-MacBook_with_Retina_Display.png&lt;/a&gt;&apos;&lt;/p&gt;
&lt;p&gt;function handleClick(e) {
alert(&apos;곧 도착합니다!&apos;);
}&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&amp;#x3C;&gt;&lt;/p&gt;
&lt;h1&gt;{product + &apos; &apos; + model} 주문하기&lt;/h1&gt;
&lt;img src={imageUrl} alt=&quot;제품 사진&quot; /&gt;
&lt;button onClick={handleClick}&gt;확인&lt;/button&gt;
&lt;/&gt;,
document.getElementById(&apos;root&apos;)
);
단, JSX 문법에서 중괄호는 자바스크립트 표현식을 다룰 때 활용하기 때문에, 중괄호 안에서 for, if문 등의 문장은 다룰 수 없다는 점은 꼭 기억해 주세요.
그런데도 만약 JSX 문법을 활용할 때 조건문이 꼭 필요하다면 조건 연산자를, 반복문이 꼭 필요하다면 배열의 반복 메소드를 활용하자.</content:encoded></item><item><title><![CDATA[branch 정리 노트]]></title><description><![CDATA[git branch 새 브랜치 이름 : 새로운 브랜치를 생성
git checkout -b 새 브랜치 이름 : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
git branch -d 기존 브랜치 이름 : 브랜치 삭제
git checkout 기존 브랜…]]></description><link>https://nicorobinv.github.io/Git-study_4/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_4/</guid><pubDate>Tue, 17 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git branch [새 브랜치 이름] : 새로운 브랜치를 생성
git checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
git branch -d [기존 브랜치 이름] : 브랜치 삭제
git checkout [기존 브랜치 이름] : 그 브랜치로 이동
git merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지
git merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Git 내용 총정리 노트]]></title><description><![CDATA[Git 써보기
git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name 'codeit' : 현재 사용자의 …]]></description><link>https://nicorobinv.github.io/Git-study_6/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_6/</guid><pubDate>Tue, 17 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Git 써보기
git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name &apos;codeit&apos; : 현재 사용자의 아이디를 &apos;codeit&apos;으로 설정(커밋할 때 필요한 정보)
git config user.email &apos;teacher@codeit.kr&apos; : 현재 사용자의 이메일 주소를 &apos;teacher@codeit.kr&apos;로 설정(커밋할 때 필요한 정보)
git add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기
git add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기
git add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기
git reset [파일 이름] : staging area에 올렸던 파일 다시 내리기
git status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)
git commit -m &quot;커밋 메시지&quot; : 현재 staging area에 있는 것들 커밋으로 남기기
git help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력&lt;/p&gt;
&lt;p&gt;GitHub 시작하기
git push -u(또는 --set-upstream) origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.
git push : 위의 커맨드를 한번 실행하고 난 후에는 git push라고만 쳐도 로컬 레포지토리의 내용을 리모트 레포지토리에 올릴 수 있습니다.
git pull : 바로 위의 위에 있는 커맨드를 한번 실행하고 난 후에는 git pull이라고만 쳐도 리모트 레포지토리의 내용을 로컬 레포지토리로 가져옵니다.
git clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기&lt;/p&gt;
&lt;p&gt;Git에서 커밋 다루기
git log : 커밋 히스토리를 출력
git log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.
git show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인
git commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦
git config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로는 별명으로도 해당 커맨드를 실행할 수 있게 설정
git diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교
git reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)
(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;	(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)

	(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)

	그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;git tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임&lt;/p&gt;
&lt;p&gt;Git에서 브랜치 사용하기
git branch [새 브랜치 이름] : 새로운 브랜치를 생성
git checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
git branch -d [기존 브랜치 이름] : 브랜치 삭제
git checkout [기존 브랜치 이름] : 그 브랜치로 이동
git merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지
git merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감&lt;/p&gt;
&lt;p&gt;Git 실전 I
git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
git blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력
git revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성&lt;/p&gt;
&lt;p&gt;Git 실전 Ⅱ
git reflog : HEAD가 그동안 가리켜왔던 커밋들의 기록을 출력
git log --all --graph : 모든 브랜치의 커밋 히스토리를, 커밋 간의 관계가 잘 드러나도록 그래프 형식으로 출력
git rebase [브랜치 이름] : A, B 브랜치가 있는 상태에서 지금 HEAD가 A 브랜치를 가리킬 때, git rebase B를 실행하면 A, B 브랜치가 분기하는 시작점이 된 공통 커밋 이후로부터 존재하는 A 브랜치 상의 커밋들이 그대로 B 브랜치의 최신 커밋 이후로 이어붙여짐(git merge와 같은 효과를 가지지만 커밋 히스토리가 한 줄로 깔끔하게 된다는 차이점이 있음)
git stash : 현재 작업 내용을 스택 영역에 저장
git stash apply [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용
git stash drop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 스택에서 삭제
git stash pop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용하면서 스택에서 삭제
git cherry-pick [커밋 아이디] : 특정 커밋의 내용을 현재 커밋에 반영
! 그 밖에 알아야할 사실&lt;/p&gt;
&lt;p&gt;(1) git commit이라고만 쓰고 실행하면 커밋 메시지를 입력할 수 있는 텍스트 에디터 창이 뜹니다. 거기서 커밋 메시지를 입력하고 저장하고 나면 커밋이 이루어집니다.&lt;/p&gt;
&lt;p&gt;(2) git push와 git pull은 그 작업 단위가 브랜치입니다. 예를 들어, master 브랜치에서 git push를 하면 master 브랜치의 내용만 리모트 레포지토리의 master 브랜치로 전송되지, premium 브랜치의 내용이 전송되는 것은 아닙니다.(git push에 --all이라는 옵션을 주면 모든 브랜치의 내용을 전송할 수 있기는 합니다.)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Git 협업하기 정리 노트]]></title><description><![CDATA[git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
git blame : 특정 파…]]></description><link>https://nicorobinv.github.io/Git-study_5/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_5/</guid><pubDate>Tue, 17 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
git blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력
git revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Git 써보기 정리 노트]]></title><description><![CDATA[git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name 'codeit' : 현재 사용자의 아이디를 'co…]]></description><link>https://nicorobinv.github.io/Git-study_1/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_1/</guid><pubDate>Mon, 16 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name &apos;codeit&apos; : 현재 사용자의 아이디를 &apos;codeit&apos;으로 설정(커밋할 때 필요한 정보)
git config user.email &apos;teacher@codeit.kr&apos; : 현재 사용자의 이메일 주소를 &apos;teacher@codeit.kr&apos;로 설정(커밋할 때 필요한 정보)
git add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기
git add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기
git add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기
git reset [파일 이름] : staging area에 올렸던 파일 다시 내리기
git status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)
git commit -m &quot;커밋 메시지&quot; : 현재 staging area에 있는 것들 커밋으로 남기기
git help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력&lt;/p&gt;</content:encoded></item></channel></rss>