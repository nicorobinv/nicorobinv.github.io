<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Dev.seungwon Jang | Feed]]></title><description><![CDATA[seungwon Jang's Development Blog]]></description><link>https://nicorobinv.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 28 Sep 2021 13:10:25 GMT</lastBuildDate><item><title><![CDATA[javascript 어휘구조]]></title><description><![CDATA[자바스크립트 프로그램은 unicode 문자 집합을 사용해 작성된다. unicode는 ASCII나 Latin-1의 상위 집합이고 지구상에서 사용되는 대부분의 문자를 표현할 수 있다. 자바스크립트는 대소문자를 구분하는 언어다. 다시 말해 키워드, 변수,…]]></description><link>https://nicorobinv.github.io/javascript-study_1/</link><guid isPermaLink="false">https://nicorobinv.github.io/javascript-study_1/</guid><pubDate>Tue, 28 Sep 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트 프로그램은 unicode 문자 집합을 사용해 작성된다. unicode는 ASCII나 Latin-1의 상위 집합이고 지구상에서 사용되는 대부분의 문자를 표현할 수 있다.&lt;/p&gt;
&lt;p&gt;자바스크립트는 대소문자를 구분하는 언어다. 다시 말해 키워드, 변수, 함수 이름, 식별자들은 모두 항상 대소문자를 구분해 입력해야 한다. 그러나 HTML은 대소문자를 구별하지 않는다. HTML이 클라이언트 측 자바스크립트와 밀접한 연관이 있기 떄문에 이 점이 약한 혼동될 수 있다. 많은 클라이언트 측 자바스크립트 객체와 프로퍼티 이름은 HTML 태그나 태그 속성(attribute)의 이름과 동일하다. 그런데 HTML에서는 태그나 속성 이름을 대소문자 구분 없이 입력해도 되지만, 자바스크립트에서는 모두 소문자로 입력해야 한다.&lt;/p&gt;
&lt;p&gt;2.1.2 공백, 줄바꿈, 제어 문자
자바스크립트는 프로그램 코드 내의 토큰(토큰이란 프로그래밍 언어에서 더 이상 나눌수 없는 최소한의 단위이며, 키워드나 변수의 이름, 숫자 등이 여기에 해당한다.) 들 사이에 있는 공백들을 무시한다.&lt;/p&gt;
&lt;p&gt;2.2 주석&lt;/p&gt;
&lt;p&gt;자바스크ㅂ트는 두 가지 형태의 주석을 지원한다. //와 줄 끝 사이에 있는 텍스트는 모두 주석으로 취급되어 자바스크립트에 의해 무시된다. /_와 _/ 사이의 텍스트도 모두 주석으로 취급된다. 이때, 주석은 여러 줄에 걸쳐 나타날수 있지만 서로 중첩될 수 없다. 다음의 코드는 모두 올바른 자바스크립트 주석이다.&lt;/p&gt;
&lt;p&gt;// 한 줄짜리 주석
/_ 이것도 주석 _/ // 또 다른 주석/*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;또 다른 주석&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러 줄에 걸쳐 있다. */&lt;/p&gt;
&lt;p&gt;2.3 리터럴&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;리터럴(literal)은 프로그램에 직접 나타나는 데이터 값이다. 다음의 코드는 모두 리터럴이다.
12 // 숫자 12
1.2 // 숫자 1.2
&quot;hello world&quot; // 문자열
&apos;Hi&apos; // 다른 문자열
true // 불리언 값
false // 다른 불리언 값
/javascript/hi // &apos;정규 표현식&apos; 리터럴(패턴 매칭용)
null // 객체가 존재하지 않음&lt;/p&gt;
&lt;p&gt;배열이나 객체 리터럴을 위한 좀 더 복잡한 표션식도 지원한다. 예를 들어, 다음과 같다.
{ x:1, y:2 } // 객체 초기자
[1,2,3,4,5] // 배열 초기자&lt;/p&gt;
&lt;p&gt;2.4 식별자와 예약어&lt;/p&gt;
&lt;p&gt;식별자(identifier)는 간단히 말해 이름이다. 자바스크립트에서 식별자는 변수나 함수에 이름을 붙이거나 코드 내 반복문에서 쓸 레이블을 붙이는 데 사용된다. 자바스크립트 식별자의 시작은 알파벳, 밑줄(_) 혹은 달러($) 표시여야 한다. 이어지는 문자들은 알파벳이나 숫자, 밑줄 혹은 달러 표시여야 한다(식별자의 첫 글자로 숫자를 허용하지 않는 이유는 자바스크립트가 숫자와 식별자를 쉽게 구별하기 위함이다). 다음은 모두 올바른 식별자다.&lt;/p&gt;
&lt;p&gt;i
my&lt;em&gt;variable&lt;/em&gt;name
v13
_dummy
$str&lt;/p&gt;
&lt;p&gt;다른 언어와 마찬가지로, 자바스크립트에도 언어 내부적으로 사용할 용도로 예약된 식별자들이 있다. 이러한 &apos;예약어(reserved keyword)&apos;는 식별자(변수명, 함수명, 레이블)로 사용할 수 없다.&lt;/p&gt;
&lt;p&gt;2.4.1 예약어&lt;/p&gt;
&lt;p&gt;자바스크립트는 몇 가지 식별자를 미리 선점하고 있다. 다음은 프로그램 내에서 식별자로 사용할 수 없는 단어들이다.&lt;/p&gt;
&lt;p&gt;break delete function return typeof
case do if switch var
catct else in this void
continue false instanceof throw while
debugger finally new true with
default for null try
class const enum export extends import super&lt;/p&gt;
&lt;p&gt;또한, 보통 자바스크립트 코드에서는 식별자로 사용할 수 있지만, 엄격모드 (strict mode)에서는 사용할 수 없는 단어도 있다.&lt;/p&gt;
&lt;p&gt;implements let priviate public yield interface package protected static&lt;/p&gt;
&lt;p&gt;엄격모드에서는 아래의 식별자도 사용이 제한된다. 이 식별자들은 완전히 예약어는 아니지만 변수나 함수 혹은 매개변수 이름으로 사용할 수 없다.&lt;/p&gt;
&lt;p&gt;arguments eval&lt;/p&gt;
&lt;p&gt;자바스크립트는 다음과 같이 몇 가지 전역 변수와 함수를 정의하고 있다. 이 단어들은 프로그램 내에서 변수나 함수 이름으로 사용해서는 안 된다.&lt;/p&gt;
&lt;p&gt;arguments encodeURI infinity number regexp
Array encodeURIComponent isFinite Object String
Boolean Error isNaN parseFloat SyntaxError
Date eval JSON parseInt TypeError
decodeURI EvalError Math RangeError undefined
decodeURIComponent function NaN ReferenceError URIError&lt;/p&gt;
&lt;p&gt;자바스크립트에서는 정의된 전역 변수와 전역 함수가 구현체마다 다를 수 있고, 자바스크립트 내장 방식(클리어이언트 측, 서버 측 등)에 따라 전역 프로퍼티 목록도 다를 수 있다.&lt;/p&gt;
&lt;p&gt;2.5 선택적인 세미콜론 사용&lt;/p&gt;
&lt;p&gt;다른 프로그래밍 언어와 마찬가지로 자바스크립트에서도 문장을 구분하기 위해 세미콜론을 사용한다. 이 점은 코드를 좀 더 의미 있게 만드는 측면에서 볼 때 중요하다. 구분자가 없으면 한 문장의 끝에 다음 문장의 시작이 올수 있고, 그다음 문장도 마찬가지다. 자바스크립트에서는 여러 문장이 서로 다른 줄에 나타나는 경우 세미콜론을 생략할 수 있다( 또한 프로그램의 끝이나 다음 토큰이 } 일 경우에도 세미콜론을 생략할 수 있다).
어떤 스타일을 선택하든 자바스크립트에서 세미콜론이 필수가 아닌 몇 가지 경우에 대해 자세히 이해하고 있어야 한다. 다음 코드를 살펴보자. 두 문장이 각각 다른 줄에 작성되어 있으므로, 첫 행의 세미콜론은 생략할 수 있다.&lt;/p&gt;
&lt;p&gt;a = 3;
b = 4;&lt;/p&gt;
&lt;p&gt;그러나 코드가 다음과 같이 작성된 경우에는 첫 번째 세미콜론이 반드시 필요하다.&lt;/p&gt;
&lt;p&gt;a = 3; b = 4;&lt;/p&gt;
&lt;p&gt;자바스크립트가 항상 모든 줄바꿈을 세미콜론으로 해석하는 것은 아니다. 일반적으로 세미콜론 없이 코드를 해석할 수 없는 경우에만 줄바꿈을 세미콜론으로 해석한다. 더 형식적으로 말하자면 자바스크립트는 다음 줄에 나오는 공백 아닌 첫 문자를 현재 문장과 이어서 해석 할 수 없을 경우에만 줄바꿈을 세미콜론으로 취급한다. 다음 코드를 살펴보자.&lt;/p&gt;
&lt;p&gt;var a
a
=
3
console.log(a)&lt;/p&gt;
&lt;p&gt;자바스크립트는 이 코드를 다음과 같이 해석한다.&lt;/p&gt;
&lt;p&gt;var a ; a = 3; console.log(a);&lt;/p&gt;
&lt;p&gt;자바스크립트는 첫 번째 줄바꿈을 세미콜론으로 취급하는데, 이는 세미콜론 없이 var a a 코드를 해석할 수 없기 때문이다. 두 번째 a는 그 자체로 실행문 a;이 될 수 있지만, 좀 더 긴 문장인 a =3; 으로 해석할 수 있기 떄문에 두 번째 줄바꿈을 세미콜론으로 취급하지 않는다. 이러한 문장 종료 규칙은 상황에 따라 일부 의도하지 않는 결과를 초래할 수 있다. 다음의 코드는 두 가지 별개의 문장을 작성한 것처럼 보인다.&lt;/p&gt;
&lt;p&gt;var y = x + f
(a+b).toString()&lt;/p&gt;
&lt;p&gt;하지만 두 번째 줄의 괄호가 첫 줄의 함수 f를 호출하는 것으로 해석될 수 있기 때문에 자바스크립트는 이 코드를 이렇게 해석한다.&lt;/p&gt;
&lt;p&gt;var y = x + f(a+b).toString();&lt;/p&gt;
&lt;p&gt;이는 십중팔구 코드의 저자가 의도한 해석이 아닐 가능성이 크다. 이 경우에 두개의 별개 문장으로 작동하게 하려면 명시적으로 세미콜론을 사용해야 한다. 일반적으로, 문장이 (, {, /, +, -로 시작하면 자바스크립트 인터프리터는 해당 문장을 이전 문장에 이어서 해석한다. 문장이 /나 +, -로 시작하는 경우는 극히 드물지만, (나 [로 시작하는 문장은 최소한 자바스크립트 프로그래밍에서는 자주 볼 수 있다. 일부 프로그래머들은 문장의 시작 부분에 방어적인 세미콜론을 넣기도 한다. 이렇게 문장을 작성할 경우, 바로 전 문장의 끝에 세미콜론을 빼먹었어도 항상 그 다음 문장은 올바로 해석된다.&lt;/p&gt;
&lt;p&gt;var x = 0 // 세미콜론이 생략됐다.&lt;/p&gt;
&lt;p&gt;;[x, x+1, x+2].forEach(console.log) //문장 앞에 넣은 방어적인 세미콜론이 이 문장을 위의 문장과 구분되게
해준다.&lt;/p&gt;
&lt;p&gt;지금까지 자바스크립트에서 줄바꿈을 세미콜론으로 해석하는 일반적인 규칙에 대해 살펴봤다. 다음 줄을 첫 줄의 문장과 이어서 하나로 처리할 수 없는 경우에만 줄바꿈을 세미콜론으로 해석한다는 일반 규칙에는 두 가지 예외가 있다. 첫번째 예외는 return, break, continue문을 사용했을 경우다. 만약 줄 바꿈이 return, break, continue 문 바로 다음에 올 경우(줄바꿈 문자 이전까지 어떠한 토큰도 사용하지 않았을 경우)에 자바스크립트는 줄바꿈을 세미콜론으로 해석한다. 예를 들어, 다음과 같은 예제를 살펴보자.&lt;/p&gt;
&lt;p&gt;return
true;&lt;/p&gt;
&lt;p&gt;자바스크립트는 여러분이 다음의 코드를 작성하려 했다고 간주한다.&lt;/p&gt;
&lt;p&gt;return; true;&lt;/p&gt;
&lt;p&gt;하지만 여러분이 원했던 코드는 아마도 다음과 같을 것이다.&lt;/p&gt;
&lt;p&gt;return true;&lt;/p&gt;
&lt;p&gt;여기서 알아야 할 점은 return, break, continue와 다음에 오는 키워드 사이에 줄바꿈을 하지 말아야 한다는 것이다. 만약에 줄바꿈을 할 경우, 좀처럼 디버깅하기 힘들고 예상치 못한 경우로 프로그램이 비정상적으로 종료될 수도 있다. 두 번째 예외는 ++나 -- 연산자가 포함된 경우다. 이러한 연산자는 피연산자가 전에 오면 전치(prefix) 연산자가 되고, 피연산자가 다음에 올 경우 후치(postfix) 연산자가 된다. 만약 이러한 연산자들을 후치 연산자로 사용할 경우에는 반드시 연산자가 적용되는 표현식과 동일한 줄에 나타나야 한다. 이렇지 않으면, 줄바꿈은 무조건 세미콜론으로 해석되고 ++나 --는 줄바꿈 다음 피연산자의 전치 연산자로 해석될 것이다. 예를 들어, 아래의 코드를 살펴보자.&lt;/p&gt;
&lt;p&gt;x
++
y&lt;/p&gt;
&lt;p&gt;위 코드는 x++; y가 아니라 x; ++y로 해석된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Express guide]]></title><description><![CDATA[Hello world 예제
기본적으로 이 앱은 여러분이 작성할 수 있는 가장 간단한 Express 앱일 것입니다. 이 앱은 하나의 파일로 된 앱이며 Express 생성기를 통해 얻게 되는 앱과는 같지 않습니다. (이 예제와 달리 Express 생성기…]]></description><link>https://nicorobinv.github.io/Express-study_1/</link><guid isPermaLink="false">https://nicorobinv.github.io/Express-study_1/</guid><pubDate>Mon, 20 Sep 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hello world 예제
기본적으로 이 앱은 여러분이 작성할 수 있는 가장 간단한 Express 앱일 것입니다. 이 앱은 하나의 파일로 된 앱이며 Express 생성기를 통해 얻게 되는 앱과는 같지 않습니다. (이 예제와 달리 Express 생성기를 통해 얻게 되는 앱은 다양한 목적을 위한 여러 JavaScript 파일, Jade 템플리트 및 하위 디렉토리를 포함하는 전체 앱에 대한 스캐폴딩을 작성합니다.)
먼저, myapp이라는 이름의 디렉토리를 작성한 후 이 디렉토리로 이동하여 npm init를 실행하십시오. 이후 설치 안내서에 따라 express를 종속 항목으로서 설치하십시오.
myapp 디렉토리에 app.js라는 이름의 파일을 작성한 후 다음과 같은 코드를 추가하십시오.&lt;/p&gt;
&lt;p&gt;var express = require(&apos;express&apos;);
var app = express();
app.get(&apos;/&apos;, function (req, res) {
res.send(&apos;Hello World!&apos;);
});
app.listen(3000, function () {
console.log(&apos;Example app listening on port 3000!&apos;);
});
앱은 서버를 시작하며 3000번 포트에서 연결을 청취합니다. 앱은 루트 URL(/) 또는 라우트에 대한 요청에 “Hello World!”로 응답합니다. 다른 모든 경로에 대해서는 404 Not Found로 응답합니다.
req(요청) 및 res(응답)는 Node가 제공하는 동일한 오브젝트이며, 따라서 req.pipe(), req.on(&apos;data&apos;, callback) 그리고 Express의 관여가 필요 없는 다른 모든 항목을 호출할 수 있습니다.
다음의 명령을 이용하여 앱을 실행하십시오.&lt;/p&gt;
&lt;p&gt;$ node app.js
이후 브라우저에서 &lt;a href=&quot;http://localhost:3000/%EC%9D%84&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/을&lt;/a&gt; 로드하여 결과물을 확인하십시오.&lt;/p&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://expressjs.com/ko/starter/hello-world.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://expressjs.com/ko/starter/hello-world.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Express 애플리케이션 생성기
애플리케이션의 골격을 신속하게 작성하려면 애플리케이션 생성기 도구인 express를 사용하십시오.
다음의 명령을 이용해 express를 설치하십시오.&lt;/p&gt;
&lt;p&gt;$ npm install express-generator -g
다음과 같이 -h 옵션을 이용해 명령의 옵션을 표시하십시오.&lt;/p&gt;
&lt;p&gt;$ express -h
Usage: express [options][dir]
Options:
-h, --help output usage information
--version output the version number
-e, --ejs add ejs engine support
--hbs add handlebars engine support
--pug add pug engine support
-H, --hogan add hogan.js engine support
--no-view generate without view engine
-v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
-c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
--git add .gitignore
-f, --force force on non-empty directory
예를 들면, 다음의 예에서는 &lt;em&gt;myapp&lt;/em&gt;라는 이름의 Express 앱을 현재 작업 디렉토리에 작성합니다.&lt;/p&gt;
&lt;p&gt;$ express --view=pug myapp
create : myapp
create : myapp/package.json
create : myapp/app.js
create : myapp/public
create : myapp/public/javascripts
create : myapp/public/images
create : myapp/routes
create : myapp/routes/index.js
create : myapp/routes/users.js
create : myapp/public/stylesheets
create : myapp/public/stylesheets/style.css
create : myapp/views
create : myapp/views/index.pug
create : myapp/views/layout.pug
create : myapp/views/error.pug
create : myapp/bin
create : myapp/bin/www
이후 다음과 같이 종속 항목을 설치하십시오.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;cd myapp&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.03588em;&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; npm install
MacOS 또는 Linux에서는 다음 명령을 사용하여 앱을 실행하십시오.&lt;/p&gt;
&lt;p&gt;$ DEBUG=myapp:* npm start
Windows에서는 다음 명령을 사용하십시오.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;set DEBUG=myapp:* &amp;#x26; npm start
이후 브라우저에서 &lt;a href=&quot;http://localhost:3000/%EC%9D%84&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/을&lt;/a&gt; 로드하여 앱에 액세스하십시오.
생성된 앱은 다음과 같은 디렉토리 구조를 갖습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;.
├── app.js
├── bin
│ └── www
├── package.json
├── public
│ ├── images
│ ├── javascripts
│ └── stylesheets
│ └── style.css
├── routes
│ ├── index.js
│ └── users.js
└── views
├── error.pug
├── index.pug
└── layout.pug
7 directories, 9 files
생성기에 의해 작성된 앱 구조는 Express 앱을 구조화하는 여러 방법 중 하나에 불과합니다. 이러한 구조를 사용하거나 사용자의 요구사항에 가장 적합하도록 구조를 수정하십시오.&lt;/p&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://expressjs.com/ko/starter/generator.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://expressjs.com/ko/starter/generator.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;기본 라우팅
라우팅은 URI(또는 경로) 및 특정한 HTTP 요청 메소드(GET, POST 등)인 특정 엔드포인트에 대한 클라이언트 요청에 애플리케이션이 응답하는 방법을 결정하는 것을 말합니다.
각 라우트는 하나 이상의 핸들러 함수를 가질 수 있으며, 이러한 함수는 라우트가 일치할 때 실행됩니다.
라우트 정의에는 다음과 같은 구조가 필요합니다.&lt;/p&gt;
&lt;p&gt;app.METHOD(PATH, HANDLER)
여기서,
• app은 express의 인스턴스입니다.
• METHOD는 HTTP 요청 메소드입니다.
• PATH는 서버에서의 경로입니다.
• HANDLER는 라우트가 일치할 때 실행되는 함수입니다.
이 학습서에서는 app이라는 이름의 express 인스턴스가 작성되며 서버가 실행 중인 것으로 가정합니다. 앱의 작성 및 시작에 익숙하지 않은 경우에는 Hello world 예제를 참조하십시오.
다음 예에서는 간단한 라우트의 정의를 설명합니다.
홈 페이지에서 Hello World!로 응답:&lt;/p&gt;
&lt;p&gt;app.get(&apos;/&apos;, function (req, res) {
res.send(&apos;Hello World!&apos;);
});
애플리케이션의 홈 페이지인 루트 라우트(/)에서 POST 요청에 응답:&lt;/p&gt;
&lt;p&gt;app.post(&apos;/&apos;, function (req, res) {
res.send(&apos;Got a POST request&apos;);
});
/user 라우트에 대한 PUT 요청에 응답:&lt;/p&gt;
&lt;p&gt;app.put(&apos;/user&apos;, function (req, res) {
res.send(&apos;Got a PUT request at /user&apos;);
});
/user 라우트에 대한 DELETE 요청에 응답:&lt;/p&gt;
&lt;p&gt;app.delete(&apos;/user&apos;, function (req, res) {
res.send(&apos;Got a DELETE request at /user&apos;);
});
라우팅에 대한 자세한 내용을 확인하려면 라우팅 안내서를 참조하십시오.&lt;/p&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://expressjs.com/ko/starter/basic-routing.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://expressjs.com/ko/starter/basic-routing.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Express에서 정적 파일 제공
이미지, CSS 파일 및 JavaScript 파일과 같은 정적 파일을 제공하려면 Express의 기본 제공 미들웨어 함수인 express.static을 사용하십시오.
정적 자산이 포함된 디렉토리의 이름을 express.static 미들웨어 함수에 전달하면 파일의 직접적인 제공을 시작할 수 있습니다. 예를 들면, 다음과 같은 코드를 이용하여 public이라는 이름의 디렉토리에 포함된 이미지, CSS 파일 및 JavaScript 파일을 제공하십시오.&lt;/p&gt;
&lt;p&gt;app.use(express.static(&apos;public&apos;));
이제 다음과 같이 public 디렉토리에 포함된 파일을 로드할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:3000/images/kitten.jpg&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/images/kitten.jpg&lt;/a&gt;
&lt;a href=&quot;http://localhost:3000/css/style.css&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/css/style.css&lt;/a&gt;
&lt;a href=&quot;http://localhost:3000/js/app.js&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/js/app.js&lt;/a&gt;
&lt;a href=&quot;http://localhost:3000/images/bg.png&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/images/bg.png&lt;/a&gt;
&lt;a href=&quot;http://localhost:3000/hello.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/hello.html&lt;/a&gt;
Express는 정적 디렉토리에 대해 상대적으로 파일을 검색하며, 따라서 정적 디렉토리의 이름은 URL의 일부가 아닙니다.
여러 개의 정적 자산 디렉토리를 이용하려면 다음과 같이 express.static 미들웨어 함수를 여러 번 호출하십시오.&lt;/p&gt;
&lt;p&gt;app.use(express.static(&apos;public&apos;));
app.use(express.static(&apos;files&apos;));
Express는 express.static 미들웨어 함수를 이용해 정적 디렉토리를 설정한 순서대로 파일을 검색합니다.
express.static 함수를 통해 제공되는 파일에 대한 가상 경로 접두부(파일 시스템 내에 해당 경로가 실제로 존재하지 않는 경우)를 작성하려면, 아래에 표시된 것과 같이 정적 디렉토리에 대한 마운트 경로를 지정하십시오.&lt;/p&gt;
&lt;p&gt;app.use(&apos;/static&apos;, express.static(&apos;public&apos;));
이제 /static 경로 접두부를 통해 public 디렉토리에 포함된 파일을 로드할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:3000/static/images/kitten.jpg&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/static/images/kitten.jpg&lt;/a&gt;
&lt;a href=&quot;http://localhost:3000/static/css/style.css&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/static/css/style.css&lt;/a&gt;
&lt;a href=&quot;http://localhost:3000/static/js/app.js&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/static/js/app.js&lt;/a&gt;
&lt;a href=&quot;http://localhost:3000/static/images/bg.png&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/static/images/bg.png&lt;/a&gt;
&lt;a href=&quot;http://localhost:3000/static/hello.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/static/hello.html&lt;/a&gt;
그러나 express.static 함수에 제공되는 경로는 node 프로세스가 실행되는 디렉토리에 대해 상대적입니다. Express 앱을 다른 디렉토리에서 실행하는 경우에는 다음과 같이 제공하기 원하는 디렉토리의 절대 경로를 사용하는 것이 더 안전합니다.&lt;/p&gt;
&lt;p&gt;app.use(&apos;/static&apos;, express.static(__dirname + &apos;/public&apos;));&lt;/p&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://expressjs.com/ko/starter/static-files.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://expressjs.com/ko/starter/static-files.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;라우팅
라우팅은 애플리케이션 엔드 포인트(URI)의 정의, 그리고 URI가 클라이언트 요청에 응답하는 방식을 말합니다. 라우팅에 대한 소개는 기본 라우팅을 참조하십시오.
다음 코드는 매우 기본적인 라우트의 예입니다.&lt;/p&gt;
&lt;p&gt;var express = require(&apos;express&apos;);
var app = express();
// respond with &quot;hello world&quot; when a GET request is made to the homepage
app.get(&apos;/&apos;, function(req, res) {
res.send(&apos;hello world&apos;);
});
라우트 메소드
라우트 메소드는 HTTP 메소드 중 하나로부터 파생되며, express 클래스의 인스턴스에 연결됩니다.
다음 코드는 앱의 루트에 대한 GET 및 POST 메소드에 대해 정의된 라우트의 예입니다.&lt;/p&gt;
&lt;p&gt;// GET method route
app.get(&apos;/&apos;, function (req, res) {
res.send(&apos;GET request to the homepage&apos;);
});
// POST method route
app.post(&apos;/&apos;, function (req, res) {
res.send(&apos;POST request to the homepage&apos;);
});
Express는 HTTP 메소드에 해당하는 다음과 같은 라우팅 메소드를 지원합니다. get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search 및 connect.
올바르지 않은 JavaScript 변수 이름으로 변환되는 메소드를 라우팅하려면 대괄호 표기법을 사용하십시오. 예를 들면 app[&apos;m-search&apos;](&apos;/&apos;, function ... 등과 같습니다.
특수한 라우팅 메소드인 app.all()은 어떠한 HTTP 메소드로부터도 파생되지 않습니다. 이 메소드는 모든 요청 메소드에 대해 한 경로에서 미들웨어 함수를 로드하는 데 사용됩니다.
다음 예에서는, GET, POST, PUT 또는 DELETE 메소드를 사용하는 경우, 또는 http 모듈에서 지원되는 기타 모든 HTTP 요청 메소드를 사용하는 경우 등의 “/secret”에 대한 요청을 위하여 핸들러가 실행됩니다.&lt;/p&gt;
&lt;p&gt;app.all(&apos;/secret&apos;, function (req, res, next) {
console.log(&apos;Accessing the secret section ...&apos;);
next(); // pass control to the next handler
});
라우트 경로
라우트 경로는, 요청 메소드와의 조합을 통해, 요청이 이루어질 수 있는 엔드포인트를 정의합니다. 라우트 경로는 문자열, 문자열 패턴 또는 정규식일 수 있습니다.
Express는 라우트 경로의 일치를 위해 path-to-regexp를 사용합니다. 라우트 경로를 정의할 수 있는 모든 가능성을 확인하려면 path-to-regexp 문서를 참조하십시오. Express Route Tester는 기본적인 Express 라우트의 테스트를 위한 편리한 도구이지만, 패턴 일치는 지원하지 않습니다.
조회 문자열은 라우트 경로의 일부가 아닙니다.
문자열을 기반으로 하는 라우트 경로의 몇 가지 예는 다음과 같습니다.
다음의 라우트 경로는 요청을 루트 라우트 /에 일치시킵니다.&lt;/p&gt;
&lt;p&gt;app.get(&apos;/&apos;, function (req, res) {
res.send(&apos;root&apos;);
});
다음의 라우트 경로는 요청을 /about에 일치시킵니다.&lt;/p&gt;
&lt;p&gt;app.get(&apos;/about&apos;, function (req, res) {
res.send(&apos;about&apos;);
});
다음의 라우트 경로는 요청을 /random.text에 일치시킵니다.&lt;/p&gt;
&lt;p&gt;app.get(&apos;/random.text&apos;, function (req, res) {
res.send(&apos;random.text&apos;);
});
문자열 패턴을 기반으로 하는 라우트 경로의 몇 가지 예는 다음과 같습니다.
다음의 라우트 경로는 acd 및 abcd와 일치합니다.&lt;/p&gt;
&lt;p&gt;app.get(&apos;/ab?cd&apos;, function(req, res) {
res.send(&apos;ab?cd&apos;);
});
다음의 라우트 경로는 abcd, abbcd 및 abbbcd 등과 일치합니다.&lt;/p&gt;
&lt;p&gt;app.get(&apos;/ab+cd&apos;, function(req, res) {
res.send(&apos;ab+cd&apos;);
});
다음의 라우트 경로는 abcd, abxcd, abRABDOMcd 및 ab123cd 등과 일치합니다.&lt;/p&gt;
&lt;p&gt;app.get(&apos;/ab&lt;em&gt;cd&apos;, function(req, res) {
res.send(&apos;ab&lt;/em&gt;cd&apos;);
});
다음의 라우트 경로는 /abe 및 /abcde와 일치합니다.&lt;/p&gt;
&lt;p&gt;app.get(&apos;/ab(cd)?e&apos;, function(req, res) {
res.send(&apos;ab(cd)?e&apos;);
});
?, +, * 및 () 문자는 정규식 문자의 서브세트입니다. 하이픈(-) 및 점(.)은 문자열 기반 경로에 의해 문자 그대로 해석됩니다.
정규식을 기반으로 하는 라우트 경로의 예:
다음의 라우트 경로는 라우트 이름에 “a”가 포함된 모든 항목과 일치합니다.&lt;/p&gt;
&lt;p&gt;app.get(/a/, function(req, res) {
res.send(&apos;/a/&apos;);
});
다음의 라우트 경로는 butterfly 및 dragonfly와 일치하지만, butterflyman 및 dragonfly man 등과 일치하지 않습니다.&lt;/p&gt;
&lt;p&gt;app.get(/.&lt;em&gt;fly$/, function(req, res) {
res.send(&apos;/.&lt;/em&gt;fly$/&apos;);
});
라우트 핸들러
미들웨어와 비슷하게 작동하는 여러 콜백 함수를 제공하여 요청을 처리할 수 있습니다. 유일한 차이점은 이러한 콜백은 next(&apos;route&apos;)를 호출하여 나머지 라우트 콜백을 우회할 수도 있다는 점입니다. 이러한 메커니즘을 이용하면 라우트에 대한 사전 조건을 지정한 후, 현재의 라우트를 계속할 이유가 없는 경우에는 제어를 후속 라우트에 전달할 수 있습니다.
다음 예에 나타난 것과 같이, 라우트 핸들러는 함수나 함수 배열의 형태 또는 둘을 조합한 형태일 수 있습니다.
하나의 콜백 함수는 하나의 라우트를 처리할 수 있습니다. 예를 들면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;app.get(&apos;/example/a&apos;, function (req, res) {
res.send(&apos;Hello from A!&apos;);
});
2개 이상의 콜백 함수는 하나의 라우트를 처리할 수 있습니다(next 오브젝트를 반드시 지정해야 함). 예를 들면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;app.get(&apos;/example/b&apos;, function (req, res, next) {
console.log(&apos;the response will be sent by the next function ...&apos;);
next();
}, function (req, res) {
res.send(&apos;Hello from B!&apos;);
});
하나의 콜백 함수 배열은 하나의 라우트를 처리할 수 있습니다. 예를 들면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;var cb0 = function (req, res, next) {
console.log(&apos;CB0&apos;);
next();
}
var cb1 = function (req, res, next) {
console.log(&apos;CB1&apos;);
next();
}
var cb2 = function (req, res) {
res.send(&apos;Hello from C!&apos;);
}
app.get(&apos;/example/c&apos;, [cb0, cb1, cb2]);
독립적인 함수와 함수 배열의 조합은 하나의 라우트를 처리할 수 있습니다. 예를 들면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;var cb0 = function (req, res, next) {
console.log(&apos;CB0&apos;);
next();
}
var cb1 = function (req, res, next) {
console.log(&apos;CB1&apos;);
next();
}
app.get(&apos;/example/d&apos;, [cb0, cb1], function (req, res, next) {
console.log(&apos;the response will be sent by the next function ...&apos;);
next();
}, function (req, res) {
res.send(&apos;Hello from D!&apos;);
});
응답 메소드
다음 표에 표시된 응답 오브젝트에 대한 메소드(res)는 응답을 클라이언트로 전송하고 요청-응답 주기를 종료할 수 있습니다. 라우트 핸들러로부터 다음 메소드 중 어느 하나도 호출되지 않는 경우, 클라이언트 요청은 정지된 채로 방치됩니다.
메소드 설명
res.download() 파일이 다운로드되도록 프롬프트합니다.
res.end() 응답 프로세스를 종료합니다.
res.json() JSON 응답을 전송합니다.
res.jsonp() JSONP 지원을 통해 JSON 응답을 전송합니다.
res.redirect() 요청의 경로를 재지정합니다.
res.render() 보기 템플리트를 렌더링합니다.
res.send() 다양한 유형의 응답을 전송합니다.
res.sendFile 파일을 옥텟 스트림의 형태로 전송합니다.
res.sendStatus() 응답 상태 코드를 설정한 후 해당 코드를 문자열로 표현한 내용을 응답 본문으로서 전송합니다.
app.route()
app.route()를 이용하면 라우트 경로에 대하여 체인 가능한 라우트 핸들러를 작성할 수 있습니다. 경로는 한 곳에 지정되어 있으므로, 모듈식 라우트를 작성하면 중복성과 오타가 감소하여 도움이 됩니다. 라우트에 대한 자세한 정보는 Router() 문서를 참조하십시오.
app.route()를 사용하여 정의된 체인 라우트 핸들러의 예는 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;app.route(&apos;/book&apos;)
.get(function(req, res) {
res.send(&apos;Get a random book&apos;);
})
.post(function(req, res) {
res.send(&apos;Add a book&apos;);
})
.put(function(req, res) {
res.send(&apos;Update the book&apos;);
});
express.Router
express.Router 클래스를 사용하면 모듈식 마운팅 가능한 핸들러를 작성할 수 있습니다. Router 인스턴스는 완전한 미들웨어이자 라우팅 시스템이며, 따라서 “미니 앱(mini-app)”이라고 불리는 경우가 많습니다.
다음 예에서는 라우터를 모듈로서 작성하고, 라우터 모듈에서 미들웨어 함수를 로드하고, 몇몇 라우트를 정의하고, 기본 앱의 한 경로에 라우터 모듈을 마운트합니다.
다음의 내용이 입력된 birds.js라는 이름의 라우터 파일을 앱 디렉토리에 작성하십시오.&lt;/p&gt;
&lt;p&gt;var express = require(&apos;express&apos;);
var router = express.Router();
// middleware that is specific to this router
router.use(function timeLog(req, res, next) {
console.log(&apos;Time: &apos;, Date.now());
next();
});
// define the home page route
router.get(&apos;/&apos;, function(req, res) {
res.send(&apos;Birds home page&apos;);
});
// define the about route
router.get(&apos;/about&apos;, function(req, res) {
res.send(&apos;About birds&apos;);
});
module.exports = router;
이후 앱 내에서 다음과 같이 라우터 모듈을 로드하십시오.&lt;/p&gt;
&lt;p&gt;var birds = require(&apos;./birds&apos;);
...
app.use(&apos;/birds&apos;, birds);
앱은 이제 /birds 및 /birds/about에 대한 요청을 처리할 수 있게 되었으며, 해당 라우트에 대한 특정한 미들웨어 함수인 timeLog를 호출할 것입니다.&lt;/p&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://expressjs.com/ko/guide/routing.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://expressjs.com/ko/guide/routing.html&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React 배포하기]]></title><description><![CDATA[명령어 복습하기 프로젝트 생성하기
npm init react-app .
터미널에서 원하는 디렉토리에 들어가서 npm init react-app .를 입력하면 현재 디렉토리에 리액트 프로젝트를 생성합니다. 개발 모드 실행하기
npm start (npm…]]></description><link>https://nicorobinv.github.io/React-study_6/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_6/</guid><pubDate>Wed, 01 Sep 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;명령어 복습하기&lt;/p&gt;
&lt;p&gt;프로젝트 생성하기
npm init react-app .
터미널에서 원하는 디렉토리에 들어가서 npm init react-app .를 입력하면 현재 디렉토리에 리액트 프로젝트를 생성합니다.&lt;/p&gt;
&lt;p&gt;개발 모드 실행하기
npm start (npm run start)
터미널에서 npm run start를 입력하면 개발 모드 서버가 실행됩니다.&lt;/p&gt;
&lt;p&gt;실행 중인 서버 종료하기
ctrl + c
서버가 실행 중인 터미널에서 ctrl + c를 입력하면 서버가 종료됩니다.&lt;/p&gt;
&lt;p&gt;개발된 프로젝트 빌드하기
npm run build
터미널에서 npm run build를 입력하면 빌드를 시작합니다.&lt;/p&gt;
&lt;p&gt;빌드한 것 로컬에서 실행하기
npx serve build
터미널에서 npx serve build를 입력하면 serve 프로그램을 다운 받고 build 폴더에서 서버가 실행됩니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React 디자인 적용하는 방법과 팁]]></title><description><![CDATA[사실 CSS 파일을 불러오거나 이미지 파일을 불러오는 기능은 리액트 고유의 기능이 아니라 Create React App이라는 프로그램이 대신 설정해 준 기능입니다. (참고: Create React App 문서) 클래스네임을 좀 더 편리하게 쓰는 방법…]]></description><link>https://nicorobinv.github.io/React-study_5/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_5/</guid><pubDate>Tue, 24 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;사실 CSS 파일을 불러오거나 이미지 파일을 불러오는 기능은 리액트 고유의 기능이 아니라 Create React App이라는 프로그램이 대신 설정해 준 기능입니다. (참고: Create React App 문서)&lt;/p&gt;
&lt;p&gt;클래스네임을 좀 더 편리하게 쓰는 방법&lt;/p&gt;
&lt;p&gt;디자인을 적용하는 방법
이미지 불러오기
이미지 파일은 import 구문을 통해 불러오고, 불러온 이미지 주소를 src 속성으로 사용하면 됩니다.&lt;/p&gt;
&lt;p&gt;import diceImg from &apos;./assets/dice.png&apos;;&lt;/p&gt;
&lt;p&gt;function Dice() {
return &lt;img src={diceImg} alt=&quot;주사위 이미지&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default App;
인라인 스타일
리액트에서 인라인 스타일은 문자열이 아닌 객체형으로 사용합니다. 프로퍼티 이름은 CSS 속성 이름으로, 프로퍼티 값은 CSS 속성 값으로 쓰는데요, 이때 프로퍼티 이름은 아래의 boarderRadius 처럼 대시 기호 없이 카멜 케이스로 써야 한다는 점도 꼭 기억해두세요.&lt;/p&gt;
&lt;p&gt;import diceImg from &apos;./assets/dice.png&apos;;&lt;/p&gt;
&lt;p&gt;const style = {
borderRadius: &apos;50%&apos;,
width: &apos;120px&apos;,
height: &apos;120px&apos;,
};&lt;/p&gt;
&lt;p&gt;function Dice() {
return &lt;img style={style} src={diceImg} alt=&quot;주사위 이미지&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default App;
CSS 파일 불러오기
import 구문으로 파일을 불러올 수 있는데요, 이때 from 키워드 없이 쓰면 됩니다.&lt;/p&gt;
&lt;p&gt;import diceImg from &apos;./assets/dice.png&apos;;
import &apos;./Dice.css&apos;;&lt;/p&gt;
&lt;p&gt;function Dice() {
return &lt;img src={diceImg} alt=&quot;주사위 이미지&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default App;
클래스네임 사용하기
CSS 파일에 정의된 클래스명을 className prop에 문자열로 넣어주면 됩니다. 이때 재사용성을 위해 className prop을 부모 컴포넌트에서 받으면 더 좋습니다.&lt;/p&gt;
&lt;p&gt;import diceImg from &apos;./assets/dice.png&apos;;
import &apos;./Dice.css&apos;;&lt;/p&gt;
&lt;p&gt;function Dice({ className = &apos;&apos; }) {
const classNames = &lt;code class=&quot;language-text&quot;&gt;Dice ${className}&lt;/code&gt;;
return &lt;img className={classNames} src={diceImg} alt=&quot;주사위 이미지&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default App;
편리하게 클래스네임을 쓰는 방법
앞에서는 여러 className을 템플릿 문자열로 합쳐서 사용했습니다. 몇 개 없을 때는 상관없지만, 개수가 늘어날수록 아래처럼 알아보기 힘들어진다는 문제점이 있는데요.&lt;/p&gt;
&lt;p&gt;템플릿 문자열을 사용한 예
function Button({ isPending, color, size, invert, children }) {
const classNames = &lt;code class=&quot;language-text&quot;&gt;Button ${isPending ? &amp;#39;pending&amp;#39; : &amp;#39;&amp;#39;} ${color} ${size} ${invert ? &amp;#39;invert&amp;#39; : &amp;#39;&amp;#39;}&lt;/code&gt;;
return &lt;button className={classNames}&gt;{children}&lt;/button&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Button;
배열을 사용한 예
function Button({ isPending, color, size, invert, children }) {
const classNames = [
&apos;Button&apos;,
isPending ? &apos;pending&apos; : &apos;&apos;,
color,
size,
invert ? &apos;invert&apos; : &apos;&apos;,
].join(&apos;&apos;);
return &lt;button className={classNames}&gt;{children}&lt;/button&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Button;
위 예시 코드처럼 지저분하게 느껴지고, 매번 반복되는 코드를 작성한다는 번거로움이 있습니다. 개발자들은 이럴 때 라이브러리라는 걸 쓰는데요, 다른 개발자가 미리 만들어 놓은 코드를 이용해서 편하게 개발하는 겁니다.&lt;/p&gt;
&lt;p&gt;클래스네임의 경우에도 편리하게 사용할 수 있는 라이브러리가 많이 있는데요, 그중에서도 이번에 소개할 라이브러리는 바로 classnames라는 라이브러리입니다. 아래 예시 코드를 보시면 아시겠지만, 클래스네임에만 집중할 수 있어 훨씬 읽기 편해집니다. 이렇게 적절한 라이브러리를 쓰면 개발 생산성이 굉장히 좋아지죠.&lt;/p&gt;
&lt;p&gt;classnames 라이브러리를 사용한 예
import classNames from &apos;classnames&apos;;&lt;/p&gt;
&lt;p&gt;function Button({ isPending, color, size, invert, children }) {
return (
&amp;#x3C;button
className={classNames(
&apos;Button&apos;,
isPending &amp;#x26;&amp;#x26; &apos;pending&apos;,
color,
size,
invert &amp;#x26;&amp;#x26; &apos;invert&apos;,
)}&gt;
{ children }
&lt;/button &gt;
);
}&lt;/p&gt;
&lt;p&gt;export default Button;
classnames 은 NPM이라는 프로그램을 통해 설치할 수 있습니다. 터미널에서 npm install classnames 을 입력하고 설치한 다음에, 위 예시처럼 import 로 불러와서 사용하면 됩니다. NPM 저장소 사이트로 들어가면 사용 방법과 설명이 나와있음.&lt;/p&gt;
&lt;p&gt;NPM classnames 패키지: &lt;a href=&quot;https://www.npmjs.com/package/classnames&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://www.npmjs.com/package/classnames&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React state 정리하기]]></title><description><![CDATA[State
state는 리액트에서 화면을 그려내는 데 굉장히 중요한 역할을 합니다. State라는 단어는 한국어로 '상태'라는 뜻이 있는데요. 리액트에서의 state도 그 의미가 다르지 않습니다. 상태가 바뀔 때마다 화면을 새롭게 그려내는 방식으로 …]]></description><link>https://nicorobinv.github.io/React-study_4/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_4/</guid><pubDate>Mon, 23 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;State
state는 리액트에서 화면을 그려내는 데 굉장히 중요한 역할을 합니다.&lt;/p&gt;
&lt;p&gt;State라는 단어는 한국어로 &apos;상태&apos;라는 뜻이 있는데요. 리액트에서의 state도 그 의미가 다르지 않습니다.&lt;/p&gt;
&lt;p&gt;상태가 바뀔 때마다 화면을 새롭게 그려내는 방식으로 동작을 하는 것이죠.&lt;/p&gt;
&lt;p&gt;리액트에서 state를 만들고, state를 바꾸기 위해서는 일단 useState라는 함수를 활용해야 합니다.&lt;/p&gt;
&lt;p&gt;import { useState } from &apos;react&apos;;&lt;/p&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;p&gt;const [num, setNum] = useState(1);&lt;/p&gt;
&lt;p&gt;// ...
보통 이렇게 Destructuring 문법으로 작성하는데요. useState 함수가 초깃값을 아규먼트로 받고 그에 따른 실행 결과로 요소 2개를 가진 배열의 형태로 리턴을 하기 때문입니다.&lt;/p&gt;
&lt;p&gt;이때 첫 번째 요소가 바로 state이고, 두 번째 요소가 이 state를 바꾸는 setter 함수인데요.&lt;/p&gt;
&lt;p&gt;참고로 위 코드에서도 볼 수 있듯 첫 번째 변수는 원하는 state의 이름(num)을 지어주고, 두 번째 변수에는 state 이름 앞에 set을 붙인 다음 카멜 케이스로 이름을 지어주는 것(setNum)이 일반적입니다.&lt;/p&gt;
&lt;p&gt;state는 변수에 새로운 값을 할당하는 방식으로 변경하는 것이 아니라 이 setter 함수를 활용해야 하는데요. setter 함수는 호출할 때 전달하는 아규먼트 값으로 state 값을 변경해 줍니다.&lt;/p&gt;
&lt;p&gt;그래서 아래 코드처럼 setter 함수를 활용해서 이벤트 핸들러를 등록해두면, 이벤트가 발생할 때마다 상태가 변하면서 화면이 새로 그려지는 것이죠!&lt;/p&gt;
&lt;p&gt;import { useState } from &apos;react&apos;;
import Button from &apos;./Button&apos;;
import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
const [num, setNum] = useState(1);&lt;/p&gt;
&lt;p&gt;const handleRollClick = () =&gt; {
setNum(3); // num state를 3으로 변경!
};&lt;/p&gt;
&lt;p&gt;const handleClearClick = () =&gt; {
setNum(1); // num state를 1로 변경!
};&lt;/p&gt;
&lt;p&gt;return (&lt;/p&gt;
&lt;div&gt;
&lt;Button onClick={handleRollClick}&gt;던지기&lt;/Button&gt;
&lt;Button onClick={handleClearClick}&gt;처음부터&lt;/Button&gt;
&lt;Dice color=&quot;red&quot; num={num} /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
참조형 State
자바스크립트의 자료형은 크게 기본형(Primitive type)과 참조형(Reference type)로 나눌 수 있다는 사실, 모두 알고 계시죠?&lt;/p&gt;
&lt;p&gt;특히 참조형 값들은 조금 독특한 특성을 가지고 있어서 변수로 다룰 때도 조금 주의해야 할 부분들이 있었는데요. state를 활용할 때도 마찬가지입니다!&lt;/p&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;p&gt;const [gameHistory, setGameHistory] = useState([]);&lt;/p&gt;
&lt;p&gt;const handleRollClick = () =&gt; {
const nextNum = random(6);
gameHistory.push(nextNum);
setGameHistory(gameHistory); // state가 제대로 변경되지 않는다!
};&lt;/p&gt;
&lt;p&gt;// ...
위 코드에서 볼 수 있듯 배열 값을 가진 gameHistory에 push 메소드를 이용해서 배열의 값을 변경한 다음, 변경된 배열을 setter 함수로 state를 변경하려고 하면 코드가 제대로 동작하지 않습니다.&lt;/p&gt;
&lt;p&gt;gameHistory state는 배열 값 자체를 가지고 있는 게 아니라 그 배열의 주솟값을 참조하고 있는 건데요. 때문에 push 메소드로 배열 안에 요소를 변경했다고 하더라도 결과적으로 참조하는 배열의 주솟값은 변경된 것이 아니게 됩니다.&lt;/p&gt;
&lt;p&gt;결과적으로 리액트 입장에서는 gameHistory state가 참조하는 주솟값은 여전히 똑같기 때문에 상태(state)가 바뀌었다고 판단하지 않는 것이죠!&lt;/p&gt;
&lt;p&gt;그래서 참조형 state를 활용할 때는 반드시 새로운 참조형 값을 만들어 state를 변경해야 합니다.&lt;/p&gt;
&lt;p&gt;가장 간단한 방법은 Spread 문법(...) 을 활용하는 것이겠죠?&lt;/p&gt;
&lt;p&gt;// ...&lt;/p&gt;
&lt;p&gt;const [gameHistory, setGameHistory] = useState([]);&lt;/p&gt;
&lt;p&gt;const handleRollClick = () =&gt; {
const nextNum = random(6);
setGameHistory([...gameHistory, nextNum]); // state가 제대로 변경된다!
};&lt;/p&gt;
&lt;p&gt;// ...
이 참조형 state의 특성을 이해하지 못하면, 간혹 state가 제대로 변경되지 않는 버그가 발생했을 때 원인을 제대로 찾지 못하는 경우가 발생할 수도 있는데요.&lt;/p&gt;
&lt;p&gt;참조형 state를 활용할 땐 반드시 새로운 참조형 값을 만들어서 state를 변경해야 한다는 점.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Props 문법]]></title><description><![CDATA[JSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다. Props는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 …]]></description><link>https://nicorobinv.github.io/React-study_3/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_3/</guid><pubDate>Sun, 22 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다.&lt;/p&gt;
&lt;p&gt;Props는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 모여서 컴포넌트를 정의한 함수의 첫 번째 파라미터로 전달됩니다.&lt;/p&gt;
&lt;p&gt;App.js&lt;/p&gt;
&lt;p&gt;import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;Dice color=&quot;blue&quot; /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
Dice.js&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;&lt;/p&gt;
&lt;p&gt;function Dice(props) {
console.log(props)
return &lt;img src={diceBlue01} alt=&quot;주사위&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
위 코드들 처럼 App 함수에서 사용하는 Dice 컴포넌트에 color라는 속성을 blue로 지정해주고, Dice 함수 내부에서 props라는 파라미터를 하나 만들어 출력해보면 브라우저 콘솔에는 다음과 같은 출력 결과가 나타나게 됩니다.&lt;/p&gt;
&lt;p&gt;{ color: &quot;blue&quot; }
그래서 컴포넌트를 활용할 때 속성값을 다양하게 전달하고 이 props 값을 활용하면, 똑같은 컴포넌트라도 전달된 속성값에 따라 서로 다른 모습을 그려낼 수도 있게 됩니다.&lt;/p&gt;
&lt;p&gt;App.js&lt;/p&gt;
&lt;p&gt;import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;Dice color=&quot;red&quot; num={2} /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
Dice.js&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;
import diceBlue02 from &apos;./assets/dice-blue-2.svg&apos;;
// ...
import diceRed01 from &apos;./assets/dice-red-1.svg&apos;;
import diceRed02 from &apos;./assets/dice-red-2.svg&apos;;
// ...&lt;/p&gt;
&lt;p&gt;const DICE_IMAGES = {
blue: [diceBlue01, diceBlue02],
red: [diceRed01, diceRed02],
};&lt;/p&gt;
&lt;p&gt;function Dice(props) {
const src = DICE_IMAGES[props.color][props.num - 1];
const alt = &lt;code class=&quot;language-text&quot;&gt;${props.color} ${props.num}&lt;/code&gt;;
return &lt;img src={src} alt={alt} /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
참고로, 이렇게 props가 객체 형태를 띠고 있으니 Destructuring 문법을 활용해서 조금 더 간결하게 코드를 작성할 수도 있겠죠?&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;
import diceBlue02 from &apos;./assets/dice-blue-2.svg&apos;;
// ...
import diceRed01 from &apos;./assets/dice-red-1.svg&apos;;
import diceRed02 from &apos;./assets/dice-red-2.svg&apos;;
// ...&lt;/p&gt;
&lt;p&gt;const DICE_IMAGES = {
blue: [diceBlue01, diceBlue02],
red: [diceRed01, diceRed02],
};&lt;/p&gt;
&lt;p&gt;function Dice({ color = &apos;blue&apos;, num = 1 }) {
const src = DICE_IMAGES[color][num - 1];
const alt = &lt;code class=&quot;language-text&quot;&gt;${color} ${num}&lt;/code&gt;;
return &lt;img src={src} alt={alt} /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
Children
props에는 children이라는 조금 특별한 프로퍼티(prop, 프롭)가 있습니다.&lt;/p&gt;
&lt;p&gt;JSX 문법으로 컴포넌트를 작성할 때 컴포넌트를 단일 태그가 아니라 여는 태그와 닫는 태그의 형태로 작성하면, 그 안에 작성된 코드가 바로 이 children 값에 담기게 됩니다.&lt;/p&gt;
&lt;p&gt;Button.js&lt;/p&gt;
&lt;p&gt;function Button({ children }) {
return &lt;button&gt;{children}&lt;/button&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Button;
App.js&lt;/p&gt;
&lt;p&gt;import Button from &apos;./Button&apos;;
import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;Button&gt;던지기&lt;/Button&gt;
&lt;Button&gt;처음부터&lt;/Button&gt;
&lt;/div&gt;
&lt;Dice color=&quot;red&quot; num={2} /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
그래서 JSX 문법으로 컴포넌트를 작성할 때 어떤 정보를 전달할 때는 일반적인 props의 속성값을 주로 활용하고, 화면에 보여질 모습을 조금 더 직관적인 코드로 작성하고자 할 때 children 값을 활용할 수가 있습니다.&lt;/p&gt;
&lt;p&gt;참고로 이 children을 활용하면 단순히 텍스트만 작성하는 걸 넘어서 컴포넌트 안에 컴포넌트를 작성할 수도 있고, 컴포넌트 안에 복잡한 태그들을 더 작성할 수도 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React commponent 문법]]></title><description><![CDATA[리액트 엘리먼트
JSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다. import ReactDOM from 'react-dom'; const element = 안녕 리액트!;
console.log(element);
ReactDOM.r…]]></description><link>https://nicorobinv.github.io/React-study_2/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_2/</guid><pubDate>Sat, 21 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;리액트 엘리먼트
JSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다.&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;const element = &lt;h1&gt;안녕 리액트!&lt;/h1&gt;;
console.log(element);
ReactDOM.render(element, document.getElementById(&apos;root&apos;));
{$$typeof: Symbol(react.element), type: &quot;h1&quot;, key: null, ref: null, props: {…}, …}
이런 객체를 리액트 엘리먼트라고 부르는데요.&lt;/p&gt;
&lt;p&gt;이 리액트 엘리먼트를 ReactDOM.render 함수의 아규먼트로 전달하게 되면, 리액트가 객체 형태의 값을 해석해서 HTML 형태로 브라우저에 띄워주는 것이죠.&lt;/p&gt;
&lt;p&gt;리액트 엘리먼트는 리액트로 화면을 그려내는데 가장 기본적인 요소입니다.&lt;/p&gt;
&lt;p&gt;리액트 컴포넌트
리액트 컴포넌트는 리액트 엘리먼트를 조금 더 자유롭게 다루기 위한 하나의 문법입니다.&lt;/p&gt;
&lt;p&gt;컴포넌트를 만드는 가장 간단한 방법은 자바스크립트의 함수를 활용하는 건데요.
아래 코드에서 JSX 문법으로 작성된 하나의 요소를 리턴하는 Hello 함수가 바로 하나의 컴포넌트입니다.&lt;/p&gt;
&lt;p&gt;이렇게 요소를 컴포넌트로 작성하게 되면 다양한 장점들이 있는데,
자세한 내용은 이후의 개념들을 하나씩 배워나가면서 차차 알아보도록 합시다!&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;function Hello() {
return &lt;h1&gt;안녕 리액트&lt;/h1&gt;;
}&lt;/p&gt;
&lt;p&gt;const element = (
&amp;#x3C;&gt;
&lt;Hello /&gt;
&lt;Hello /&gt;
&lt;Hello /&gt;
&amp;#x3C;/&gt;
);&lt;/p&gt;
&lt;p&gt;ReactDOM.render(element, document.getElementById(&apos;root&apos;));
그리고 이렇게 컴포넌트를 작성하면,
위 코드에서 element 변수 안의 JSX 코드에서 볼 수 있듯 컴포넌트 함수 이름을 통해 하나의 태그처럼 활용할 수가 있습니다.&lt;/p&gt;
&lt;p&gt;이런 특성을 모듈 문법으로 활용하면 훨씬 더 독립적으로 컴포넌트 특성에 집중해서 코드를 작성할 수가 있습니다.&lt;/p&gt;
&lt;p&gt;예시: Dice.js&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;&lt;/p&gt;
&lt;p&gt;function Dice() {
return &lt;img src={diceBlue01} alt=&quot;주사위&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
예시: App.js&lt;/p&gt;
&lt;p&gt;import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;Dice /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
한 가지 주의해야 할 부분은, 리액트 컴포넌트의 이름은 반드시 첫 글자를 대문자로 작성해야 한다는 것입니다.
컴포넌트 이름의 첫 글자가 소문자라면 오류가 발생하니깐 꼭 주의!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React JSX 문법]]></title><description><![CDATA[JSX란?
JSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다. import ReactDOM from 'react-do…]]></description><link>https://nicorobinv.github.io/React-study_1/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_1/</guid><pubDate>Fri, 20 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JSX란?
JSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다.&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;h1&gt;안녕 리액트!&lt;/h1&gt;, document.getElementById(&apos;root&apos;));
JSX 문법
JSX는 자바스크립트로 HTML과 같은 문법을 사용할 수 있도록 만들어주는 편리한 문법이지만, 그만큼 꼭 지켜야 할 규칙들도 있습니다.&lt;/p&gt;
&lt;p&gt;HTML과 다른 속성명&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;속성명은 카멜 케이스로 작성하기!
JSX 문법에서도 태그에 속성을 지정해 줄 수 있습니다. 단, 여러 단어가 조합된 몇몇 속성들을 사용할 때는 반드시 카멜 케이스(Camel Case)로 작성해야 합니다.
사실 여러 단어가 조합된 HTML 속성들이 많진 않지만, 예를 들면 onclick, onblur, onfocus 등과 같은 이벤트 속성이나, tabindex 같은 속성들이 있습니다.
이런 속성들은 모두 onClick, onBlur, onFocus, onMouseDown, onMouseOver, tabIndex 처럼 작성하는 것이죠!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&lt;button onClick= ... &gt;클릭!&lt;/button&gt;,
document.getElementById(&apos;root&apos;)
);
단, 예외적으로 HTML에서 비표준 속성을 다룰 때 활용하는 data-* 속성은 카멜 케이스(Camel Case)가 아니라 기존의 HTML 문법 그대로 작성하셔야 합니다.&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;div&gt;
    상태 변경: 
    &lt;button className=&quot;btn&quot; data-status=&quot;대기중&quot;&gt;대기중&lt;/button&gt;
    &lt;button className=&quot;btn&quot; data-status=&quot;진행중&quot;&gt;진행중&lt;/button&gt;
    &lt;button className=&quot;btn&quot; data-status=&quot;완료&quot;&gt;완료&lt;/button&gt;
  &lt;/div&gt;,
  document.getElementById(&apos;root&apos;)
);
2. 자바스크립트 예약어와 같은 속성명은 사용할 수 없다!
JSX 문법도 결국은 자바스크립트 문법이기 때문에, for나 class처럼 자바스크립트의 문법에 해당하는 예약어와 똑같은 이름의 속성명은 사용할 수 없습니다.
그래서 HTML의 for의 경우에는 자바스크립트의 반복문 키워드 for와 겹치기 때문에 htmlFor로, HTML의 class 속성도 자바스크립트의 클래스 키워드 class와 겹치기 때문에 className으로 작성해 주어야 합니다.
&lt;p&gt;React 공식 문서 - 어트리뷰트의 차이&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;form&gt;
    &lt;label htmlFor=&quot;name&quot;&gt;이름&lt;/label&gt;
    &lt;input id=&quot;name&quot; className=&quot;name-input&quot; type=&quot;text&quot; /&gt;
  &lt;/form&gt;,
  document.getElementById(&apos;root&apos;)
);
반드시 하나의 요소로 감싸기 - Fragment
JSX 문법을 활용할 때는 반드시 하나의 요소로 감싸주어야 합니다. 그래서 아래 코드처럼 여러 개의 요소를 작성하면 오류가 발생하는데요.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;p&gt;안녕&lt;/p&gt;
  &lt;p&gt;리액트!&lt;/p&gt;,
  document.getElementById(&apos;root&apos;)
);
이럴 때는 아래 코드처럼 여러 태그를 감싸는 부모 태그를 만들어 하나의 요소로 만들어 주어야 합니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;안녕&lt;/p&gt;
    &lt;p&gt;리액트!&lt;/p&gt;
  &lt;/div&gt;,
  document.getElementById(&apos;root&apos;)
);
하지만 이렇게 작성한다면 때로는 꼭 필요하지 않은 부모 태그가 작성될 수 있겠죠? 그럴 땐 Fragment로 감싸주면 의미 없는 부모 태그를 만들지 않아도 여러 요소를 작성할 수 있습니다.
&lt;p&gt;import { Fragment } from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&lt;Fragment&gt;&lt;/p&gt;
&lt;p&gt;안녕&lt;/p&gt;
&lt;p&gt;리액트!&lt;/p&gt;
&lt;/Fragment&gt;,
document.getElementById(&apos;root&apos;)
);
참고로 Fragment는 아래 코드처럼 빈 태그로 감싸는 단축 문법으로 활용할 수도 있습니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&amp;#x3C;&gt;&lt;/p&gt;
&lt;p&gt;안녕&lt;/p&gt;
&lt;p&gt;리액트!&lt;/p&gt;
&lt;/&gt;,
document.getElementById(&apos;root&apos;)
);
자바스크립트 표현식 넣기
JSX 문법에서 중괄호({})를 활용하면 자바스크립트 표현식을 넣을 수 있습니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;const product = &apos;맥북&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;h1&gt;나만의 {product} 주문하기&lt;/h1&gt;,
  document.getElementById(&apos;root&apos;)
);
이런 부분들을 잘 활용하면, 아래 코드처럼 중괄호 안에서 문자열을 조합할 수도 있고 변수에 이미지 주소를 할당해서 img 태그의 src 속성값을 전달해 줄 수도 있고, 이벤트 핸들러를 좀 더 편리하게 등록할 수도 있습니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;const product = &apos;MacBook&apos;;
const model = &apos;Air&apos;;
const imageUrl = &apos;&lt;a href=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/MacBook_with_Retina_Display.png/500px-MacBook_with_Retina_Display.png&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/MacBook_with_Retina_Display.png/500px-MacBook_with_Retina_Display.png&lt;/a&gt;&apos;&lt;/p&gt;
&lt;p&gt;function handleClick(e) {
alert(&apos;곧 도착합니다!&apos;);
}&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&amp;#x3C;&gt;&lt;/p&gt;
&lt;h1&gt;{product + &apos; &apos; + model} 주문하기&lt;/h1&gt;
&lt;img src={imageUrl} alt=&quot;제품 사진&quot; /&gt;
&lt;button onClick={handleClick}&gt;확인&lt;/button&gt;
&lt;/&gt;,
document.getElementById(&apos;root&apos;)
);
단, JSX 문법에서 중괄호는 자바스크립트 표현식을 다룰 때 활용하기 때문에, 중괄호 안에서 for, if문 등의 문장은 다룰 수 없다는 점은 꼭 기억해 주세요.
그런데도 만약 JSX 문법을 활용할 때 조건문이 꼭 필요하다면 조건 연산자를, 반복문이 꼭 필요하다면 배열의 반복 메소드를 활용하자.</content:encoded></item><item><title><![CDATA[Git 협업하기 정리 노트]]></title><description><![CDATA[git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
git blame : 특정 파…]]></description><link>https://nicorobinv.github.io/Git-study_5/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_5/</guid><pubDate>Tue, 17 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
git blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력
git revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성&lt;/p&gt;</content:encoded></item><item><title><![CDATA[branch 정리 노트]]></title><description><![CDATA[git branch 새 브랜치 이름 : 새로운 브랜치를 생성
git checkout -b 새 브랜치 이름 : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
git branch -d 기존 브랜치 이름 : 브랜치 삭제
git checkout 기존 브랜…]]></description><link>https://nicorobinv.github.io/Git-study_4/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_4/</guid><pubDate>Tue, 17 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git branch [새 브랜치 이름] : 새로운 브랜치를 생성
git checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
git branch -d [기존 브랜치 이름] : 브랜치 삭제
git checkout [기존 브랜치 이름] : 그 브랜치로 이동
git merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지
git merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감&lt;/p&gt;</content:encoded></item></channel></rss>