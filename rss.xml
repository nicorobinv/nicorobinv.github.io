<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Dev.seungwon Jang | Feed]]></title><description><![CDATA[seungwon Jang's Development Blog]]></description><link>https://nicorobinv.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 22 Aug 2021 02:53:12 GMT</lastBuildDate><item><title><![CDATA[React Props 문법]]></title><description><![CDATA[JSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다. Props는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 …]]></description><link>https://nicorobinv.github.io/React-stydy_3/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-stydy_3/</guid><pubDate>Sun, 22 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JSX 문법에서 컴포넌트를 작성할 때 컴포넌트에도 속성을 지정할 수 있는데요. 리액트에서 이렇게 컴포넌트에 지정한 속성들을 Props라고 부릅니다.&lt;/p&gt;
&lt;p&gt;Props는 Properties의 약자인데요. 컴포넌트에 속성을 지정해주면 각 속성이 하나의 객체로 모여서 컴포넌트를 정의한 함수의 첫 번째 파라미터로 전달됩니다.&lt;/p&gt;
&lt;p&gt;App.js&lt;/p&gt;
&lt;p&gt;import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;Dice color=&quot;blue&quot; /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
Dice.js&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;&lt;/p&gt;
&lt;p&gt;function Dice(props) {
console.log(props)
return &lt;img src={diceBlue01} alt=&quot;주사위&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
위 코드들 처럼 App 함수에서 사용하는 Dice 컴포넌트에 color라는 속성을 blue로 지정해주고, Dice 함수 내부에서 props라는 파라미터를 하나 만들어 출력해보면 브라우저 콘솔에는 다음과 같은 출력 결과가 나타나게 됩니다.&lt;/p&gt;
&lt;p&gt;{ color: &quot;blue&quot; }
그래서 컴포넌트를 활용할 때 속성값을 다양하게 전달하고 이 props 값을 활용하면, 똑같은 컴포넌트라도 전달된 속성값에 따라 서로 다른 모습을 그려낼 수도 있게 됩니다.&lt;/p&gt;
&lt;p&gt;App.js&lt;/p&gt;
&lt;p&gt;import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;Dice color=&quot;red&quot; num={2} /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
Dice.js&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;
import diceBlue02 from &apos;./assets/dice-blue-2.svg&apos;;
// ...
import diceRed01 from &apos;./assets/dice-red-1.svg&apos;;
import diceRed02 from &apos;./assets/dice-red-2.svg&apos;;
// ...&lt;/p&gt;
&lt;p&gt;const DICE_IMAGES = {
blue: [diceBlue01, diceBlue02],
red: [diceRed01, diceRed02],
};&lt;/p&gt;
&lt;p&gt;function Dice(props) {
const src = DICE_IMAGES[props.color][props.num - 1];
const alt = &lt;code class=&quot;language-text&quot;&gt;${props.color} ${props.num}&lt;/code&gt;;
return &lt;img src={src} alt={alt} /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
참고로, 이렇게 props가 객체 형태를 띠고 있으니 Destructuring 문법을 활용해서 조금 더 간결하게 코드를 작성할 수도 있겠죠?&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;
import diceBlue02 from &apos;./assets/dice-blue-2.svg&apos;;
// ...
import diceRed01 from &apos;./assets/dice-red-1.svg&apos;;
import diceRed02 from &apos;./assets/dice-red-2.svg&apos;;
// ...&lt;/p&gt;
&lt;p&gt;const DICE_IMAGES = {
blue: [diceBlue01, diceBlue02],
red: [diceRed01, diceRed02],
};&lt;/p&gt;
&lt;p&gt;function Dice({ color = &apos;blue&apos;, num = 1 }) {
const src = DICE_IMAGES[color][num - 1];
const alt = &lt;code class=&quot;language-text&quot;&gt;${color} ${num}&lt;/code&gt;;
return &lt;img src={src} alt={alt} /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
Children
props에는 children이라는 조금 특별한 프로퍼티(prop, 프롭)가 있습니다.&lt;/p&gt;
&lt;p&gt;JSX 문법으로 컴포넌트를 작성할 때 컴포넌트를 단일 태그가 아니라 여는 태그와 닫는 태그의 형태로 작성하면, 그 안에 작성된 코드가 바로 이 children 값에 담기게 됩니다.&lt;/p&gt;
&lt;p&gt;Button.js&lt;/p&gt;
&lt;p&gt;function Button({ children }) {
return &lt;button&gt;{children}&lt;/button&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Button;
App.js&lt;/p&gt;
&lt;p&gt;import Button from &apos;./Button&apos;;
import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;Button&gt;던지기&lt;/Button&gt;
&lt;Button&gt;처음부터&lt;/Button&gt;
&lt;/div&gt;
&lt;Dice color=&quot;red&quot; num={2} /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
그래서 JSX 문법으로 컴포넌트를 작성할 때 어떤 정보를 전달할 때는 일반적인 props의 속성값을 주로 활용하고, 화면에 보여질 모습을 조금 더 직관적인 코드로 작성하고자 할 때 children 값을 활용할 수가 있습니다.&lt;/p&gt;
&lt;p&gt;참고로 이 children을 활용하면 단순히 텍스트만 작성하는 걸 넘어서 컴포넌트 안에 컴포넌트를 작성할 수도 있고, 컴포넌트 안에 복잡한 태그들을 더 작성할 수도 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React commponent 문법]]></title><description><![CDATA[리액트 엘리먼트
JSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다. import ReactDOM from 'react-dom'; const element = 안녕 리액트!;
console.log(element);
ReactDOM.r…]]></description><link>https://nicorobinv.github.io/React-study_2/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_2/</guid><pubDate>Sat, 21 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;리액트 엘리먼트
JSX 문법으로 작성한 요소는 결과적으로 자바스크립트 객체가 됩니다.&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;const element = &lt;h1&gt;안녕 리액트!&lt;/h1&gt;;
console.log(element);
ReactDOM.render(element, document.getElementById(&apos;root&apos;));
{$$typeof: Symbol(react.element), type: &quot;h1&quot;, key: null, ref: null, props: {…}, …}
이런 객체를 리액트 엘리먼트라고 부르는데요.&lt;/p&gt;
&lt;p&gt;이 리액트 엘리먼트를 ReactDOM.render 함수의 아규먼트로 전달하게 되면, 리액트가 객체 형태의 값을 해석해서 HTML 형태로 브라우저에 띄워주는 것이죠.&lt;/p&gt;
&lt;p&gt;리액트 엘리먼트는 리액트로 화면을 그려내는데 가장 기본적인 요소입니다.&lt;/p&gt;
&lt;p&gt;리액트 컴포넌트
리액트 컴포넌트는 리액트 엘리먼트를 조금 더 자유롭게 다루기 위한 하나의 문법입니다.&lt;/p&gt;
&lt;p&gt;컴포넌트를 만드는 가장 간단한 방법은 자바스크립트의 함수를 활용하는 건데요.
아래 코드에서 JSX 문법으로 작성된 하나의 요소를 리턴하는 Hello 함수가 바로 하나의 컴포넌트입니다.&lt;/p&gt;
&lt;p&gt;이렇게 요소를 컴포넌트로 작성하게 되면 다양한 장점들이 있는데,
자세한 내용은 이후의 개념들을 하나씩 배워나가면서 차차 알아보도록 합시다!&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;function Hello() {
return &lt;h1&gt;안녕 리액트&lt;/h1&gt;;
}&lt;/p&gt;
&lt;p&gt;const element = (
&amp;#x3C;&gt;
&lt;Hello /&gt;
&lt;Hello /&gt;
&lt;Hello /&gt;
&amp;#x3C;/&gt;
);&lt;/p&gt;
&lt;p&gt;ReactDOM.render(element, document.getElementById(&apos;root&apos;));
그리고 이렇게 컴포넌트를 작성하면,
위 코드에서 element 변수 안의 JSX 코드에서 볼 수 있듯 컴포넌트 함수 이름을 통해 하나의 태그처럼 활용할 수가 있습니다.&lt;/p&gt;
&lt;p&gt;이런 특성을 모듈 문법으로 활용하면 훨씬 더 독립적으로 컴포넌트 특성에 집중해서 코드를 작성할 수가 있습니다.&lt;/p&gt;
&lt;p&gt;예시: Dice.js&lt;/p&gt;
&lt;p&gt;import diceBlue01 from &apos;./assets/dice-blue-1.svg&apos;;&lt;/p&gt;
&lt;p&gt;function Dice() {
return &lt;img src={diceBlue01} alt=&quot;주사위&quot; /&gt;;
}&lt;/p&gt;
&lt;p&gt;export default Dice;
예시: App.js&lt;/p&gt;
&lt;p&gt;import Dice from &apos;./Dice&apos;;&lt;/p&gt;
&lt;p&gt;function App() {
return (&lt;/p&gt;
&lt;div&gt;
&lt;Dice /&gt;
&lt;/div&gt;
);
}
&lt;p&gt;export default App;
한 가지 주의해야 할 부분은, 리액트 컴포넌트의 이름은 반드시 첫 글자를 대문자로 작성해야 한다는 것입니다.
컴포넌트 이름의 첫 글자가 소문자라면 오류가 발생하니깐 꼭 주의!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React JSX 문법]]></title><description><![CDATA[JSX란?
JSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다. import ReactDOM from 'react-do…]]></description><link>https://nicorobinv.github.io/React-study_1/</link><guid isPermaLink="false">https://nicorobinv.github.io/React-study_1/</guid><pubDate>Fri, 20 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JSX란?
JSX는 자바스크립트의 확장 문법인데요. 리액트로 코드를 작성할 때 HTML 문법과 비슷한 이 JSX 문법을 활용하면 훨씬 더 편리하게 화면에 나타낼 코드를 작성할 수가 있게 됩니다.&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;h1&gt;안녕 리액트!&lt;/h1&gt;, document.getElementById(&apos;root&apos;));
JSX 문법
JSX는 자바스크립트로 HTML과 같은 문법을 사용할 수 있도록 만들어주는 편리한 문법이지만, 그만큼 꼭 지켜야 할 규칙들도 있습니다.&lt;/p&gt;
&lt;p&gt;HTML과 다른 속성명&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;속성명은 카멜 케이스로 작성하기!
JSX 문법에서도 태그에 속성을 지정해 줄 수 있습니다. 단, 여러 단어가 조합된 몇몇 속성들을 사용할 때는 반드시 카멜 케이스(Camel Case)로 작성해야 합니다.
사실 여러 단어가 조합된 HTML 속성들이 많진 않지만, 예를 들면 onclick, onblur, onfocus 등과 같은 이벤트 속성이나, tabindex 같은 속성들이 있습니다.
이런 속성들은 모두 onClick, onBlur, onFocus, onMouseDown, onMouseOver, tabIndex 처럼 작성하는 것이죠!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&lt;button onClick= ... &gt;클릭!&lt;/button&gt;,
document.getElementById(&apos;root&apos;)
);
단, 예외적으로 HTML에서 비표준 속성을 다룰 때 활용하는 data-* 속성은 카멜 케이스(Camel Case)가 아니라 기존의 HTML 문법 그대로 작성하셔야 합니다.&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;div&gt;
    상태 변경: 
    &lt;button className=&quot;btn&quot; data-status=&quot;대기중&quot;&gt;대기중&lt;/button&gt;
    &lt;button className=&quot;btn&quot; data-status=&quot;진행중&quot;&gt;진행중&lt;/button&gt;
    &lt;button className=&quot;btn&quot; data-status=&quot;완료&quot;&gt;완료&lt;/button&gt;
  &lt;/div&gt;,
  document.getElementById(&apos;root&apos;)
);
2. 자바스크립트 예약어와 같은 속성명은 사용할 수 없다!
JSX 문법도 결국은 자바스크립트 문법이기 때문에, for나 class처럼 자바스크립트의 문법에 해당하는 예약어와 똑같은 이름의 속성명은 사용할 수 없습니다.
그래서 HTML의 for의 경우에는 자바스크립트의 반복문 키워드 for와 겹치기 때문에 htmlFor로, HTML의 class 속성도 자바스크립트의 클래스 키워드 class와 겹치기 때문에 className으로 작성해 주어야 합니다.
&lt;p&gt;React 공식 문서 - 어트리뷰트의 차이&lt;/p&gt;
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;form&gt;
    &lt;label htmlFor=&quot;name&quot;&gt;이름&lt;/label&gt;
    &lt;input id=&quot;name&quot; className=&quot;name-input&quot; type=&quot;text&quot; /&gt;
  &lt;/form&gt;,
  document.getElementById(&apos;root&apos;)
);
반드시 하나의 요소로 감싸기 - Fragment
JSX 문법을 활용할 때는 반드시 하나의 요소로 감싸주어야 합니다. 그래서 아래 코드처럼 여러 개의 요소를 작성하면 오류가 발생하는데요.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;p&gt;안녕&lt;/p&gt;
  &lt;p&gt;리액트!&lt;/p&gt;,
  document.getElementById(&apos;root&apos;)
);
이럴 때는 아래 코드처럼 여러 태그를 감싸는 부모 태그를 만들어 하나의 요소로 만들어 주어야 합니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;안녕&lt;/p&gt;
    &lt;p&gt;리액트!&lt;/p&gt;
  &lt;/div&gt;,
  document.getElementById(&apos;root&apos;)
);
하지만 이렇게 작성한다면 때로는 꼭 필요하지 않은 부모 태그가 작성될 수 있겠죠? 그럴 땐 Fragment로 감싸주면 의미 없는 부모 태그를 만들지 않아도 여러 요소를 작성할 수 있습니다.
&lt;p&gt;import { Fragment } from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&lt;Fragment&gt;&lt;/p&gt;
&lt;p&gt;안녕&lt;/p&gt;
&lt;p&gt;리액트!&lt;/p&gt;
&lt;/Fragment&gt;,
document.getElementById(&apos;root&apos;)
);
참고로 Fragment는 아래 코드처럼 빈 태그로 감싸는 단축 문법으로 활용할 수도 있습니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&amp;#x3C;&gt;&lt;/p&gt;
&lt;p&gt;안녕&lt;/p&gt;
&lt;p&gt;리액트!&lt;/p&gt;
&lt;/&gt;,
document.getElementById(&apos;root&apos;)
);
자바스크립트 표현식 넣기
JSX 문법에서 중괄호({})를 활용하면 자바스크립트 표현식을 넣을 수 있습니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;const product = &apos;맥북&apos;;&lt;/p&gt;
&lt;p&gt;ReactDOM.render(&lt;/p&gt;
  &lt;h1&gt;나만의 {product} 주문하기&lt;/h1&gt;,
  document.getElementById(&apos;root&apos;)
);
이런 부분들을 잘 활용하면, 아래 코드처럼 중괄호 안에서 문자열을 조합할 수도 있고 변수에 이미지 주소를 할당해서 img 태그의 src 속성값을 전달해 줄 수도 있고, 이벤트 핸들러를 좀 더 편리하게 등록할 수도 있습니다.
&lt;p&gt;import ReactDOM from &apos;react-dom&apos;;&lt;/p&gt;
&lt;p&gt;const product = &apos;MacBook&apos;;
const model = &apos;Air&apos;;
const imageUrl = &apos;&lt;a href=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/MacBook_with_Retina_Display.png/500px-MacBook_with_Retina_Display.png&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/MacBook_with_Retina_Display.png/500px-MacBook_with_Retina_Display.png&lt;/a&gt;&apos;&lt;/p&gt;
&lt;p&gt;function handleClick(e) {
alert(&apos;곧 도착합니다!&apos;);
}&lt;/p&gt;
&lt;p&gt;ReactDOM.render(
&amp;#x3C;&gt;&lt;/p&gt;
&lt;h1&gt;{product + &apos; &apos; + model} 주문하기&lt;/h1&gt;
&lt;img src={imageUrl} alt=&quot;제품 사진&quot; /&gt;
&lt;button onClick={handleClick}&gt;확인&lt;/button&gt;
&lt;/&gt;,
document.getElementById(&apos;root&apos;)
);
단, JSX 문법에서 중괄호는 자바스크립트 표현식을 다룰 때 활용하기 때문에, 중괄호 안에서 for, if문 등의 문장은 다룰 수 없다는 점은 꼭 기억해 주세요.
그런데도 만약 JSX 문법을 활용할 때 조건문이 꼭 필요하다면 조건 연산자를, 반복문이 꼭 필요하다면 배열의 반복 메소드를 활용하자.</content:encoded></item><item><title><![CDATA[Git 협업하기 정리 노트]]></title><description><![CDATA[git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
git blame : 특정 파…]]></description><link>https://nicorobinv.github.io/Git-study_5/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_5/</guid><pubDate>Tue, 17 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
git blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력
git revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성&lt;/p&gt;</content:encoded></item><item><title><![CDATA[branch 정리 노트]]></title><description><![CDATA[git branch 새 브랜치 이름 : 새로운 브랜치를 생성
git checkout -b 새 브랜치 이름 : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
git branch -d 기존 브랜치 이름 : 브랜치 삭제
git checkout 기존 브랜…]]></description><link>https://nicorobinv.github.io/Git-study_4/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_4/</guid><pubDate>Tue, 17 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git branch [새 브랜치 이름] : 새로운 브랜치를 생성
git checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
git branch -d [기존 브랜치 이름] : 브랜치 삭제
git checkout [기존 브랜치 이름] : 그 브랜치로 이동
git merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지
git merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Git 내용 총정리 노트]]></title><description><![CDATA[Git 써보기
git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name 'codeit' : 현재 사용자의 …]]></description><link>https://nicorobinv.github.io/Git-study_6/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_6/</guid><pubDate>Tue, 17 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Git 써보기
git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name &apos;codeit&apos; : 현재 사용자의 아이디를 &apos;codeit&apos;으로 설정(커밋할 때 필요한 정보)
git config user.email &apos;teacher@codeit.kr&apos; : 현재 사용자의 이메일 주소를 &apos;teacher@codeit.kr&apos;로 설정(커밋할 때 필요한 정보)
git add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기
git add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기
git add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기
git reset [파일 이름] : staging area에 올렸던 파일 다시 내리기
git status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)
git commit -m &quot;커밋 메시지&quot; : 현재 staging area에 있는 것들 커밋으로 남기기
git help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력&lt;/p&gt;
&lt;p&gt;GitHub 시작하기
git push -u(또는 --set-upstream) origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.
git push : 위의 커맨드를 한번 실행하고 난 후에는 git push라고만 쳐도 로컬 레포지토리의 내용을 리모트 레포지토리에 올릴 수 있습니다.
git pull : 바로 위의 위에 있는 커맨드를 한번 실행하고 난 후에는 git pull이라고만 쳐도 리모트 레포지토리의 내용을 로컬 레포지토리로 가져옵니다.
git clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기&lt;/p&gt;
&lt;p&gt;Git에서 커밋 다루기
git log : 커밋 히스토리를 출력
git log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.
git show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인
git commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦
git config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로는 별명으로도 해당 커맨드를 실행할 수 있게 설정
git diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교
git reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)
(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;	(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)

	(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)

	그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;git tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임&lt;/p&gt;
&lt;p&gt;Git에서 브랜치 사용하기
git branch [새 브랜치 이름] : 새로운 브랜치를 생성
git checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동
git branch -d [기존 브랜치 이름] : 브랜치 삭제
git checkout [기존 브랜치 이름] : 그 브랜치로 이동
git merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지
git merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감&lt;/p&gt;
&lt;p&gt;Git 실전 I
git fetch : 로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져옴(가져오기만 한다는 점에서, 가져와서 머지까지 하는 git pull과는 차이가 있음)
git blame : 특정 파일의 내용 한줄한줄이 어떤 커밋에 의해 생긴 것인지 출력
git revert : 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성&lt;/p&gt;
&lt;p&gt;Git 실전 Ⅱ
git reflog : HEAD가 그동안 가리켜왔던 커밋들의 기록을 출력
git log --all --graph : 모든 브랜치의 커밋 히스토리를, 커밋 간의 관계가 잘 드러나도록 그래프 형식으로 출력
git rebase [브랜치 이름] : A, B 브랜치가 있는 상태에서 지금 HEAD가 A 브랜치를 가리킬 때, git rebase B를 실행하면 A, B 브랜치가 분기하는 시작점이 된 공통 커밋 이후로부터 존재하는 A 브랜치 상의 커밋들이 그대로 B 브랜치의 최신 커밋 이후로 이어붙여짐(git merge와 같은 효과를 가지지만 커밋 히스토리가 한 줄로 깔끔하게 된다는 차이점이 있음)
git stash : 현재 작업 내용을 스택 영역에 저장
git stash apply [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용
git stash drop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 스택에서 삭제
git stash pop [커밋 아이디] : 스택 영역에 저장된 가장 최근의(혹은 특정) 작업 내용을 working directory에 적용하면서 스택에서 삭제
git cherry-pick [커밋 아이디] : 특정 커밋의 내용을 현재 커밋에 반영
! 그 밖에 알아야할 사실&lt;/p&gt;
&lt;p&gt;(1) git commit이라고만 쓰고 실행하면 커밋 메시지를 입력할 수 있는 텍스트 에디터 창이 뜹니다. 거기서 커밋 메시지를 입력하고 저장하고 나면 커밋이 이루어집니다.&lt;/p&gt;
&lt;p&gt;(2) git push와 git pull은 그 작업 단위가 브랜치입니다. 예를 들어, master 브랜치에서 git push를 하면 master 브랜치의 내용만 리모트 레포지토리의 master 브랜치로 전송되지, premium 브랜치의 내용이 전송되는 것은 아닙니다.(git push에 --all이라는 옵션을 주면 모든 브랜치의 내용을 전송할 수 있기는 합니다.)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Blog test]]></title><description><![CDATA[오늘의 느낀점..github에서 저장소 생성할시에 readme 파일 생성하는건 잘생각하고 하자...]]></description><link>https://nicorobinv.github.io/first-post/</link><guid isPermaLink="false">https://nicorobinv.github.io/first-post/</guid><pubDate>Mon, 16 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;오늘의 느낀점..github에서 저장소 생성할시에 readme 파일 생성하는건 잘생각하고 하자...&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GitHub 시작하기 정리 노트]]></title><description><![CDATA[git push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.
git push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기
git pull : 리모트 레포지토리의 내용을 로컬 …]]></description><link>https://nicorobinv.github.io/Git-study_2/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_2/</guid><pubDate>Mon, 16 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.
git push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기
git pull : 리모트 레포지토리의 내용을 로컬 레포지토리로 가져오기
git clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기&lt;/p&gt;</content:encoded></item><item><title><![CDATA[commit 정리 노트]]></title><description><![CDATA[git log : 커밋 히스토리를 출력
git log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 …]]></description><link>https://nicorobinv.github.io/Git-study_3/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_3/</guid><pubDate>Mon, 16 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git log : 커밋 히스토리를 출력
git log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.
git show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인
git commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦
git config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로 별명으로 해당 커맨드를 실행할 수 있도록 설정
git diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교
git reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)
(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;	(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)

	(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)

	그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;git tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Git 써보기 정리 노트]]></title><description><![CDATA[git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name 'codeit' : 현재 사용자의 아이디를 'co…]]></description><link>https://nicorobinv.github.io/Git-study_1/</link><guid isPermaLink="false">https://nicorobinv.github.io/Git-study_1/</guid><pubDate>Mon, 16 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name &apos;codeit&apos; : 현재 사용자의 아이디를 &apos;codeit&apos;으로 설정(커밋할 때 필요한 정보)
git config user.email &apos;teacher@codeit.kr&apos; : 현재 사용자의 이메일 주소를 &apos;teacher@codeit.kr&apos;로 설정(커밋할 때 필요한 정보)
git add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기
git add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기
git add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기
git reset [파일 이름] : staging area에 올렸던 파일 다시 내리기
git status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)
git commit -m &quot;커밋 메시지&quot; : 현재 staging area에 있는 것들 커밋으로 남기기
git help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력&lt;/p&gt;</content:encoded></item></channel></rss>